<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>An Introduction to Sound Sunthesis with Wavelet Packets [ Intro ]</title>		<meta name="Version" content="8.0.3612">		<meta name="Date" content="2/24/97">		<meta name="Template" content="C:\PROGRAMAS\MICROSOFT OFFICE\OFFICE\html.dot">	</head>	<body text="black" link="blue" vlink="purple" bgcolor="white">		<font face="Times New Roman"><b>0. </b></font><a href="index.html"><font face="Times New Roman">Index</font></a><font face="Times New Roman"> <b>1.</b> <u>Intro</u> <b>2. </b><a href="mathcode.html">Mathematica code</a> <b>3. </b><a href="wpt.html">WPT</a> <b>4.</b> <a href="fwt.html">FWT</a> <b>5. </b><a href="ref.html">References</a></font>		<p><font face="Times New Roman">		<hr>		</font></p>		<h3><font size="4" face="Times New Roman,Georgia,Times"><b>1. Introducing Wavelets</b></font></h3>		<p><font face="Times New Roman">Wavelets are mathematical functions that can process complex data and facilitate the extraction of significant features by representing the data in frequency-space domain. Perhaps their most interesting characteristic is that the analyzed signals can be inspected simultaneously in several scales, giving us a coherent means of detecting both localized, small scale behavior, and broad range, gross properties. This analysis over several scales, is known as a <i>Multi-Resolution Analysis</i>.</font></p>		<p><font face="Times New Roman">When compared with Fourier techniques, wavelets have some similarities, as well as some advantages. They are both linear operations, with comparable computational expense, and there are fast window-type methods to perform both the FFT (Fast Fourier Transform) for Fourier analysis, and the FWT (Fast Wavelet Transform) for wavelet analysis. Both methods use convolution techniques to process a window of values (with size a power of two), and generate another window of data of the same size. Additionally, the transformation is performed in place (using the same array of data where the original signal was stored, to write the transformed signal), which makes both methods very neat and economic.</font></p>		<p><font face="Times New Roman">Where wavelets excel, is in the representation of the transformed signals. While in the case of FFT, the representing signals are sines and cosines, in the wavelet case this signals are special functions called mother wavelets. The big difference resides in the fact that while the representing signals for Fourier analysis are not localized in space (although they are in frequency), the wavelet basis are localized both in space, and in frequency domains. Also, the base functions are not a short set, as with Fourier's sines and cosines, but rather there is an infinity of wavelets that can be used (even if most of them are of no particular use). One of the most important wavelet basis are the ones found by Ingrid Daubechies. Its smallest (and more compact) element has only four coefficients, and is known as DAUB4. In general, the wavelet basis range from highly localized, rough wavelets, to very smooth, wide spread ones. An obvious tradeoff must be made, between smooth and compact.</font></p>		<h3><font face="Times New Roman"><b>The Wavelet Transform</b></font></h3>		<p><font face="Times New Roman">The easiest way I found so far, to understand wavelet transform's principles, is described in Wim Sweldens and Peter Schroder's paper <i>'Building Your Own Wavelets at home'</i>. We start by taking an example signal just two samples long. Lets call these samples <i>u</i> and <i>v</i>. A simple linear transform that would let us look at this short signal in other ways, would be to replace these samples by both their average (<i>a</i>) and their difference (<i>d</i>), like this:</font></p>		<center>			<p><font face="Times New Roman">a = (u + v) / 2</font></p>		</center>		<center>			<p><font face="Times New Roman">d = v - u</font></p>		</center>		<p><font face="Times New Roman">This is a completely reversible process, since we can at any time recover the original signal, using:</font></p>		<center>			<p><font face="Times New Roman">u = a - d / 2</font></p>		</center>		<center>			<p><font face="Times New Roman">v = a + d / 2</font></p>		</center>		<p><font face="Times New Roman">Now, if the original signal was not too rapidly changing (if it was a <i>smooth</i> signal), then probably the difference will be a very small value, and replacing it with zero (better yet, discarding it entirely), will not yield significant changes, when reconstructing the signal back, by the above method. Therefore, we have a means of representing a signal that was initially 2 samples long, by using fewer samples.</font></p>		<p><font face="Times New Roman">The wavelet transform achieves this same goal over a vector of samples, using a couple of FIR filters: a low-pass filter (<i>H</i>) for the <i>sum</i> (<i>s</i>), and a high-pass filter (<i>G</i>) for the <i>difference</i> (<i>d</i>). These filters are specially related to each other to form what is called a <i>quadrature mirror pair.</i> The signal passes through the filter pair, and results in a vector of the same length, but in which half the values will be the <i>detail coefficients</i>, resulting from the high-pass filter, and the other half will be <i>smooth coefficients</i>, from the low-pass filter output. The output of each filter is a signal the same length of the original, so, in order to fit both <i>smooth</i> and <i>detail</i> data in a vector of the same length, half the coefficients (every other one) is discarded, through a process known as <i>decimation</i> (<i>downsampling by half </i>- the frequency range of the filtered signal will be half of the original, so according to Nyquist, half the samples are enough to fully describe the signal). Then, after sorting the interleaved <i>smooth</i> and <i>detail</i> coefficients, into their own half of the signal table, the same quadrature filter pair is again applied to the signal, but only to the smooth half, resulting in a smooth-smooth quarter and a smooth-detail quarter (remember we preserved the other half, with the detail coefficients). The details are always preserved, and the smooth part is consecutively double-filtered until only a trivial number of smooth-smooth-smooth-... coefficients remains (usually 2). As I said, the process is completely reversible.</font></p>		<p><font face="Times New Roman">So, what have we gained by doing so? Well, hopefully, the signal will exhibit some coherent behavior over time, and will have some smooth evolution. In this case, the <i>detail coefficients</i>, will be very small, and rounding them off, wont have a big impact in the reconstructed signal. In fact, if the signal is not too wild, we can simply discard all coefficients below a certain threshold, and the inverse wavelet transformation will still regenerate a signal very much like the original. So, using the wavelet transform, we can use less space to store a given signal, and still preserve its significant features. This provides a method for data compression, which is one of the primary applications for wavelets. The compressing ratio, will be higher for smooth signals, and furthermore, the wavelet basis should be chosen in a way as to maximize the number of near-zero <i>detail coefficients</i>. That way, a larger number of coefficients can be discarded.</font></p>		<p><font face="Times New Roman">Additionally, each successive application of the algorithm, reveals the signal's shape, being analyzed at increasingly coarser resolutions. At each application of the filter pair, we analyze data one octave down, thus by controlling the depth of the transform, we can observe data at various levels of detail, or at various resolutions. An analogy can be made with those gradual-downloading images we see on the net (block DCT, or JPEG format): at first only the smooth-smooth-smooth-... coefficients (which are very few) are sent, resulting in a picture made of big averaged blurs of color, and a very crude detail, but as the transmission proceeds, each new set of coefficients (every step up the number of coefficients increases by a factor of 2) is also sent, resulting in successive increases in definition, until all the detail of the original picture, finally emerges.</font></p>		<h3><font face="Times New Roman"><b>The Boundary Effect</b></font></h3>		<p><font face="Times New Roman">The algorithms we'll be using, simple as they are, suffer from a limitation, usually taken as problematic. For the sake of simplifying the formulation and the implementation of the algorithm, the signal is assumed to be periodic, so that in a window of samples, the beginning and ending of the signal have the same amplitude. This simplifying assumption has no effect over the wave packet synth instrument, but when dealing with the fast wavelet transform, and since our signals will hardly fit the periodicity requirement, we will get 'glitches' on the window boundaries, when we reconstruct the signal (you'll have a chance of confirming that for yourself, once we study the FWT instrument). This is an inconvenience, and several methods have been used to overcome it. Developing an aperiodic wavelet transform instrument, is unfortunately beyond the scope of this introductory paper, so I invite the curious reader to check some of the solutions that have been proposed, using the links provided in the reference section.</font></p>		<h3><font face="Times New Roman"><b>Wave-Packets</b></font></h3>		<p><font face="Times New Roman">Wave packets are a generalization of wavelets. If, when calculating the wavelet transform, not only we apply the filter-pair to the <i>smooth coefficients</i>, but also to the <i>detail coefficients</i>, and proceed recursively, expanding the wavelet tree in all directions, instead of just down to the left, as in the plain wavelet case, we arrive at the wave-packet tree:</font></p>		<center>			<p><font face="Times New Roman"><img src="figures/wptree.gif" width="401" height="161"></font></p>		</center>		<p><font face="Times New Roman">Shown in bold, are the operations (<i>sum</i> and <i>difference</i>) required to calculate the wavelet transform part of the tree. Expanding the whole tree leads to many basis wavelet packets (of which the wavelet transform is a particular case), each one sufficient to regenerate the original signal. Not all wave packets are equally suited for a particular application, so one must choose the best wave-packets (the <i>best-basis</i>) to represent the problem at hand.</font></p>		<h3><font face="Times New Roman"><b>Applications</b></font></h3>		<p><font face="Times New Roman">Wickerhauser suggested that wave packets could be used in the synthesis of audio signals. Specifically, if we anticonvolved a signal made of a single one, and the remain with zeros, the result would be a sonic burst in the time domain (a <i>toneburst</i>). Different wave packets would produce different tones, and by experimentation, a musician could choose the more appropriate. Since the algorithm is so fast, this could replace a large number of oscillators.</font></p>		<p><font face="Times New Roman">Another application, would be as a sample compression tool, to be used in sampler-type instruments. Instrument samples could be compressed using appropriate wave packets, and the coefficients stored. During performance it would suffice to load the coefficients into a wave-packet generator, which would then recreate the original sound. Other aspects of the particular instrument, like timbre dynamics, could be mimic by using amplitude and filter envelopes. Alternatively, longer packets could be used and these characteristics encoded in the wave-packets themselves.</font></p>		<p><font face="Times New Roman">A very effective application, consists of the denoising of noisy data. Since the wavelet transformation decomposes the input signal into average and detail coefficients, and since these detail coefficients correspond to the details, or sharp edges, of the signal, one can perform denoising by simply rounding the small coefficients off. In fact, simply setting to zero all detail coefficients that lie below a predetermined threshold, can have a great effect in eliminating noise from a given source, without compromising general characteristic behavior of the data.</font></p>		<h3><font face="Times New Roman"><b>Some Pictures of Tonebursts</b></font></h3>		<p><font face="Times New Roman">This is the familiar graph obtained by using Daubechies' filters (in this case DAUB4). These wavelet basis have a fractal nature, and exhibit self-similarity when closely inspected.</font></p>		<center>			<p><font face="Times New Roman"><img src="figures/tburst1.gif" width="151" height="168"></font></p>		</center>		<p><font face="Times New Roman">&nbsp;</font></p>		<p><font face="Times New Roman">Here's a more complex (but rather uninteresting) toneburst, using a Coifman filter, and a different sequence of H's and G's</font></p>		<center>			<p><font face="Times New Roman"><img src="figures/tburst2.gif" width="261" height="180"></font></p>		</center>		<center>			<p><font face="Times New Roman">&nbsp;</font></p>		</center>		<p><font face="Times New Roman">More appealing tonebursts can be generated with some experimentation with the type of filter and the filter sequence:</font></p>		<center>			<p><font face="Times New Roman"><img src="figures/tburst3.gif" width="190" height="155"></font></p>		</center>		<center>			<p><font face="Times New Roman"><img src="figures/tburst4.gif" width="400" height="182">&nbsp;</font></p>		</center>		<p><font face="Times New Roman">&nbsp;</font></p>		<p><font face="Times New Roman">These pictures were all obtained with the <a href="instruments/wpt.orc">WPT.ORC</a> and <a href="instruments/wpt.sco">WPT.SCO</a> instrument we'll study right away.&nbsp;</font></p>		<p><font face="Times New Roman">		<hr>		</font></p>		<p><font face="Times New Roman"><b>0. </b><a href="index.html">Index</a> <b>1.</b> <u>Intro</u> <b>2. </b><a href="mathcode.html">Mathematica code</a> <b>3. </b><a href="wpt.html">WPT</a> <b>4.</b> <a href="fwt.html">FWT</a> <b>5. </b><a href="ref.html">References</a></font>	</body></html>