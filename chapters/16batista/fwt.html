<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>An Introduction to Sound Sunthesis with Wavelet Packets [ FWT ]</title>		<meta name="Version" content="8.0.3612">		<meta name="Date" content="2/24/97">		<meta name="Template" content="C:\PROGRAMAS\MICROSOFT OFFICE\OFFICE\html.dot">	</head>	<body text="black" link="blue" vlink="purple" bgcolor="white">		<b>0. </b><a href="index.html">Index</a><b> 1. </b><a href="wavelet.html">Intro</a> <b>2. </b><a href="mathcode.html">Mathematica code</a> <b>3.</b> <a href="wpt.html">WPT</a> <b>4. </b><u>FWT</u> <b>5. </b><a href="ref.html">References</a>		<p>		<hr>		</p>		<h3><b>4. The Fast Wavelet Transform Instrument...</b></h3>		<p>Next we'll be analyzing the design issues behind the making of the <a href="instruments/fwt.orc">FWT.ORC</a> and <a href="instruments/fwt.sco">FWT.SCO</a> instrument.</p>		<p>The original code was intended to perform convolution/decimation and conversely anticonvolution, on a wave-packet perspective. At each pass, the signal to be convolved only needed to go through one filter (either H or G according to the particular wave packet). Similarly, each anticonvolution stage only used a single filter (again, either H or G, depending on the specific wave packet) to generate the anticonvolved signal. In order to perform the fast wavelet transform, some adjustments must be made: first, when convolve-decimating, the original signal must go through both the H filter (to obtain the left half portion of the resulting signal) and the G filter (generating in the right half portion of the resulting signal); second, when anti-convolving the wavelet, the resulting signal must take in account both the H and G filters, as well as both the leftmost (H) and rightmost (G) portions of the wavelet coefficients.</p>		<p>The following graph should help clear things up. We start with a signal of size 16 (in this illustrating example), and convolve and decimate down till all is left is a single H coefficient (the overall average of the original signal) and a bunch of detail coefficients (all the G portions from levels 1 to 4). Indicated on the graph are also the array start and end positions for each of the levels; the intermediate wavelets are being stored contiguously in zak space, and hopefully this simplified graph serves the purpose of organizing our ideas for the programming.</p>		<p><img src="figures/wlevels.gif" width="497" height="190"></p>		<p>&nbsp;</p>		<p>For additional support, here are the equivalent C-like routines that perform the Convolution and Anticonvolution stages of the FWT. Notice how the routines are adapted from the more generic wave-packet case.</p>		<p>		<table cellspacing="0" border="0" width="633">			<tr>				<td valign="top" colspan="4">float *ConvolveDecimate(float *filter, float *vector)</td>			</tr>			<tr>				<td valign="top" colspan="4">{</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="3">vectorLen=length(vector);</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="3">filterRng=length(filter);</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="3">for(i=0; i&lt;vectorLen/2; ++i) {</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">for(j=0,sumH=0, sumG=0; j&lt;filterRng; j++) {</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td width="72%" valign="top">sumH+=filter[j]*vector[(2*i+j)%vectorLen];</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td width="72%" valign="top">sumG+=mirror[j]*vector[(2*i+j)%vectorLen];</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">}</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">tmpVec[i]=sumH;</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">tmpVec[i+vectorLen/2]=sumG;</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="3">}</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="3">return tmpVec;</td>			</tr>			<tr>				<td valign="top" colspan="4">}</td>			</tr>		</table>		</p>		<p>&nbsp;</p>		<p>		<table cellspacing="0" border="0" width="637">			<tr>				<td valign="top" colspan="5">float *AntiConvolve(float filter[], float vector[])</td>			</tr>			<tr>				<td valign="top" colspan="5">{</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="4">vectorLen=length(vector);</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="4">filterRng=length(filter);</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="4">newLen=2*vectorLen;</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="4">for(i=0; i&lt;newLen; ++i) tmpVec[i] = 0.0;</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="4">for(j=0; j&lt;vectorLen; ++j)</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td valign="top" colspan="3">for(i=0; i&lt;filterRng; i++)</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">tmpVec[(2*j+i)%newLen]+=vector[j]*filter[i]+</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td width="9%" valign="top">&nbsp;</td>				<td width="30%" valign="top">&nbsp;</td>				<td width="43%" valign="top">vector[j+vectorLen]*mirror[i];</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="4">return tmpVec;</td>			</tr>			<tr>				<td valign="top" colspan="5">}</td>			</tr>		</table>		</p>		<p>&nbsp;</p>		<p><b>The orchestra </b><a href="instruments/fwt.orc">FWT.ORC</a></p>		<p>The processing has been split over several instruments to help debugging and provide more clarity. The first instrument just initializes the filters. Suffice to set it's start and duration times both to zero, since all it does is init-time code. The only parameter is then the filter number, from one up to the three standard filters available.</p>		<p>instr 1; InitializeFilters</p>		<p>; p4 = filter number (1 to 3)</p>		<p>endin</p>		<p>The second instrument gathers the sound to be transformed. I just use soundin to read a specified soundfile. The pointer number for the soundin is passed through parameter p5. This instrument writes blocks of ksmps samples to a function table, using the <i>tablewa</i> ugen, so an additional value must be passed (p4) denoting the number of the signal table to write the samples to. This brings us to one of the idiosyncrasies of this program: since tablewa must have a table of size &gt;= ksmps to write to, we'll use a signal window size that is (a power of two, and) as close as possible to ksmps, without being less than ksmps. For a sample rate of 44100, we see by inspection that not many fit solutions exist. I've chosen here to use a value of ksmps = 490, which corresponds to a signal table (window) size of 512. Some other possible values are:</p>		<center>			<p>			<table cellspacing="0" border="0" cellpadding="2" width="384">				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2"><u><b>sr</b></u></font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2"><u><b>kr</b></u></font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2"><u><b>ksmps</b></u></font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2"><u><b>window size</b></u></font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">2940</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">15</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">16</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">1470</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">30</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">32</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">700</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">63</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">64</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">350</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">126</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">128</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">175</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">252</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">256</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">90</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">490</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">512</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">45</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">980</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">1024</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">25</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">1764</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">2048</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">12</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">3675</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">4096</font></center>					</td>				</tr>				<tr height="16">					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">44100</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">6</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">7350</font></center>					</td>					<td width="25%" valign="top" height="16">						<center>							<font face="Arial" size="2">8192</font></center>					</td>				</tr>			</table>			</p>		</center>		<p>The table must be initialized with zeros, since the wavelet transform will act through the whole table, although only the beginning ksmps samples are actually played.</p>		<p>instr 2; InitializeSound</p>		<p>; p4 = signal table number</p>		<p>; p5 = soundin file number</p>		<p>endin</p>		<p>Next we have the FWT stage. This was also written using i-code, since it makes debugging easier, but it can be easily converted to k-code once its stable. Notice that in order to have this instrument run on every k-cycle, the instrument must be constantly <i>reiniting</i> (as will the equivalent anticonvolution instrument), otherwise the code would only run once at the beggining. The parameters used are the signal's table number and size, and an additional value denoting the wavelet size to reach (this must, of course, be a lower power of two than the signal size). The instrument writes consecutive stages of the wavelet transform, in zak-space, following the organization depicted in the picture above. Finally it internally informs the next (inverse-transform) instrument, of the position and wavelet size where it left, so that things can be reconstructed from the bottom up.</p>		<p>instr 3; ConvolveDecimate</p>		<p>; p4 = signal table number</p>		<p>; p5 = signal table size</p>		<p>; p6 = lowest wavelet size (level down to go)</p>		<p>endin</p>		<p>At this point we have our wavelet, consisting of p6/2 smooth coefficients, and all the detail coefficients that were generated down to the lowest level. This would be the place to apply denoising, or thresholding routines, prior to reconstructing the signal. It is no big hassle to insert another instrument, in sequence, here, working with k-rate (or <i>reinit</i>ed i-rate) over the array of data.</p>		<p>&nbsp;</p>		<p>The inverse-transform instrument is in every sense similar to the convolution instrument, only working backwards. The lowest wavelet size is passed internally, but the signal's table number and size must also be supplied. At the end the instrument reloads the signal table with the reconstructed signal, and we're ready to sound the reconstructed samples.</p>		<p>instr 5; AntiConvolve</p>		<p>; p4 = signal table number</p>		<p>; p5 = signal table size</p>		<p>endin</p>		<p>Thats what we do in the last instrument, merely table-reading ksmps with <i>tablera</i>, and outputting them. The only needed parameter is the signal table number.</p>		<p>instr 6; PlaySound</p>		<p>; p4 = signal table number</p>		<p>endin</p>		<p>&nbsp;</p>		<p><b>The score </b><a href="instruments/fwt.sco">FWT.SCO</a></p>		<p>The score file invokes all instruments. Remember that the order in which they run cant be changed, and furthermore, the convolution and anticonvolution instruments must be run through the whole time that the sound in &amp; out instruments are active.</p>		<p>First of all we need a table to store the windowed signal. Its size must be bigger than ksmps, and its content must be initialized with zeros. Also, to keep things coherent, this function table number and size must be supplied to the ConvolveDecimate and AntiConvolve instruments.</p>		<p>;signal table</p>		<p>f10 0 512 -7 0 512 0</p>		<p>Next we need to choose a filter from the five available in this implementation. This next instrument takes care of that, once you specify a filter number. As discussed, this instrument should have both its start and duration times set to zero.</p>		<p>;initialize filter</p>		<p>		<table cellspacing="0" border="0" width="212">			<tr>				<td width="38%" valign="top">;</td>				<td width="62%" valign="top">					<center>						filter (1-3)</center>				</td>			</tr>			<tr>				<td width="38%" valign="top">i1 0 0</td>				<td width="62%" valign="top">					<center>						1</center>				</td>			</tr>		</table>		</p>		<p>This following instrument (which pairs with the last instrument) is responsible for the sound input. The soundin number you provide will be used to load the signal table (specified as the <i>vectab</i> parameter) in 512-samples chunks. Again, its up to you to change this signal generating instrument to something different. All you have to do is to fill a table with ksmps samples, at each k-cycle. For test purposes you can use <a href="instruments/soundin.1">soundin.1</a> as the input sample.</p>		<p>;in sound</p>		<p>		<table cellspacing="0" border="0">			<tr>				<td width="80" valign="top">					<center>						;vectab</center>				</td>				<td width="94" valign="top">					<center>						soundin.#</center>				</td>				<td width="94"></td>			</tr>			<tr>				<td width="80" valign="top">i2 0 .5</td>				<td width="94" valign="top">					<center>						10</center>				</td>				<td width="94" valign="top">					<center>						1</center>				</td>			</tr>		</table>		</p>		<p>At last the FWT routines are applied over the signal. The necessary parameters are the signal table's number and size, and additionally the lowest wavelet size to reach (the <i>wavsz</i> parameter).</p>		<p>;* * ConvolveDecimate * *</p>		<p>		<table cellspacing="0" border="0" width="382">			<tr>				<td width="14%" valign="top">;</td>				<td width="12%" valign="top">					<center>						str</center>				</td>				<td width="12%" valign="top">					<center>						dur</center>				</td>				<td width="20%" valign="top">					<center>						vectab</center>				</td>				<td width="20%" valign="top">					<center>						vecsz</center>				</td>				<td width="22%" valign="top">					<center>						wavsz</center>				</td>			</tr>			<tr>				<td width="14%" valign="top">i3</td>				<td width="12%" valign="top">					<center>						0</center>				</td>				<td width="12%" valign="top">					<center>						.5</center>				</td>				<td width="20%" valign="top">					<center>						10</center>				</td>				<td width="20%" valign="top">					<center>						512</center>				</td>				<td width="22%" valign="top">					<center>						2</center>				</td>			</tr>		</table>		</p>		<p>It may seem wasteful to just anticonvolve it immediately, but this is just an academic program, intended to give us some working knowledge. Should we want some kind of denoising, or compression implemented (hey, thats the whole point), and this would be the right place to put it.</p>		<p>This instrument must be numbered in between the convolution and anticonvolution instruments, so it must be instr 4 (more instruments could be inserted if we shifted the last instruments numbering to provide space). As for the code, it can be k-code looping over the internal vector table (table 10), and performing some kind of operation. To perform compression, you need to save all the non-zero coefficients, as well as their position! To perform denoising you apply a threshold over all positions of the table, as we'll see down below.</p>		<p>Finally, we're ready to anticonvolve the whole wavelet, and regenerate the original signal. Our next instrument does just that, requiring that we pass it the signal table's number and size. The result should be just exactly the same as the input signal. Unfortunatelly things are not so simple, and due to the 'boundary effect' you will get unwanted irregularities in the outcome, more or less spaced according to the wavelet window size.</p>		<p>;* * AntiConvolve * *</p>		<p>		<table cellspacing="0" border="0" width="297">			<tr>				<td width="17%" valign="top">;</td>				<td width="16%" valign="top">					<center>						str</center>				</td>				<td width="16%" valign="top">					<center>						dur</center>				</td>				<td width="25%" valign="top">					<center>						vectab</center>				</td>				<td width="25%" valign="top">					<center>						vecsz</center>				</td>			</tr>			<tr>				<td width="17%" valign="top">i5</td>				<td width="16%" valign="top">					<center>						0</center>				</td>				<td width="16%" valign="top">					<center>						.5</center>				</td>				<td width="25%" valign="top">					<center>						10</center>				</td>				<td width="25%" valign="top">					<center>						512</center>				</td>			</tr>		</table>		</p>		<p>And thats it, really. All that remains to do now is to sound the samples we just reconstructed, using the <i>tablera</i> ugen. Thats the purpose of the last instrument.</p>		<p>;out sound</p>		<p>		<table cellspacing="0" border="0" width="155">			<tr>				<td width="58%" valign="top">;</td>				<td width="42%" valign="top">					<center>						vectab</center>				</td>			</tr>			<tr>				<td width="58%" valign="top">i6 0 .5</td>				<td width="42%" valign="top">					<center>						10</center>				</td>			</tr>		</table>		</p>		<p>e</p>		<p>		<hr>		</p>		<p><i><b>Denoising</b></i></p>		<p>For this humble attempt at denoising (the <a href="instruments/denoiser.orc">DENOISER.ORC</a> and <a href="instruments/denoiser.sco">DENOISER.SCO</a> files), I restructured the code, in order for it to save the results (of the convolution/anticonvolution) in the same signal table used for the input sample, as the process goes along through each new stage. This facilitates inserting an instrument between the <i>ConvolveDecimate</i> and <i>AntiConvolve</i> instruments, to process the wavelet transform coefficients in some way, as now all coefficients are stored sequentially in a single vector table. I've place a 'denoising' instrument there, just to prove my point.</p>		<p>This design has another advantage: if you comment the <i>AntiConvolve</i> instrument activation line in the score, what will actually be output will be the wavelet coefficients themselves. Take care because they may exceed the audio range, resulting in clipping. But with the necessary caution, you will see a burst of audio, that gradually extinguishes, in a more or less peaceful way.</p>		<p>For instance, if we took this audio signal, and <i>ConvolveDecimate</i> it</p>		<center>			<p><img src="figures/wave1.gif" width="245" height="160"></p>		</center>		<p>this would give rise to a set of wavelet coefficients shaped like this</p>		<center>			<p><img src="figures/wave2.gif" width="247" height="162"></p>		</center>		<p>Notice how the rightmost coefficients are all zero or close to zero? Of course a different signal, would give rise to a differently shaped wavelet. This provides, just like FFT, a sonic <i>fingerprint</i> of the audio. Reshaping this wavelet will have numerous results, but not being particularly knowledgeable in wavelets, I can only find out by experimentation, exactly what these results will be. But we can use the power of csound to reshape this table at will, so its not like we're short on options. I've even tried combining several wavelets (for different signals) and regenerating the result. Not surprisingly, the effect of regenerating a set of coefficients that are averaged from the input signals respective coefficients, is just the same as if we averaged (mixed) the signals directly in the time domain. Dont forget that FWT is a linear operation...</p>		<p>To perform denoising, we will base ourselves in the work of D. L. Donoho, regarding wavelet shrinkage. The wavelet transform of white noise is white noise, and consequently, the wavelet coefficients of a noisy signal, will be affected by the same noise as the original signal was. Here's what we could expect the wavelet shape to be, if we superimposed white noise to the signal prior to applying the FWT:</p>		<center>			<p><img src="figures/wave3.gif" width="247" height="162"></p>		</center>		<p>Now there's some fixed noise level, over all the wavelet coefficients. In practice, simply discarding coefficients below some level, wont do, because this will also eliminate many coefficients on the left side of the graph and have an undesired effect over the real coefficients, those that represent the signal. A <i>soft-threshold </i>method will be used instead, in particular the simple wavelet shrinkage method (the coefficients are shrinked down to zero, by some threshold) developed by Donoho.</p>		<p>This technique requires that we estimate the median energy content of the coefficients at the lowest level. In practice this will be an intensity factor we'll be supplying from the score.</p>		<p>Applying the denoising method with a an empiricaly determined energy estimation (sigma), changes the look of the wavelet to:</p>		<center>			<p><img src="figures/wave4.gif" width="248" height="162"></p>		</center>		<p>Which is close enough to the original. It is not possible with the naive methodology I've used in this demonstrative instrument, to fully eliminate the noise without loosing some character of the sound. But I hope you get the notion as to the potential of these techniques.</p>		<p>&nbsp;</p>		<p>Here's the <a href="instruments/denoiser.orc">DENOISER.ORC</a> and <a href="instruments/denoiser.sco">DENOISER.SCO</a>, for you to experiment. I've added some white noise to <a href="instruments/soundin.1">soundin.1</a>, which resulted in the noisy <a href="instruments/soundin.2">soundin.2</a>, that you can use for test purposes.</p>		<p>&nbsp;</p>		<p>The score has a bunch of instruments running sequentially. I only did it like this to compartment things, but it could all just be a long instrument.</p>		<p>;in sound<br>		; str dur soundin<br>		i2 0 .5 2 ; &lt;--- change soundin.#<br>		<br>		;* * ConvolveDecimate * *<br>		; str dur wavsz<br>		i3 0 .5 2<br>		<br>		;* * Denoiser * *<br>		; str dur sigma<br>		i4 0 .5 18000 ; &lt;--- estimated power<br>		<br>		;* * AntiConvolve * *<br>		; str dur<br>		i5 0 .5<br>		<br>		;out sound<br>		; str dur<br>		i6 0 .5</p>		<p>As&nbsp;a consequence of this design, all instruments must be running during the same time and for the whole performance, in order for things to be properly executed.</p>		<p>You can comment the <i>denoiser </i>(i4) and <i>anticonvolve</i> (i5) instruments, to observe the shape of the wavelet for the particular soundin number you supplied. Or you can just comment the <i>anticonvolve</i> (i5) instrument, and observe the effect the <i>denoiser</i> instrument is having over the coefficients. Keep in mind the fact that the coefficient values can often exceed the audio range, resulting in clipping, something that speakers and, most importantly, ear-drums dont seem to appreciate.</p>		<p>&nbsp;</p>		<p>		<hr>		</p>		<p><b>0. </b><a href="index.html">Index</a><b> 1. </b><a href="wavelet.html">Intro</a> <b>2. </b><a href="mathcode.html">Mathematica code</a> <b>3.</b> <a href="wpt.html">WPT</a> <b>4. </b><u>FWT</u> <b>5. </b><a href="ref.html">References</a></p>		<p>&nbsp;	</body></html>