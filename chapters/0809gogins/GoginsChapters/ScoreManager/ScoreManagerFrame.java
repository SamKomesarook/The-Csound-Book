package GoginsChapters.ScoreManager;
//	S I L E N C E
//	A system for making music on computers by means of software alone.
//	Copyright (C) 1997 by Michael Gogins. All rights reserved.
//	P U R P O S E
//	A platform-independent graphical user interface for Csound.
import java.io.*;
import java.awt.*;
import java.net.*;
import javax.swing.*;

class ScoreManagerFrame extends Frame
{
	//	Score manager.
	public ScoreManager scoreManager = null;
	//	User interfaces.
    private IDD_DIALOG_FUNCTIONS iddDialogFunctions = null;
	private IDD_DIALOG_INSTRUMENT iddDialogInstrument = null;
	private IDD_DIALOG_INSTRUMENT_TEST iddDialogInstrumentTest = null;
	private IDD_DIALOG_NOTE iddDialogNote = null;
	private IDD_DIALOG_ORCHESTRA iddDialogOrchestra = null;
	private IDD_DIALOG_SCORE_OPTIONS iddDialogScoreOptions = null;
	private IDD_DIALOG_SOUNDFILE_OPTIONS iddDialogSoundfileOptions = null;
	//  Scratch variables.
	float hue;
	float saturation;
	float brightness;
    Image buffer = null;
	Insets insets = null;
	int border;
	int width;
	int height;
	Graphics bg = null;
	double start;
	double octave;
	double length;
	double end;
	double instrument;
	double decibels;
	double startMin;
	double startMax;
	double startIncrement;
	double startSubscript;
	double octaveMin;
	double octaveMax;
	double octaveIncrement;
	double octaveSubscript;
	double startMove;
	double startScale;
	double octaveMove;
	double octaveScale;
	double instrumentMove;
	double instrumentScale;
	public ScoreManagerFrame(String string, ScoreManager manager)
	{
		super(string);
		scoreManager = manager;
		setBackground(Color.white);
	}
	//	The handleEvent() method receives all events generated within the frame
	//	window. You can use this method to respond to window events. To respond
	//	to events generated by menus, buttons, etc. or other controls in the
	//	frame window but not managed by the applet, override the window's
	//	action() method.
	public boolean handleEvent(Event event)
	{
		switch (event.id)
		{
			//	Application shutdown (e.g. user chooses Close from the system menu).
			case Event.WINDOW_DESTROY:
				if(event.target instanceof ScoreManagerFrame)
				{
					//	TODO: Place additional clean up code here
					dispose();
					//	System.exit(0);
					return true;
				}
				else if(event.target instanceof Dialog)
				{
					iddDialogFunctions = null;
					return true;
				}
			case Event.ACTION_EVENT:
				if(event.target instanceof MenuItem)
				{
					String string = ((MenuItem)event.target).getLabel();
					if(string.equals("New score..."))
					{
						scoreManager.initialize();
						repaint();
						return true;
					}
					else if(string.equals("Open score..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Open ScoreManager score", FileDialog.LOAD);
						fileDialog.setFile("*.osc");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.initialize();
						scoreManager.load(filename);
						scoreManager.filename = filename;
						repaint();
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Save score"))
					{
						scoreManager.save(scoreManager.filename);
						return true;
					}
					else if(string.equals("Save score as..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Save ScoreManager score", FileDialog.SAVE);
						fileDialog.setFile("*.osc");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.filename = filename;
						scoreManager.save(scoreManager.filename);
						setTitle("Score Manager: " + scoreManager.filename);
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Import score..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Import ScoreManager score", FileDialog.LOAD);
						fileDialog.setFile("*.osc");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.load(filename);
						repaint();
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Export score..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Export ScoreManager score", FileDialog.SAVE);
						fileDialog.setFile("*.scr");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.save(filename);
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Exit..."))
					{
						dispose();
						System.exit(0);
						return true;
					}
					else if(string.equals("Edit functions..."))
					{
						DialogFunctions dialog = new DialogFunctions(this);
						dialog.show();
						return true;
					}
					else if(string.equals("Delete all functions"))
					{
						scoreManager.functionsDelete();
						return true;
					}
					else if(string.equals("Import functions..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Import function definitions", FileDialog.LOAD);
						fileDialog.setFile("*.sco");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.functionsLoad(filename);
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Export functions..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Export function definitions", FileDialog.SAVE);
						fileDialog.setFile("*.sco");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.functionsSave(filename);
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Edit orchestra..."))
					{
						DialogOrchestra dialog = new DialogOrchestra(this);
						dialog.show();
						return true;
					}
					else if(string.equals("Delete all instruments"))
					{
						scoreManager.instrumentsDelete();
						return true;
					}
					else if(string.equals("Import orchestra..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Import instrument definitions", FileDialog.LOAD);
						fileDialog.setFile("*.orc");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.instrumentsLoad(filename);
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Export orchestra..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Export instrument definitions", FileDialog.SAVE);
						fileDialog.setFile("*.orc");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.orchestraSave(filename);
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Edit notes..."))
					{
						DialogNote dialog = new DialogNote(this);
						dialog.show();
						repaint();
						return true;
					}
					else if(string.equals("Delete all notes"))
					{
						scoreManager.notesDelete();
						repaint();
						return true;
					}
					else if(string.equals("Scale..."))
					{
						DialogNoteScale dialog = new DialogNoteScale(this);
						dialog.show();
						invalidate();
						repaint();
						return true;
					}
					else if(string.equals("Rescale actual to target"))
					{
						setCursor(WAIT_CURSOR);
						scoreManager.scaleActualToTargetSet();
						repaint();
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Import notes..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Import note definitions", FileDialog.LOAD);
						fileDialog.setFile("*.sco");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.notesLoad(filename);
						repaint();
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Export notes..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Export note definitions", FileDialog.SAVE);
						fileDialog.setFile("*.sco");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.notesSave(filename);
						setCursor(DEFAULT_CURSOR);
						return true;
					}
					else if(string.equals("Score options..."))
					{
						DialogScoreOptions dialog = new DialogScoreOptions(this);
						dialog.show();
						return true;
					}
					else if(string.equals("Play midifile..."))
					{
						return true;
					}
					else if(string.equals("Edit midifile..."))
					{
						return true;
					}
					else if(string.equals("Import midifile..."))
					{
						FileDialog fileDialog = new FileDialog(this, "Import midifile", FileDialog.LOAD);
						fileDialog.setFile("*.mid");
						fileDialog.show();
						if(fileDialog.getFile() == null)
						{
							return true;
						}
						setCursor(WAIT_CURSOR);
						String filename = fileDialog.getDirectory() + fileDialog.getFile();
						scoreManager.midifileImport(filename);
						repaint();
						setCursor(DEFAULT_CURSOR);
					    return true;
					}
					else if(string.equals("Export midifile..."))
					{
						return true;
					}
					else if(string.equals("Render soundfile..."))
					{
						scoreManager.soundfileRender();
						return true;
					}
					else if(string.equals("Stop rendering"))
					{
						scoreManager.soundfileStopRendering();
					}
					else if(string.equals("Play soundfile..."))
					{
						scoreManager.soundfilePlay();
						return true;
					}
					else if(string.equals("Edit soundfile..."))
					{
					    //scoreManager.soundfileEdit();
					    return true;
					}
					else if(string.equals("Soundfile options..."))
					{
						DialogSoundfileOptions dialog = new DialogSoundfileOptions(this);
						dialog.show();
						return true;
					}
				}
			}
		return super.handleEvent(event);
	}
	public void paint(Graphics g)
	{
		try
		{
			//	Do not paint if there are no notes.
			int i = 0;
			int n = scoreManager.notes.size();
			if(n <= 0)
			{
				return;
			}
			setTitle(scoreManager.filename + " " + scoreManager.notes.size() + " notes");
			//	Find the bounding hypercube of note space.
			scoreManager.scaleActualFind();
			//	Do not paint if any of its to-be-rendered spans is not a floating point number.
			if(scoreManager.scaleActualRanges.startGet() < Float.MIN_VALUE || 
				scoreManager.scaleActualRanges.octaveGet() < Float.MIN_VALUE)
			{
				return;
			}
			setCursor(WAIT_CURSOR);
			buffer = null;
			//	Create a copy of the frame window image buffer in memory.
			//	Margins.
			insets = insets();
			border = 5;
			width = bounds().width - (insets.left + insets.right);
			height = bounds().height - (insets.bottom + insets.top);
			buffer = createImage(width, height);
			if(buffer == null)
			{
				scoreManager.showStatus("Null image buffer.");
				return;
			}
			//	Create a graphics context for it.
			bg = buffer.getGraphics();
			if(bg == null)
			{
				scoreManager.showStatus("Null graphics context.");
				return;
			}
			//	Corresponding ranges and grid things.
			startMin = scoreManager.scaleActualMinima.startGet();
			//	Assume that the longest note is the last.
			startMax = startMin + scoreManager. scaleActualRanges.startGet() + 
				scoreManager.scaleActualRanges.lengthGet();
			startIncrement = 10;
			octaveMin = scoreManager.scaleActualMinima.octaveGet();
			octaveMax = octaveMin + scoreManager.scaleActualRanges.octaveGet();
			octaveIncrement = 1;
			//	Scaling factors.
			startMove = - startMin;
			startScale = width / (startMax - startMin);
			octaveMove = - octaveMin;
			octaveScale = height / (octaveMax - octaveMin);
			instrumentMove = - scoreManager.scaleActualMinima.instrumentGet();
			instrumentScale = scoreManager.scaleActualRanges.instrumentGet();
			//	Avoid black notes if ranges == 0.
			if(instrumentScale == 0.0)
			{
				instrumentScale = 1.0;
			}
			else
			{
				instrumentScale = 1.0 / instrumentScale;
			}
			double decibelsMove = - scoreManager.scaleActualMinima.decibelsGet();
			double decibelsScale = scoreManager.scaleActualRanges.decibelsGet();
			if(decibelsScale == 0.0)
			{
				decibelsScale = 1.0;
			}
			else
			{
				decibelsScale = 1.0 / decibelsScale;
			}
			//	Everything we paint is just a line segment.
			int x1;
			int y1;
			int x2;
			int y2;
			//	Draw a blue-green grid at intervals of 1 octave and 10 seconds.
			//	Vertical lines.
			bg.setColor(new Color(0, 128, 128));
			for(startSubscript = startMin; startSubscript <= startMax; startSubscript += startIncrement)
			{
				x1 = (int)((startSubscript + startMove) * startScale);
				x2 = x1;
				bg.drawLine(x1, 0, x2, height);
			}
			//	Horizontal lines.
			for(octaveSubscript = octaveMin; octaveSubscript <= octaveMax; octaveSubscript += octaveIncrement)
			{
				//	Middle C is red.
				if(octaveSubscript > 7.5 && octaveSubscript < 8.5)
				{
					bg.setColor(Color.red);
				}
				else
				{
					bg.setColor(new Color(0, 128, 128));
				}
				y1 = (int)((octaveSubscript + octaveMove) * octaveScale);
				y2 = y1;
				bg.drawLine(0, height - y1, width, height - y1);
			}
			//	Draw the notes themselves.
			Note note = null;
			//	Instrument is mapped onto hue, decibels onto brightness.
			//	No note should be too white of hue or too bright.
			saturation = 1;
			boolean useEqualTemperament = Boolean.valueOf(scoreManager.scoreOptions.getProperty("UseEqualTemperament")).booleanValue();
			double temperament = Double.valueOf(scoreManager.scoreOptions.getProperty("DivisionsPerOctave")).doubleValue();
			//	Try to compensate for rounding errors when displaying
			//	already tempered scores as tempered.
			double temperamentRound = (1 / temperament) / 2;
			for(i = 0; i < n; ++i)
			{
				note = (Note) scoreManager.notes.elementAt(i);
				start = note.startGet();
				end = start + note.lengthGet();
				octave = note.octaveGet();
				instrument = note.instrumentGet();
				decibels = note.decibelsGet();
				x1 = (int)((start + startMove) * startScale);
				x2 = (int)((end + startMove) * startScale);
				if(useEqualTemperament)
				{
					octave = ((int)((octave + temperamentRound) * temperament)) / temperament;
				}
				y1 = 0 + (int)((octave + octaveMove) * octaveScale);
				y2 = y1;
				//	Round instrument down to nearest integer as Csound does.
				hue = (float)((((int)instrument) + instrumentMove) * instrumentScale);
				brightness = (float)((decibels  + decibelsMove) * decibelsScale);
				bg.setColor(Color.getHSBColor(hue, saturation, brightness));
				if(x1 == x2)
				{
					++x2;
				}
				bg.drawLine(x1, height - y1, x2, height - y2);
			}
			//	Copy the image buffer onto the actual graphics screen.
			boolean returnValue = g.drawImage(buffer, insets.right, insets.top, Color.black, this);
		}
		catch(Exception e)
		{
			scoreManager.showStatus("ScoreManagerFrame.paint(): " + e.getMessage());
		}
		setCursor(Frame.DEFAULT_CURSOR);
	}
}
