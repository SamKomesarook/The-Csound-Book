package GoginsChapters.ScoreManager;
//	S I L E N C E
//	A system for making music on computers by means of software alone.
//	Copyright (C) 1997 by Michael Gogins. All rights reserved.
//	P U R P O S E
//	A platform-independent graphical user interface for Csound.
import java.applet.*;
import java.awt.*;
import java.util.*;
import java.io.*;
import java.net.*;

public class ScoreManager extends Applet implements Runnable
{
	//	Csound data members.
	String filename;
	public String functions;
	public Properties instruments;
	public Vector arrangement;
	public Vector notes;
	public Note scaleTargetMinima;
	public Note scaleTargetRanges;
	public Note scaleActualMinima;
	public Note scaleActualRanges;
	public Properties soundfileOptions;
	public Properties scoreOptions;
	public String instrumentTestScore;
	//	Execute a "DOS" type console program and pull stdout out of it.
	ProcessConsole processConsole = new ProcessConsole();
	//	User interface members.
	//	Generated by Visual J++.
	IDR_MENU idrMenu = null;
	ScoreManagerFrame frame = null;
	//	THREAD SUPPORT:
	//	m_ScoreManager	is the Thread object for the applet
	Thread m_ScoreManager = null;
	//	STANDALONE APPLICATION SUPPORT:
	//	m_fStandAlone will be set to true if applet is run standalone
	boolean m_fStandAlone = false;
	//	PARAMETER SUPPORT:
	//	Parameters allow an HTML author to pass information to the applet;
	//	the HTML author specifies them using the <PARAM> tag within the <APPLET>
	//	tag.  The following variables are used to store the values of the
	//	parameters.
    //	Members for applet parameters
    //	<type>       <MemberVar>    = <Default Value>
	private String m_OrchestraFilename = "";
	private String m_FunctionsFilename = "";
	private String m_ScoreFilename = "";
    //	Parameter names.  To change a name of a parameter, you need only make
	//	a single change.  Simply modify the value of the parameter string below.
	private final String PARAM_OrchestraFilename = "OrchestraFilename";
	private final String PARAM_FunctionsFilename = "FunctionsFilename";
	private final String PARAM_ScoreFilename = "ScoreFilename";
	//	STANDALONE APPLICATION SUPPORT
	//	The GetParameter() method is a replacement for the getParameter() method
	//	defined by Applet. This method returns the value of the specified parameter;
	//	unlike the original getParameter() method, this method works when the applet
	//	is run as a standalone application, as well as when run within an HTML page.
	//	This method is called by GetParameters().
	String GetParameter(String strName, String args[])
	{
		if (args == null)
		{
			//	Running within an HTML page, so call original getParameter().
			return getParameter(strName);
		}	
		//	Running as standalone application, so parameter values are obtained from
		//	the command line. The user specifies them as follows:
		//
		//	JView ScoreManager param1=<val> param2=<"val with spaces"> ...
		int i;
		String strArg	= strName + "=";
		String strValue = null;
		for (i = 0; i < args.length; i++)
		{
			if (strArg.equalsIgnoreCase(args[i].substring(0, strArg.length())))
			{
				//	Found matching parameter on command line, so extract its value.
				//	If in double quotes, remove the quotes.
				strValue= args[i].substring(strArg.length());
				if (strValue.startsWith("\""))
				{
					strValue = strValue.substring(1);
					if (strValue.endsWith("\""))
					{
						strValue = strValue.substring(0, strValue.length() - 1);
					}
				}
			}
		}
		return strValue;
	}
	//	STANDALONE APPLICATION SUPPORT
	// 	The GetParameters() method retrieves the values of each of the applet's
	//	parameters and stores them in variables. This method works both when the
	//	applet is run as a standalone application and when it's run within an HTML
	//	page.  When the applet is run as a standalone application, this method is
	//	called by the main() method, which passes it the command-line arguments.
	//	When the applet is run within an HTML page, this method is called by the
	//	init() method with args == null.
	public void GetParameters(String args[])
	{
		//	Query values of all Parameters
		String parameter;
		//	OrchestraFilename: Parameter description
		parameter = GetParameter(PARAM_OrchestraFilename, args);
		if (parameter != null)
		{
			instrumentsLoad(parameter);
			m_OrchestraFilename = parameter;
		}
		//	FunctionsFilename: Parameter description
		parameter = GetParameter(PARAM_FunctionsFilename, args);
		if (parameter != null)
		{
			functionsLoad(parameter);
			m_FunctionsFilename = parameter;
		}	
		//	ScoreFilename: Parameter description
		parameter = GetParameter(PARAM_ScoreFilename, args);
		if (parameter != null)
		{
			load(parameter);
			m_ScoreFilename = parameter;
		}
	}
	
	//	STANDALONE APPLICATION SUPPORT
	// 	The main() method acts as the applet's entry point when it is run
	//	as a standalone application. It is ignored if the applet is run from
	//	within an HTML page.
	public static void main(String args[])
	{
		ScoreManager scoreManager = new ScoreManager();
		scoreManager.m_fStandAlone = true;
		scoreManager.GetParameters(args);
		scoreManager.init();
		scoreManager.start();
	}
	//	ScoreManager Class Constructor
	public ScoreManager()
	{
		initialize();
	}
	public void initialize()
	{
		filename = new String("Csound.osc");
		functions = new String();
		instruments = new Properties();
		arrangement = new Vector();
		notes = new Vector();
		scaleTargetMinima = new Note();
		scaleTargetRanges = new Note();
		scaleActualMinima = new Note();
		scaleActualRanges = new Note();
		soundfileOptions = new Properties();
		soundfileOptions.put("sr", "44100");
		soundfileOptions.put("ksmps", "10");
		soundfileOptions.put("kr", "441");
		soundfileOptions.put("nchnls", "2");
		soundfileOptions.put("Format", "A");
		soundfileOptions.put("Sample", "s");
		soundfileOptions.put("R", "R");
		soundfileOptions.put("g", "g");
		soundfileOptions.put("SoundPlayer", "MPLAYER");
		scoreOptions = new Properties();
		scoreOptions.put("UseEqualTemperament", "true");
		scoreOptions.put("DivisionsPerOctave", "12");
		scaleTargetMinima.instrumentSet(1);
		scaleTargetMinima.startSet(0);
		scaleTargetMinima.lengthSet(.5);
		scaleTargetMinima.octaveSet(6);
		scaleTargetMinima.decibelsSet(50);
		scaleTargetMinima.panSet(-.25);
		scaleTargetRanges.instrumentSet(4);
		scaleTargetRanges.startSet(250);
		scaleTargetRanges.lengthSet(4);
		scaleTargetRanges.octaveSet(6);
		scaleTargetRanges.decibelsSet(20);
		scaleTargetRanges.panSet(.5);
		instrumentTestScore = new String();
	}
	//	APPLET INFO SUPPORT:
	//	The getAppletInfo() method returns a string describing the applet's
	//	author, copyright date, or miscellaneous information.
	public String getAppletInfo()
	{
		return "Name: ScoreManager.\r\n" +
			"Copyright (C) 1997 by Michael Gogins.\r\n" +
			"Created with Microsoft Visual J++ Version 1.0.";
	}
	//	PARAMETER SUPPORT
	//	The getParameterInfo() method returns an array of strings describing
	//	the parameters understood by this applet.
	//
    //	ScoreManager Parameter Information:
    //  { "Name", "Type", "Description" },
	public String[][] getParameterInfo()
	{
		String[][] info =
		{
			{ PARAM_OrchestraFilename, "String", "Parameter description" },
			{ PARAM_FunctionsFilename, "String", "Parameter description" },
			{ PARAM_ScoreFilename, "String", "Parameter description" },
		};
		return info;
	}
	//	The init() method is called by the AWT when an applet is first loaded or
	//	reloaded.  Override this method to perform whatever initialization your
	//	applet needs, such as initializing data structures, loading images or
	//	fonts, creating frame windows, setting the layout manager, or adding UI
	//	components.
	public void init()
	{	
		if (!m_fStandAlone)
		{
			GetParameters(null);
		}
	    openWindow();
	}
	public void openWindow()
	{
   		frame = new ScoreManagerFrame("Score Manager", this);
		idrMenu = new IDR_MENU((Frame)frame);
	    idrMenu.CreateMenu();
	    frame.resize(640, 480);
		frame.show();
	}
	public void closeWindow()
	{
		frame.hide();
	}
	//	Place additional applet clean up code here.  destroy() is called when
	//	when you applet is terminating and being unloaded.
	public void destroy()
	{
		//	TODO: Place applet cleanup code here
	}
	
	//	The start() method is called when the page containing the applet
	//	first appears on the screen. The AppletWizard's initial implementation
	//	of this method starts execution of the applet's thread.
	public void start()
	{
		if (m_ScoreManager == null)
		{
			m_ScoreManager = new Thread(this);
			m_ScoreManager.start();
		}
	}
	//	The stop() method is called when the page containing the applet is
	//	no longer on the screen. The AppletWizard's initial implementation of
	//	this method stops execution of the applet's thread.
	public void stop()
	{
		if (m_ScoreManager != null)
		{
			m_ScoreManager.stop();
			m_ScoreManager = null;
		}
	}
	//	THREAD SUPPORT
	//	The run() method is called when the applet's thread is started. If
	//	your applet performs any ongoing activities without waiting for user
	//	input, the code for implementing that behavior typically goes here. For
	//	example, for an applet that performs animation, the run() method controls
	//	the display of images.
	public void run()
	{
		while (true)
		{
			try
			{
				Thread.sleep(50);
			}
			catch (InterruptedException e)
			{
				stop();
			}
		}
	}
	//	Csound object interfaces.
	//	Score management proper.
	public void noteAdd(double instrument, double start, double length, double octave, double decibels, double pan)
	{
		Note note = new Note();
		note.instrumentSet(instrument);
		note.startSet(start);
		note.lengthSet(length);
		note.octaveSet(octave);
		note.decibelsSet(decibels);
		note.panSet(pan);
		notes.addElement(note);
	}
	public void noteAdd(Note note)
	{
		notes.addElement(note.clone());
	}
	public boolean noteGet(int subscript, double instrument, double start, double length, double octave, double decibels, double pan)
	{
		if(subscript < 0 || subscript >= notes.size())
		{
			return false;
		}
		Note note = (Note) notes.elementAt(subscript);
		instrument = note.instrumentGet();
		start = note.startGet();
		length = note.lengthGet();
		octave = note.octaveGet();
		decibels = note.decibelsGet();
		pan = note.panGet();
		return true;
	}
	public Note noteGet(int subscript)
	{
		return (Note) notes.elementAt(subscript);
	}
	
	public boolean noteSet(int subscript, double instrument, double start, double length, double octave, double decibels, double pan)
	{
		if(subscript < 0 || subscript >= notes.size())
		{
			return false;
		}
		Note note = (Note) notes.elementAt(subscript);
		note.instrumentSet(instrument);
		note.startSet(start);
		note.lengthSet(length);
		note.octaveSet(octave);
		note.decibelsSet(decibels);
		note.panSet(pan);
		return true;
	}
	public boolean noteSet(Note note, int subscript)
	{
		if(subscript < 0 || subscript >= notes.size())
		{
			return false;
		}
		notes.setElementAt(note.clone(), subscript);
		return true;
	}
	public boolean noteDelete(int subscript)
	{
		if(subscript < 0 || subscript >= notes.size())
		{
			return false;
		}
		notes.removeElementAt(subscript);
		return true;
	}
	public void notesDelete()
	{
		notes.setSize(0);
	}
	public int notesCountGet()
	{
		return notes.size();
	}
	public void notesCountSet(int newCount)
	{
		notes.setSize(newCount);
	}
	public boolean scoreAdd(ScoreManager source)
	{
		if(source.notes.size() == 0)
		{
			return false;
		}
		Note note = null;
		for(Enumeration e = source.notes.elements(); e.hasMoreElements(); )
		{
			note = (Note) e.nextElement();
			notes.addElement(note.clone());
		}
		return true;
	}
	public boolean scoreAppend(ScoreManager source)
	{
		if(source.notes.size() == 0)
		{
			return false;
		}
		scaleActualFind();
		Note note = noteGet(notes.size() - 1);
		//	Start adding notes from the source score
		//	at the ending time of this score's last sounded note.
		double sourceStart = scaleActualMinima.startGet() + scaleActualRanges.startGet() + note.startGet();
		for(Enumeration e = source.notes.elements(); e.hasMoreElements(); )
		{
			note = (Note) e.nextElement();
			note.startSet(sourceStart + note.startGet());
			notes.addElement(note.clone());
		}
		return true;
	}
	public boolean scaleActualFind()
	{
		boolean returnValue = false;
		try
		{
			int i;
			int j;
			int n = notes.size();
			Note note = null;
			Note scaleActualMaxima = new Note();
			double d = 0;
			double min = 0;
			double max = 0;
			for(j = 0; j < 6; j++)
			{
				scaleActualMinima.setElementAt(Double.MAX_VALUE, j);
				scaleActualMaxima.setElementAt(- Double.MAX_VALUE, j);
			}
			for(i = 0; i < n; i++)
			{
				note = (Note) notes.elementAt(i);
				for(j = 0; j < 6; j++)
				{
					d = note.elementAt(j);
					min = scaleActualMinima.elementAt(j);
					max = scaleActualMaxima.elementAt(j);
					if(d <= min)
					{
						scaleActualMinima.setElementAt(d, j);
					}
					if(d  >= max )
					{
						scaleActualMaxima.setElementAt(d, j);
					}
				}
			}
			for(j = 0; j < 6; j++)
			{
				double range = 0;
				double minimum = 0;
				double maximum = 0;
				minimum = scaleActualMinima.elementAt(j);
				maximum = scaleActualMaxima.elementAt(j);
				//	Avoid exceptions on too small a range.
				if(minimum == Double.NaN || maximum == Double.NaN)
				{
					range = 0;
				}
				else
				{
					range = maximum - minimum;
				}
				scaleActualRanges.setElementAt(range, j);
			}
			returnValue = true;
		}
		catch(Exception e)
		{
			showStatus("ScoreManager.scaleActualFind()" + e.getMessage());
			returnValue = false;
		}
		return returnValue;
	}
	public boolean scaleTargetToActualSet()
	{
		try
		{
			boolean returnValue = scaleActualFind();
			scaleTargetMinima = (Note) scaleActualMinima.clone();
			scaleTargetRanges = (Note) scaleActualRanges.clone();
		}
		catch(Exception e)
		{
			showStatus(e.getMessage());
			return false;
		}
		return true;
	}
	public boolean scaleActualToTargetSet()
	{
		boolean returnValue = true;
		try
		{
			returnValue = scaleActualFind();
			int i;
			int j;
			int n = notes.size();
			Note note = null;
			Note rescale = new Note();
			double a;
			double t;
			double d;
			for(j = 0; j < 6; j++)
			{   
				if(Math.abs(scaleActualRanges.elementAt(j)) > Float.MIN_VALUE)
				{
					t = scaleTargetRanges.elementAt(j);
					a = scaleActualRanges.elementAt(j);
					d = t / a;
					rescale.setElementAt(d, j);
				}
				else
				{
					rescale.setElementAt(1, j);
				}
			}             
			for(i = 0; i < n; i++)
			{  
				note = (Note) notes.elementAt(i);
				if(note != null)
				{
					for(j = 0; j < 6; j++)
					{                    
						double moveToOrigin = scaleActualMinima.elementAt(j);
						double scale = rescale.elementAt(j);
						double moveToTarget = scaleTargetMinima.elementAt(j);
						d = note.elementAt(j);
						d = d - moveToOrigin;
						d = d * scale;
						d = d + moveToTarget;
						note.setElementAt(d, j);
					}
				}
			}                 
			scaleActualFind();	
		}
		catch(Exception e)
		{
			showStatus(e.getMessage());
		}
		return returnValue;
	}
	//	Persistence.
	public boolean save(String newFilename)
	{
		boolean returnValue = false;
		try
		{
			filename = newFilename;
			FileOutputStream outputStream = new FileOutputStream(filename);
			PrintStream stream = new PrintStream(outputStream);
			write(stream);
			outputStream.close();
			returnValue = true;
		}
		catch(IOException ioException)
		{
			returnValue = false;
			showStatus(ioException.getMessage());
		}
		return returnValue;
	}
	public boolean write(PrintStream stream)
	{
		boolean returnValue;
		try
		{
			//	ScoreManagers and their components are always saved as
			//	tagged text in a format similar to that of HTML.
			//	The filename is not saved.
			String key = null;
			String value = null;
			stream.println("<CsScoreManager>");
			stream.println("<CsFunctions>");
			functionsWrite(stream);
			stream.println("</CsFunctions>");
			stream.println("<CsInstruments>");
			instrumentsWrite(stream);
			stream.println("</CsInstruments>");
			stream.println("<CsArrangement>");
			for(Enumeration e = arrangement.elements(); e.hasMoreElements(); )
			{
				String buffer = (String) e.nextElement();
				stream.println(buffer);
			}
			stream.println("</CsArrangement>");
			stream.println("<CsNotes>");
			notesWrite(stream);
			stream.println("</CsNotes>");
			stream.println("<CsScaleTargetMinima>");
			stream.println(scaleTargetMinima.stringGet());
			stream.println("</CsScaleTargetMinima>");
			stream.println("<CsScaleTargetRanges>");
			stream.println(scaleTargetRanges.stringGet());
			stream.println("</CsScaleTargetRanges>");
			stream.println("<CsScaleActualMinima>");
			stream.println(scaleActualMinima.stringGet());
			stream.println("</CsScaleActualMinima>");
			stream.println("<CsScaleActualRanges>");
			stream.println(scaleActualRanges.stringGet());
			stream.println("</CsScaleActualRanges>");
			stream.println("<CsSoundfileOptions>");
			for(Enumeration e = soundfileOptions.keys(); e.hasMoreElements(); )
			{
				key = (String) e.nextElement();
				value = soundfileOptions.getProperty(key);
				stream.println(key + "=" + value);
			}			
			stream.println("</CsSoundfileOptions>");
			stream.println("<CsScoreOptions>");
			for(Enumeration e = scoreOptions.keys(); e.hasMoreElements(); )
			{
				key = (String) e.nextElement();
				value = scoreOptions.getProperty(key);
				stream.println(key + "=" + value);
			}			
			stream.println("</CsScoreOptions>");
			stream.println("<CsTestScore>");
			stream.println(instrumentTestScore);
			stream.println("</CsTestScore>");
			stream.println("</CsScoreManager>");
			returnValue = true;
		}
		catch(IOException ioException)
		{
			returnValue = false;
			showStatus(ioException.getMessage());
		}
		return returnValue;
	}
	public boolean functionsSave(String filename)
	{
		boolean returnValue = false;
		try
		{
			FileOutputStream outputStream = new FileOutputStream(filename);
			PrintStream stream = new PrintStream(outputStream);
			functionsWrite(stream);
			outputStream.close();
			returnValue = true;
		}
		catch(IOException ioException)
		{
			returnValue = false;
		}
		return returnValue;
	}
	public void functionsWrite(PrintStream stream) throws IOException
	{
		stream.println(functions);
	}
	public boolean orchestraSave(String filename)
	{
		boolean returnValue = false;
		try
		{
			FileOutputStream outputStream = new FileOutputStream(filename);
			PrintStream stream = new PrintStream(outputStream);
			instrumentsWrite(stream);
			outputStream.close();
			returnValue = true;
		}
		catch(IOException ioException)
		{
			returnValue = false;
		}
		return returnValue;
	}
	
	public void instrumentsWrite(PrintStream stream) throws IOException
	{
		int i;
		Enumeration k;
		String name;
		String definition;
		for(i = 1, k = instruments.keys(); k.hasMoreElements(); i++)
		{
			name = (String) k.nextElement();
			definition = "instr " + String.valueOf(i) + " ; " + name + "\n" + instruments.getProperty(name) + "\nendin\n";
			stream.println(definition);
		}
	}	
	public boolean arrangementSave(String filename)
	{
		boolean returnValue = false;
		try
		{
			FileOutputStream outputStream = new FileOutputStream(filename);
			PrintStream stream = new PrintStream(outputStream);
			arrangementWrite(stream);
			outputStream.close();
			returnValue = true;
		}
		catch(IOException ioException)
		{
			returnValue = false;
		}
		return returnValue;
	}	
	public void arrangementWrite(PrintStream stream) throws IOException
	{
		String buffer;
		Integer sr = Integer.valueOf(soundfileOptions.getProperty("sr"));
		stream.println("sr = " + sr);
		Integer ksmps = Integer.valueOf(soundfileOptions.getProperty("ksmps"));
		int kr = sr.intValue() / ksmps.intValue();
		stream.println("kr = " + kr);
		stream.println("ksmps = " + ksmps);
		buffer = soundfileOptions.getProperty("nchnls");
		stream.println("nchnls = " + buffer);
		stream.println();
		for(int i = 0, n = arrangement.size(); i < n; i++)
		{
			String definition = "instr " + String.valueOf(i + 1) + "\n" + instruments.getProperty((String)arrangement.elementAt(i)) + "\nendin";
			stream.println(definition);
		}
	}	
	public boolean scoreSave(String filename)
	{
		boolean returnValue = true;
		try
		{
			FileOutputStream outputStream = new FileOutputStream(filename);
			PrintStream stream = new PrintStream(outputStream);
			scoreWrite(stream);
			outputStream.close();
			returnValue = true;
		}
		catch(IOException ioException)
		{
			returnValue = false;
		}
		return returnValue;
	}
	public void scoreWrite(PrintStream stream) throws IOException
	{
		functionsWrite(stream);
		notesWrite(stream);
	}
	public boolean notesSave(String filename)
	{
		boolean returnValue = false;
		try
		{
			FileOutputStream outputStream = new FileOutputStream(filename);
			PrintStream stream = new PrintStream(outputStream);
			notesWrite(stream);
			outputStream.close();
			returnValue = true;
		}
		catch(IOException ioException)
		{
			returnValue = false;
		}
		return returnValue;
	}
	public void notesWrite(PrintStream stream) throws IOException
	{
		Note note;
		Enumeration e;
		if(scoreOptions.getProperty("UseEqualTemperament").equals("true"))
		{
		    String temperamentString = scoreOptions.getProperty("DivisionsPerOctave");
		    double temperament = Double.valueOf(temperamentString).doubleValue();		    
    		for(e = notes.elements(); e.hasMoreElements(); )
	    	{
		    	note = (Note) e.nextElement();
				stream.println(note.stringGet(temperament));
	    	}
		}
		else
		{
    		for(e = notes.elements(); e.hasMoreElements(); )
	    	{
		    	note = (Note) e.nextElement();
				stream.println(note.stringGet());
	    	}
		}
	}
	public boolean load(String Filename)
	{
		boolean returnValue = false;
		try
		{
			FileInputStream inputStream = new FileInputStream(Filename);
			DataInputStream dataStream = new DataInputStream(inputStream);
			returnValue = read(dataStream);
			inputStream.close();
		}
		catch(IOException ioException)
		{
			returnValue = false;
			showStatus(ioException.getMessage());
		}
		return returnValue;
	}
	public boolean read(DataInputStream dataStream) throws IOException
	{
		try
		{
			for(;;)
			{
				String buffer = dataStream.readLine();
				if(buffer.startsWith("<CsScoreManager>"))
				{
				}
				else if(buffer.startsWith("</CsScoreManager>"))
				{
					return true;
				}
				else if(buffer.startsWith("<CsFunctions>"))
				{
					functionsRead(dataStream);
				}
				else if(buffer.startsWith("<CsInstruments>"))
				{
					instrumentsRead(dataStream);
				}
				else if(buffer.startsWith("<CsArrangement>"))
				{
					arrangementRead(dataStream);
				}
				else if(buffer.startsWith("<CsNotes>"))
				{
					notesRead(dataStream);
				}
				else if(buffer.startsWith("<CsScaleTargetMinima>"))
				{
					scaleTargetMinima.read(dataStream);
				}
				else if(buffer.startsWith("<CsScaleTargetRanges>"))
				{
					scaleTargetRanges.read(dataStream);
				}
				else if(buffer.startsWith("<CsScaleActualMinima>"))
				{
					scaleActualMinima.read(dataStream);
				}
				else if(buffer.startsWith("<CsScaleActualRanges>"))
				{
					scaleActualRanges.read(dataStream);
				}
				else if(buffer.startsWith("<CsSoundfileOptions>"))
				{
					soundfileOptionsRead(dataStream);
				}
				else if(buffer.startsWith("<CsScoreOptions>"))
				{
					scoreOptionsRead(dataStream);
				}
				else if(buffer.startsWith("<CsTestScore>"))
				{
					testScoreRead(dataStream);
				}
				if(buffer == null)
				{
					return true;
				}
			}
		}
		catch(EOFException eofException)
		{
			return true;
		}
	}
	public boolean functionsLoad(String filename)
	{
		boolean returnValue = false;
		try
		{
			FileInputStream inputStream = new FileInputStream(filename);
			DataInputStream dataStream = new DataInputStream(inputStream);
			returnValue = functionsRead(dataStream);
			inputStream.close();
		}
		catch(IOException e)
		{
			returnValue = false;
		}
		return returnValue;
	}
	public boolean functionsRead(DataInputStream dataStream) throws IOException
	{
		try
		{
			for(;;)
			{
				String buffer = dataStream.readLine();
				if(buffer == null)
				{
					return true;
				}
				else if(buffer.startsWith("</CsFunctions>"))
				{
					return true;
				}
				else if(buffer.startsWith("f"))
				{
					functions = functions + buffer + "\n";
				}
			}
		}
		catch(IOException ioException)
		{
			return false;
		}
	}
	public boolean instrumentsLoad(String filename)
	{
		boolean returnValue = false;
		try
		{
			FileInputStream inputStream = new FileInputStream(filename);
			DataInputStream dataStream = new DataInputStream(inputStream);
			returnValue = instrumentsRead(dataStream);
			inputStream.close();
		}
		catch(IOException e)
		{
			returnValue = false;
		}
		return returnValue;
	}
	public boolean instrumentsRead(DataInputStream dataStream) throws IOException
	{
		try
		{
			String name = "";
			String definition = "";
			for(int i = 1; true; i++)
			{
				String buffer = dataStream.readLine();
				if(buffer == null)
				{
					return true;
				}
				else if(buffer.startsWith("</CsInstruments>"))
				{
					return true;
				}
				else if(buffer.startsWith("instr"))
				{
					definition = "";
					if(buffer.indexOf(";") == -1)
					{
						name = String.valueOf(i);
					}
					else
					{
						name = buffer.substring(buffer.indexOf(";") + 1);
					}
					name = name.trim();
				}
				else if(buffer.startsWith("endin"))
				{
					instruments.put(name, definition);
				}
				else
				{
					definition = definition + buffer + "\n";
				}
			}
		}
		catch(IOException ioException)
		{
			return false;
		}
	}
	public boolean arrangementRead(DataInputStream dataStream) throws IOException
	{
		try
		{
			for(;;)
			{
				String buffer = dataStream.readLine();
				if(buffer == null)
				{
					return true;
				}
				else if(buffer.startsWith("</CsArrangement>"))
				{
					return true;
				}
				else
				{
					arrangement.addElement(buffer);				
				}
			}
		}
		catch(IOException ioException)
		{
			return false;
		}
	}
	public boolean notesLoad(String filename)
	{
		boolean returnValue = false;
		try
		{
			FileInputStream inputStream = new FileInputStream(filename);
			DataInputStream dataStream = new DataInputStream(inputStream);
			returnValue = notesRead(dataStream);
			inputStream.close();
		}
		catch(IOException e)
		{
			returnValue = false;
		}
		return returnValue;
	}
	
	public boolean notesRead(DataInputStream dataStream) throws IOException
	{
		try
		{
			String buffer;
			Note note;
			for(int i = 1; true; i++)
			{
				buffer = dataStream.readLine();
				if(buffer == null)
				{
					return true;
				}
				else if(buffer.startsWith("</CsNotes>"))
				{
					return true;
				}
				else if(buffer.startsWith("i"))
				{
					note = new Note(buffer);
					notes.addElement(note);
				}
			}
		}
		catch(IOException ioException)
		{
			return false;
		}
	}
	public boolean soundfileOptionsRead(DataInputStream dataStream)
	{
		try
		{
			String buffer;
			int subscript;
			for(int i = 1; true; i++)
			{
				buffer = dataStream.readLine();
				if(buffer == null)
				{
					return true;
				}
				else if(buffer.startsWith("</CsSoundfileOptions>"))
				{
					return true;
				}
				else if(buffer.startsWith("#"))
				{
				}
				else if((subscript = buffer.indexOf("=")) > 0 && buffer.length() > subscript + 1)
				{
					String key = buffer.substring(0, subscript);
					String value = buffer.substring(subscript + 1);
					soundfileOptions.put(key, value);
				}
			}
		}
		catch(IOException ioException)
		{
			return false;
		}
	}
	public boolean scoreOptionsRead(DataInputStream dataStream)
	{
		try
		{
			String buffer;
			int subscript;
			for(int i = 1; true; i++)
			{
				buffer = dataStream.readLine();
				if(buffer == null)
				{
					return true;
				}
				else if(buffer.startsWith("</CsScoreOptions>"))
				{
					return true;
				}
				else if(buffer.startsWith("#"))
				{
				}
				else if((subscript = buffer.indexOf("=")) > 0 && buffer.length() > subscript + 1)
				{
					String key = buffer.substring(0, subscript);
					String value = buffer.substring(subscript + 1);
					scoreOptions.put(key, value);
				}
			}
		}
		catch(IOException ioException)
		{
			return false;
		}
	}
	public boolean testScoreLoad(String filename)
	{
		boolean returnValue = false;
		try
		{
			FileInputStream inputStream = new FileInputStream(filename);
			DataInputStream dataStream = new DataInputStream(inputStream);
			returnValue = testScoreRead(dataStream);
			inputStream.close();
		}
		catch(IOException ioException)
		{
			returnValue = false;
		}
		return returnValue;
	}
	public boolean testScoreRead(DataInputStream dataStream) throws IOException
	{
		try
		{
			String buffer;
			for(int i = 1; true; i++)
			{
				buffer = dataStream.readLine();
				if(buffer == null)
				{
					return true;
				}
				else if(buffer.startsWith("</CsTestScore>"))
				{
					return true;
				}
				else if(buffer.startsWith("i"))
				{
					instrumentTestScore = instrumentTestScore + buffer + "\n";
				}
			}
		}
		catch(EOFException eofException)
		{
			return false;
		}
	}
	public void functionsDelete()
	{
		functions = "";
	}
	public void instrumentsDelete()
	{
		instruments.clear();
	}
	public String rootFilename()
	{
		String buffer;
		if(filename.indexOf(".") > 0)
		{
			buffer = filename.substring(0, filename.indexOf("."));
		}
		else
		{
			buffer = filename;
		}
		return buffer;
	}
	public String orchestraFilename()
	{
		return rootFilename() + ".orc";
	}	
	public String scoreFilename()
	{
		return rootFilename() + ".sco";
	}	
	public String soundfileName()
	{
		String buffer = rootFilename();
		if(soundfileOptions.getProperty("Format").equals("W"))
		{
			buffer = buffer + ".wav";
		}
		else if(soundfileOptions.getProperty("Format").equals("A"))
		{
			buffer = buffer + ".aif";
		}
		else if(soundfileOptions.getProperty("Format").equals("h"))
		{
			buffer = buffer + ".raw";
		}
		return buffer;
	}	
	public void soundfileStopRendering()
	{
		try
		{
			processConsole.destroy();
		}
		catch(Exception e)
		{
			showStatus(e.getMessage());
		}
	}
	public void soundfilePlay()
	{
		try
		{
			String commandLine = soundfileOptions.getProperty("SoundPlayer", "MPLAYER.EXE") + " " + soundfileName();
			Runtime runtime = Runtime.getRuntime();
			Process process = runtime.exec(commandLine);
		}
		catch(Exception e)
		{
			showStatus(e.getMessage());
		}
	}	
	//	Override this to catch exceptions when running standalone.
	public void showStatus(String message)
	{
		try
		{
			super.showStatus(message);
		}
		catch(Exception e)
		{
			System.out.println(message);
		}
	}
	public String filenameGet()
	{
		return filename;
	}
	public void filenameSet(String newValue)
	{
		if(newValue.indexOf(".") > 0)
		{
			filename = newValue.substring(0, newValue.indexOf("."));
		}
		filename = filename + ".osc";
	}
	public void soundfileRender()
	{
		try
		{
			arrangementSave(orchestraFilename());
			scoreSave(scoreFilename());
			String commandLine = csoundCommand();
			System.out.println("Csound command: " + commandLine);
			File file = new File(".");
			System.out.println("Csound executable should be in: " + file.getAbsolutePath());
			processConsole.exec(commandLine);
		}
		catch(Exception e)
		{
			showStatus(e.getMessage());
		}
	}
	public String csoundCommand()
	{
		String commandLine = "winsound -";
		String outputFilename = "";
		String orchestraFilename = "";
		String scoreFilename = "";
		String buffer = soundfileOptions.getProperty("Format");
		if(buffer != null)
		{
			commandLine = commandLine + buffer;
		}
		buffer = soundfileOptions.getProperty("Sample");
		if(buffer != null)
		{
			commandLine = commandLine + buffer;
		}
		buffer = soundfileOptions.getProperty("R");
		if(buffer != null)
		{
			commandLine = commandLine + buffer;
		}
		buffer = soundfileOptions.getProperty("Other");
		if(buffer != null)
		{
			commandLine = commandLine + buffer;
		}
		commandLine = commandLine + " -o " + soundfileName() + " ";
		commandLine = commandLine + orchestraFilename() + " ";
		commandLine = commandLine + scoreFilename();
		return commandLine;
	}
	public boolean midifileImport(String Filename) 
	{
	    try
	    {
	        int currentTick;
	        double deltaTicks;
	        //  Tempo in micro seconds per quarter note.
	        double tempo = 1000000.;	
	        double currentTime;
	        double deltaTime;
	        int eventSize;
	        byte nextByte;
	        byte status;
	        byte byteBuffer1;
	        byte byteBuffer2;
	        byte byteBuffer3;
	        byte byteBuffer4;
	        int	format;
	        int trackCount;
	        double ticksPerQuarterNote;
	        int i;
	        int trackIndex;
	        Vector MidiEvents = null;
	        MidiEvent midiEvent = null;
	        MidiEvent noteOnEvent = null;
	        MidiEvent noteOffEvent = null;
	        RandomAccessFile randomAccessFile = new RandomAccessFile(Filename, "r");
	        byteBuffer1 = randomAccessFile.readByte();	
	        byteBuffer2 = randomAccessFile.readByte();
	        byteBuffer3 = randomAccessFile.readByte();
	        byteBuffer4 = randomAccessFile.readByte();
	        if(byteBuffer1 != 'M' || byteBuffer2 != 'T' || byteBuffer3 != 'h' || byteBuffer4 != 'd')
	        {
	            System.out.println("This is not a standard MIDI file.");
	            return false;
	        }
            //  Skip length.
            randomAccessFile.skipBytes(4);  
	        byteBuffer1 = randomAccessFile.readByte();
	        byteBuffer2 = randomAccessFile.readByte();
	        format = (byteBuffer1 << 8) + byteBuffer2;
	        byteBuffer1 = randomAccessFile.readByte();
	        byteBuffer2 = randomAccessFile.readByte();
	        trackCount = (byteBuffer1 << 8) + byteBuffer2;
	        byteBuffer1 = randomAccessFile.readByte();
	        byteBuffer2 = randomAccessFile.readByte();
	        ticksPerQuarterNote = (byteBuffer1 << 8) + byteBuffer2;
	        System.out.println("Importing midifile...");
	        System.out.println("p1 = midi channel + 1");
	        System.out.println("p2 = starting time (seconds)");
	        System.out.println("p3 = length (seconds)");
	        System.out.println("p4 = pitch (linear octaves, middle C = 8.0)");
	        System.out.println("p5 = amplitude (midi velocity)");
	        System.out.println("p6 = pan (p1 / 16.0 - 0.5)");
	        for(trackIndex = 0; trackIndex < trackCount; trackIndex++)
	        {
	            System.out.println("Track " + trackIndex);
    	        MidiEvents = new Vector();
	            byteBuffer1 = randomAccessFile.readByte();  
	            byteBuffer2 = randomAccessFile.readByte();
	            byteBuffer3 = randomAccessFile.readByte();
	            byteBuffer4 = randomAccessFile.readByte();
	            if(byteBuffer1 != 'M' || byteBuffer2 != 'T' || byteBuffer3 != 'r' || byteBuffer4!='k')
	            {
	                System.out.println("This file did not have the proper MTrk chunk ID.");
	                return false;
	            }
                //  Skip length.
                randomAccessFile.skipBytes(4);	
	            currentTick = 0;
	            currentTime = 0;
	            status = 0;
	            while(status != 0x2F)
	            {
	                //  Create a new MIDI event.
	                midiEvent = new MidiEvent();
	                MidiEvents.addElement(midiEvent);
	                //  First get the time.
	                deltaTicks = MidiEvent.readVarLen(randomAccessFile) ;
	                currentTick += deltaTicks ;
	                deltaTime = deltaTicks / ticksPerQuarterNote * tempo / 1000000.;
	                currentTime += deltaTime ;
	                midiEvent.time = currentTime;
	                //  Next get the status.
	                //  Skip running status.
	                nextByte = randomAccessFile.readByte();
	                if((nextByte & 0x80) == 0x80)
	                {
	                    //  Meta event.
	                    if ((nextByte & 0xff) == 0xff)
	                    {
	                        status = randomAccessFile.readByte();
	                    }
	                    else
	                    {
	                        status = nextByte;
	                        if (status != 0xF0 && status != 0xF7)
	                        {
	                            nextByte = randomAccessFile.readByte();
	                        }
	                    }
	                }
	                //  Import the event.
	                //System.out.println("Status = " + (status + 128) + " Delta ticks = " + deltaTicks);
	                //  Meta event or system exclusive event.
	                if ((status & 0xff) < 0x80 || (status & 0xff) == 0xF0 || (status & 0xff) == 0xF7)
	                {
	                    eventSize = MidiEvent.readVarLen(randomAccessFile);
	                    switch(status)
	                    {
	                        //  Time signature.
	                        case 0x58:	
    	                        randomAccessFile.readByte();	/* get numerator */
	                            randomAccessFile.readByte();	/* get denumerator */
	                            randomAccessFile.readByte();	/* get cc */
	                            randomAccessFile.readByte();	/* get bb */
	                            break;
	                        //  Tempo change.
	                        case 0x51:	
	                            byteBuffer1 = randomAccessFile.readByte();
	                            byteBuffer2 = randomAccessFile.readByte();
    	                        byteBuffer3 = randomAccessFile.readByte();
	                            tempo = ((int) byteBuffer1 << 16) + ((int) byteBuffer2 << 8) + byteBuffer3;
	                            System.out.println("Tempo change " + tempo);
	                            break;
	                        //  End of track.
	                        case 0x2F:
	                            midiEvent.status = status;
	                            break;
	                        //  Skip over all other events.
	                        default: 
	                            randomAccessFile.skipBytes(eventSize);
	                    }
	                } 
	                //  Channel event.
	                else	
	                {
	                    midiEvent.status = status;
	                    midiEvent.data[0] = nextByte;
	                    if ((status & 0xE0) != 0xC0)
	                    {
	                        midiEvent.data[1] = randomAccessFile.readByte();
	                    }
	                }
	            } 	
	            //  Translate the Midi event array to Csound notes.
	            int eventCount = MidiEvents.size();
	            for(int noteOnIndex = 0; noteOnIndex < eventCount; noteOnIndex++)
	            {
	                noteOnEvent = (MidiEvent) MidiEvents.elementAt(noteOnIndex);
	                //  Is this a note on event?
	                if(noteOnEvent.isNoteOn())
	                {
	                    //  If so, look for the first matching note off event.
	                    for(int noteOffIndex = noteOnIndex + 1; noteOffIndex < eventCount; noteOffIndex++)
	                    {
	                        noteOffEvent = (MidiEvent) MidiEvents.elementAt(noteOffIndex);
	                        if(noteOnEvent.isMatchingNoteOff(noteOffEvent))
	                        {
	                            double instrument = (format == 0) ? (noteOnEvent.status & 0x0F) + 1 : trackIndex;
	                            double start = noteOnEvent.time;
	                            double length = noteOffEvent.time - noteOnEvent.time;
	                            double octave = (((double) noteOnEvent.data[0]) / 12.0) + 3.0;
	                            double decibels = noteOnEvent.data[1];
	                            double pan = instrument / 16.0 - 0.5;
	                            noteAdd(instrument, start, length, octave, decibels, pan);
    	                        break;
	                        }
	                    }
	                }
	            }
	        }
	    }
	    catch(java.io.IOException e)
	    {
	        return false;
	    }
	    return true;
    }
	public boolean midifileExport(String Filename)
	{
	    //try
	    //{
	    //}
	    //catch(java.io.IOException e)
	    //{
	    //    return false;
	    //}
	    return true;
	}
	
}
	

