<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>Neural Processing in Csound [ XOR ]</title>		<meta name="Template" content="C:\PROGRAMAS\MICROSOFT OFFICE\OFFICE\HTML.DOT">	</head>	<body bgcolor="white" link="blue" vlink="purple">		<h3><font size="4" face="Times New Roman,Georgia,Times"><b>Testing the Back-Prop Algorithm with the XOR Problem</b></font></h3>		<p><font face="Times New Roman">In this section, we'll be constructing a soundless instrument, which will merely help us consolidate our knowledge of the back-prop algorithm. We will be implementing a solution for the xor problem, using simply i-code and print isntructions to display the net's output.</font></p>		<p><font face="Times New Roman">Lets first consider the topology of the net we'll be needing. It will have two inputs, and a single output. The hidden layer size will be two cells, which is enough for solving this particular problem (so I've heard :)):</font></p>		<center>			<p><font face="Times New Roman"><img src="figures/6.gif" height="221" width="473"></font></p>		</center>		<dir><font face="Times New Roman">&nbsp;</font>			<p><font face="Times New Roman">The picture also shows the variables we'll be needing to store values:</font></p>		</dir>		<p><font face="Courier New">		<table border="0" cellspacing="0" cellpadding="4" width="599">			<tr>				<td valign="top" width="56%">i [1], i [2]</td>				<td valign="top" width="44%">The input pattern area</td>			</tr>			<tr>				<td valign="top" width="56%">o [1]</td>				<td valign="top" width="44%">The target pattern area&nbsp;</td>			</tr>			<tr>				<td valign="top" width="56%">a [1][1], a [1][2]</td>				<td valign="top" width="44%">Activation values for hidden layer&nbsp;</td>			</tr>			<tr>				<td valign="top" width="56%">a [2][1]</td>				<td valign="top" width="44%">Activation values for output layer&nbsp;</td>			</tr>			<tr>				<td valign="top" width="56%">w [1][1][1], w [1][1][2], w [1][2][1],w [1][2][2]</td>				<td valign="top" width="44%">Weight values for the input connections of hidden layer</td>			</tr>			<tr>				<td valign="top" width="56%">w [2][1][1], w [2][2][1]</td>				<td valign="top" width="44%">Weight values for input connections of output layer</td>			</tr>			<tr>				<td valign="top" width="56%">d [1][1], d [1][2]</td>				<td valign="top" width="44%">Delta for hidden layer&nbsp;</td>			</tr>			<tr>				<td valign="top" width="56%">d [2][1]</td>				<td valign="top" width="44%">Delta for output layer&nbsp;</td>			</tr>		</table>		</font></p>		<dir><font face="Courier New">&nbsp;</font>		</dir>		<p><font face="Times New Roman">Since this is a very small network, and to make things clear, I will use single variables for each of these values, isntead of some zak-space array. The nomenclature used for the variable names, will consist of the variable letter (A, W or D), followed by a number identifying the respective layer, followed by an underscore, followed by the indexes that identify each value within the layer.</font></p>		<p><font face="Times New Roman">Examples:</font></p>		<p><font face="Times New Roman">i_a1_2 will be the activation value of cell 2 in layer 1 (the hidden layer)</font><font face="Times New Roman"><br>		i_w2_21 will be the connection weight between cell 2 in layer 1 (the hidden layer) and cell 1 in layer 2 (the output layer)<br>		i_i2 will be input value number 2<br>		i_o1 will be the output (target) value&nbsp;&nbsp;</font></p>		<p><font face="Times New Roman">Lets inspect the code then. First the usual sr/kr definition (not relevant in this case since all is done is i-time processing)</font></p>		<p><font size="2" face="Courier New">sr = 44100</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">kr = 441</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">ksmps = 100</font></p>		<p><font face="Times New Roman">Next, the start of the instrument definition, where some parameters are defined.</font></p>		<p><font face="Times New Roman">The learning rate eta, which will determine the scaling factor by which weights are updated. Lets keep it low for now, but you may increase this value later (up to 1, and even 2 or 3), to see how the algorithm behaves (you wont be able to increase it much, before the algorithm starts diverging...).</font></p>		<p><font size="2" face="Courier New">ieta = .25 ;training coeficient</font></p>		<p><font face="Times New Roman">The number of patterns to be trained (since we'll be training a xor table, this corresponds to the four possible combinations of the two binary inputs)</font></p>		<p><font size="2" face="Courier New">inump = 4 ;number of patterns</font></p>		<p><font face="Times New Roman">for the exclusive-OR table:</font></p>		<p><font face="Times New Roman">		<table border="0" cellspacing="0" cellpadding="4" width="235">			<tr>				<td valign="top" width="24%">					<center>						<b>I1</b></center>				</td>				<td valign="top" width="24%">					<center>						<b>I2</b></center>				</td>				<td valign="top" width="52%">					<center>						<b>O1</b></center>				</td>			</tr>			<tr>				<td valign="top" width="24%">					<center>						0</center>				</td>				<td valign="top" width="24%">					<center>						0</center>				</td>				<td valign="top" width="52%">					<center>						0 xor 0 = 0</center>				</td>			</tr>			<tr>				<td valign="top" width="24%">					<center>						0</center>				</td>				<td valign="top" width="24%">					<center>						1</center>				</td>				<td valign="top" width="52%">					<center>						0 xor 1 = 1</center>				</td>			</tr>			<tr>				<td valign="top" width="24%">					<center>						1</center>				</td>				<td valign="top" width="24%">					<center>						0</center>				</td>				<td valign="top" width="52%">					<center>						1 xor 0 = 1</center>				</td>			</tr>			<tr>				<td valign="top" width="24%">					<center>						1</center>				</td>				<td valign="top" width="24%">					<center>						1</center>				</td>				<td valign="top" width="52%">					<center>						1 xor 1 = 0</center>				</td>			</tr>		</table>		</font></p>		<p><font face="Times New Roman">And also the maximum number of iterations (in case the net diverges, this is a maximum value of epochs; if at this point the net hasnt found a solution, you might as well give up) :</font></p>		<p><font size="2" face="Courier New">imaxit = 50000 ;maximum number of iterations</font></p>		<p><font face="Times New Roman">This value is way overestimated. This particular implementation reaches the solution at 2490 iterations, within a 40% range. Its certainly not like we're making things hard for it... Maybe 10,000 iterations would be an ideal number, but sadly many solutions (when there are solutions) go past that.</font></p>		<p><font face="Times New Roman">Next the whole bunch of variables is initialized with zero (which wasnt really necessary, except for the weights which need be initialized, but serves as presentation for the nomenclature).</font></p>		<p><font face="Times New Roman">Just be sure to notice the weight array initialization. It seems best to initialize the weights with random values, which is whats being done here, with a value in the range 0 to 1 (1/100 to 100/100 to be precise).</font></p>		<p><font size="2" face="Courier New">;the activation array</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_a1_1 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_a1_2 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_a2_1 = 0</font></p>		<p><font size="2" face="Courier New">;the delta array</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_d1_1 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_d1_2 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_d2_1 = 0</font></p>		<p><font size="2" face="Courier New">;the weight array</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w1_11 = (rnd(99)+1)/100</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w1_12 = (rnd(99)+1)/100</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w1_21 = (rnd(99)+1)/100</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w1_22 = (rnd(99)+1)/100</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w2_11 = (rnd(99)+1)/100</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w2_21 = (rnd(99)+1)/100</font></p>		<p><font size="2" face="Courier New">;the input array</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i1 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i2 = 0</font></p>		<p><font size="2" face="Courier New">;the output array</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_o1 = 0</font></p>		<p><font face="Times New Roman">Now we'll start the iteration loop. The variable iter holds the present iteration number, and the loop restarts at the newitr: label.</font></p>		<p><font size="2" face="Courier New">;iteration loop</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">iter = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">newitr:</font></p>		<p><font face="Times New Roman">This next variable ihit is used to determine if the solution has been reached. I start it with 1 in each iteration (in boolean style, a value of 'true'), and after each pattern training I turn it to 0 if the pattern is not correctly recognized. If I manage to still arrive with the value of 1 to the end of an iteration, it means all patterns were successfully recognized, and the net already found a solution.</font></p>		<p><font size="2" face="Courier New">ihit = 1</font></p>		<p><font face="Times New Roman">Inside the iteration loop, we have the pattern loop, which will, one by one, present each pattern pair to the net (all four of them for each epoch) and update the weights. Again a restart label newpat: is used for the looping:</font></p>		<p><font size="2" face="Courier New">ipat = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">newpat:</font></p>		<p><font face="Times New Roman">For the actual training, we must start by loading the input/output variables with the pattern corresponding to the current pattern number. This is straight forward with the following code:</font></p>		<p><font size="2" face="Courier New">;load input/output patterns</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (ipat&gt;0) igoto skp0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i1 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i2 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_o1 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">igoto skp3</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">skp0:</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (ipat&gt;1) igoto skp1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i1 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i2 = 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_o1 = 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">igoto skp3</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">skp1:</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (ipat&gt;2) igoto skp2</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i1 = 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i2 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_o1 = 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">igoto skp3</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">skp2:</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (ipat&gt;3) igoto skp3</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i1 = 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_i2 = 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_o1 = 0</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">skp3:</font></p>		<p><font face="Times New Roman">Then the output of the net is calculated, layer by layer, form the input to the output (the temporary variable inet). For each cell, we first multiply each weight by the stimulus through that particular weight and add the combined result. Then, the activation amount is updated using the formula for the logistic function:</font></p>		<p><font size="2" face="Courier New">;activation of neuron 1 from layer 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">inet = i_i1*i_w1_11+i_i2*i_w1_21</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_a1_1 = 1/(1+exp(-inet)))</font></p>		<p><font size="2" face="Courier New">;activation of neuron 2 from layer 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">inet = i_i1*i_w1_12+i_i2*i_w1_22</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_a1_2 = 1/(1+exp(-inet)))</font></p>		<p><font face="Times New Roman">Once all neurons in the first layer have been computed, proceed with next layer:</font></p>		<p><font size="2" face="Courier New">;activation of neuron 1 from layer 2</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">inet = i_a1_1*i_w2_11+i_a1_2*i_w2_21</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_a2_1 = 1/(1+exp(-inet)))</font></p>		<p><font face="Times New Roman">At this point, we have our output neuron (i_a2_1) firing the output of the net, for the pattern that is being trained (i_i1 and i_i2). What we want to do is display the result, so that we can see the net evolving, during the instrument's execution. This is done simply with a print instruction (notice the variable itimes, the number of iterations to go by before printing, since we dont need to see the results at every single iteration):</font></p>		<p><font size="2" face="Courier New">;print output of the net</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">itimes = 100; every 100 times</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (frac(iter/itimes)!=0) igoto prskp</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">print iter, ipat, i_i1, i_i2, i_a2_1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">prskp:</font></p>		<p><font face="Times New Roman">And we must check if the net has found the solution. The irange variable holds the error percentage that we'll be allowing. Since we're dealing with binary patterns, we may find that a value above .6 is already a sufficient approximation to 1, a goal which wont demand as many iterations, as to get within, say, 10% of the result. You may later try smaller values for irange, to realize for yourself the number of required iterations.</font></p>		<p><font face="Times New Roman">If the distance between the actual and desired output is less than the maximum error percentage, then it means the pattern was successfully recognized. Otherwise zero ihit, so that the program knows training isnt over yet.</font></p>		<p><font size="2" face="Courier New">;check if output within range</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">irange = .4</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">idst = abs(i_a2_1-i_o1)</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (idst&lt;irange) igoto yes</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">ihit = 0; no</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">yes:</font><font face="Courier New"><br>		</font><font face="Times New Roman">&nbsp;</font></p>		<p><font face="Times New Roman">If this was the last pattern, and the ihit value is still 1 (meaning all patterns were within the specified range from the target), then we can stop training, since we already found a solution</font></p>		<p><font size="2" face="Courier New">if (ipat&lt;3) igoto sk1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (ihit==1) igoto done</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">sk1:</font></p>		<p><font face="Times New Roman">Otherwise, lets correct the weights using the back-propagation rule:</font></p>		<p><font face="Times New Roman">First lets find delta for the output layer. This will consist of the difference between the actual and desired outputs, multiplied by the derivative of the activation function, out*(1-out), where out is the activation level of the neuron.</font></p>		<p><font size="2" face="Courier New">;find delta for output layer</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_d2_1 = (i_o1-i_a2_1)*(i_a2_1*(1-i_a2_1))</font></p>		<p><font face="Times New Roman">Then, lets backpropagate this delta to the hidden layer. The back propagated amount is stored in ibp, and as you see it consists of the found delta for the output layer, times the respective connection weights to each cell in the hidden layer. This backpropagated value, is then multiplied by the activation function derivative, as before:</font></p>		<p><font size="2" face="Courier New">;delta for cell 1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">ibp = i_d2_1*i_w2_11</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_d1_1 = ibp*(i_a1_1*(1-i_a1_1))</font></p>		<p><font size="2" face="Courier New">;delta for cell 2</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">ibp = i_d2_1*i_w2_21</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_d1_2 = ibp*(i_a1_2*(1-i_a1_2))</font></p>		<p><font face="Times New Roman">We're finally able to correct all the connection weights, based on the just found deltas. For each connection, the change in weight value equals the connection's input activation (activation level of the cell on the input of the connection), times the delta value for the cell on the output of the connection, times the learning rate eta.</font></p>		<p><font face="Times New Roman">Heres the code for the four connections of the hidden layer, plus the two connections of the output layer:</font></p>		<p><font size="2" face="Courier New">;layer 1 connections</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w1_11 = i_w1_11+ieta*i_d1_1*i_i1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w1_12 = i_w1_12+ieta*i_d1_2*i_i1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w1_21 = i_w1_21+ieta*i_d1_1*i_i2</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w1_22 = i_w1_22+ieta*i_d1_2*i_i2</font></p>		<p><font size="2" face="Courier New">;layer 2 connections</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w2_11 = i_w2_11+ieta*i_d2_1*i_a1_1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">i_w2_21 = i_w2_21+ieta*i_d2_1*i_a1_2</font></p>		<p><font face="Times New Roman">At this point, we've trained one pattern, and should proceed with the next one. Thats whats done by</font></p>		<p><font size="2" face="Courier New">ipat = ipat+1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (ipat&lt;inump) igoto newpat</font></p>		<p><font face="Times New Roman">After all four patterns have been used, it looks like we ended an iteration cycle. So lets just increment the iteration counter, and loop to the next epoch (unless the maximum number of iterations was reached, which means the net diverged)</font></p>		<p><font size="2" face="Courier New">iter = iter+1</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">if (iter&lt;imaxit) igoto newitr</font></p>		<p><font face="Times New Roman">If eventually the net manages to successfully recognize all four patterns during an iteration, this is where program control will be transferred to:</font></p>		<p><font size="2" face="Courier New">done:</font></p>		<p><font face="Times New Roman">All we have to do now, is print the number of iterations, and the result solution. This solution will consist simply of the weight values, that you can use to check for ourselves, they in fact solve the problem</font></p>		<p><font size="2" face="Courier New">;print down results</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">print iter</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">print i_w1_11</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">print i_w1_12</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">print i_w1_21</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">print i_w1_22</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">print i_w2_11</font><font face="Courier New"><br>		</font><font size="2" face="Courier New">print i_w2_21</font></p>		<p><font face="Times New Roman">And thats all (no sound on this one, sorry :))</font></p>		<p><font size="2" face="Courier New">endin</font><font face="Courier New"><br>		</font><font face="Times New Roman">&nbsp;&nbsp;</font></p>		<p><font face="Times New Roman">Here's the complete orchestra file : <a href="instruments/bpxor.orc">BPXOR.ORC</a></font></p>		<p><font face="Times New Roman">The score just needs to call the instrument with whatever duration. You can still just use this <a href="instruments/dummy.sco">DUMMY.SCO</a></font><font size="2" face="Times New Roman,Georgia,Times"><b>.</b></font></p>		<p><font face="Times New Roman">		<hr>		</font></p>		<dir><font face="Times New Roman"><b>Next : </b><a href="rprop.html">Resilient back-propagation (RPROP)</a></font>			<p><font face="Times New Roman"><b>Previous : </b><a href="backprop.html">Hidden layer training (back-propagation)</a></font></p>			<p><font face="Times New Roman"><b>Up:</b> <a href="index.html">Back to index</a></font>		</dir>	</body></html>