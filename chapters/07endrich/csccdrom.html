<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>Five Musical Applications of Cscore</title>	</head>	<body bgcolor="white">		<div align="left">			<h1><font face="Times New Roman">Five Musical Applications of Cscore<br>			</font></h1>			<h2><font face="Times New Roman">Archer Endrich</font></h2>		</div>		<center>			<h2><font face="Times New Roman"><a name="CONTENTS"></a>Contents: Introductory Notes &#150; Reference Manual Page &#150; Source Code for:</font></h2>		</center>		<ol>			<li><a href="#ALTER"><font face="Times New Roman">CS10ALTR.C</font></a><font face="Times New Roman">&nbsp;Use functions to alter pfields, with command line input<br>			</font>			<li><a href="#CUE"><font face="Times New Roman">CS11CUE.C</font></a><font face="Times New Roman">&nbsp;Create <i>N</i> event-blocks at specified time cues, + crescendo &amp; diminuendo<br>			</font>			<li><a href="#CHORD"><font face="Times New Roman">CS12CHRD.C</font></a><font face="Times New Roman">&nbsp;Explore pitch/sound continuum with Fibonacci-based chords<br>			</font>			<li><a href="#TEXTURE"><font face="Times New Roman">CS13TEXT.C</font></a><font face="Times New Roman">&nbsp;Create a texture, with user inputs &amp; processing options<br>			</font>			<li><a href="#PARTIALS"><font face="Times New Roman">CS14PTLS.C</font></a><font face="Times New Roman">&nbsp;Alter partials content during a single tone<br>			</font>		</ol>		<h3><font face="Times New Roman">1.&nbsp;<a name="ALTER"></a>CS10ALTR.C&nbsp;-&nbsp; Use functions to alter pfields, with command line input</font></h3>		<h3><font face="Times New Roman">Introductory notes</font></h3>		<p><font face="Times New Roman">The user inputs four values on the command line, one for each pfield to be affected, and four different functions are called, one for each pfield. Thus each algorithm is tailored to the requirements of each pfield individually. The FOR loop where these four functions are called looks like this:</font></p>		<p><code><font face="Courier New">for(i=0; i&lt;=n-1; i++) {</font></code><font face="Courier New"><br>		</font></p>		<blockquote>			<font face="Courier New"><code>(*f)-&gt;p[2] = newstt((*f)-&gt;p[2], start);</code> /* alter start time of event 1*/<br>			<code>(*f)-&gt;p[3] = newdur((*f)-&gt;p[3], dur);</code> /* alter duration of event 1*/<br>			<code>(*f)-&gt;p[4] = newamp((*f)-&gt;p[4], amp);</code> /* alter amplitude of event 1*/<br>			<code>(*f)-&gt;p[5] = newpch((*f)-&gt;p[5], freqf);</code> /* alter pitch of event 1*/<br>			<code>f++; /* move on to next event */<br>			</code></font></blockquote>		<p><font face="Courier New"><code><code>}</code><br>		</code></font></p>		<p><font face="Times New Roman"><code>The FOR loop is set to terminate when <code>i&lt;=n-1</code> because the <i>N</i> count begins at 1 and the FOR loop count begins at 0. Now we are beginning to see the power of the Cscore environment. Blocks of events can be copied and treated differently in each section of the score. User inputs can change the results with every run of the program, providing a useful experimental working method. Each pfield can be massaged with an algorithmic function of arbitrary complexity. It's starting to look good!</code></font></p>		<p><font face="Times New Roman"><code>If one is going to think about this environment as an 'algorithmic mix window', the start time and duration pfields are of key importance. The blocks of events can all have the same time, thus forming chords; they can overlap by starting before the next event is finished, or can come after silences by beginning after the previous event has finished, thereby controlling the horizontal density of the resulting texture: the pitch pfield controls its vertical density. In the next program we examine a higher-level mechanism for handling blocks of events by means of timing cues.</code></font></p>		<h3><font face="Times New Roman"><code>Reference Manual Page</code></font></h3>		<p><font face="Times New Roman"><code>CS10ALTR - use functions to alter several pfields, with commandline input<br>		<br>		Usage:<br>		<br>		</code></font><code><font face="Courier New"><b>cs10altr -s</b><i>startf</i> <b>-d</b><i>durf</i> <b>-a</b><i>ampf</i> <b>-f</b><i>freqf inscore.sc outscore.sc</i><br>		<br>		<b>-s</b><i>startf</i> start_time scaling ratio (double) (*: 0.0-&gt;)<br>		<b>-d</b><i>durf</i> duration scaling ratio (double) (*: &gt;0.0)<br>		<b>-a</b><i>ampf</i> amplitude scaling factor (int) (+: 0-&gt;x000)<br>		<b>-f</b><i>freqf</i> frequency scaling ratio (double) (*: &gt;0.0)<br>		</font></code></p>		<blockquote>			<p><font face="Courier New"><code>When multiplying, vals &lt; 1 compress, &gt; 1 expand<br>			NB1: values &lt; 1 * scaling ratios: &nbsp; &lt; 1 become very small!<br>			NB2: if startf = 0, a simultaneity will result<br>			</code></font></p>		</blockquote>		<p><font face="Courier New"><i><code>inscore.sc</code></i><code> input Csound score file<br>		</code></font></p>		<blockquote>			<font face="Times New Roman"><code>assumed to have different values for each event, but identical inscore values in a parameter field will also all be the same in the outscore, though rescaled.</code></font></blockquote>		<p><font face="Times New Roman"><i><code>outscore.sc</code></i><code> altered Csound scorefile produced by the program<br>		</code></font></p>		<h4><font face="Times New Roman"><code>Description</code></font></h4>		<p><font face="Times New Roman"><code>Start_time, duration, amplitude and frequency are the four parameter fields of the input scorefile altered by a simple algorithmic function. The user enters the scaling factor on the command line, and can easily produce a variety of output scores, viewing them to check the results before going on to produce a soundfile.</code></font></p>		<p><font face="Times New Roman"><code>Start time, duration, and frequency are all calculated by applying the same formula 'new_value *= scaling_ratio': i.e., the new value = the current value * the scaling factor. The current value is passed to the function and multiplied by the scaling factor, thereby becoming the new value.</code></font></p>		<p><font face="Times New Roman"><code>Amplitude uses an integer factor and += .</code></font></p>		<p><font face="Times New Roman"><code>EXAMPLE: ('nv' = new_value, 'cv' = current_value, 'sf' = scaling_factor)<br>		<table border="1">			<tr>				<td>IN_VALUE</td>				<td>OUT_VALUE</td>				<td>CALCULATION</td>			</tr>			<tr>				<td>cv</td>				<td>nv</td>				<td>= cv * sf</td>			</tr>			<tr>				<td>0</td>				<td>0</td>				<td>= 0 * 1.2</td>			</tr>			<tr>				<td>1</td>				<td>1.2</td>				<td>= 1 * 1.2</td>			</tr>			<tr>				<td>2.5</td>				<td>3</td>				<td>= 2.5 * 1.2</td>			</tr>		</table>		</code></font></p>		<p><font face="Times New Roman"><code>The code for one of these functions looks like this:<br>		</code></font></p>		<p><font face="Times New Roman"><code><code>double<br>		<code>newdur(double du, double df)</code><br>		/* <code>double du;</code> duration variable as in pfield 3 */<br>		/* <code>double df;</code> duration factor input on command line */<br>		<code>{</code><br>		</code></code></font><code></p>		<blockquote>			<font face="Times New Roman"><code><code>du *= df;</code> /* duration scaled by user's factor */<br>			<code>fprintf(stderr, &quot;diagnostic, newst(): new duration = %.3f\n&quot;, du);</code><br>			<code>return (du);</code><br>			</code></font></blockquote>		<p><font face="Times New Roman"><code><code>}</code><br>		</code></font></p>		<h4><font face="Times New Roman"><code>Using the Program</code></font></h4>		<p><font face="Times New Roman"><code>As the usage reminds us, the program requires an input file assumed to have different values for each of the events. Any values which are the same from one event to the next will remain equal, though rescaled. In other words, a fixed change is applied throughout. It would take a further development of the code to start with the same values and accumulate the results from one event to the next. This is a 'series' operation and is applied in some of the programs which follow.</code></font></p>		<p><font face="Times New Roman"><code>Because the scaling factor is applied by a multiplication operation, the user should be careful with scaling ratios less than zero. When applied for example to start times or durations which are also less than zero, rather small numbers can easily result. E.g., 0.2 * 0.7 = 0.14. This will have the effect of moving events closer to the start of the output soundfile, or of producing very short events.</code></font></p>		<p><font face="Times New Roman"><code>On the other hand, because multiplication is involved, values greater than 1 easily 'blow up': become excessively large. Multiplication is in fact a dangerous operation in this context, though appropriate for frequency.</code></font></p>		<p><font face="Times New Roman"><code>The following programs in this set of examples for Cscore try out different algorithms, with a greater role for addition.</code></font></p>		<p><font face="Times New Roman"><code>The simple beginning represented by this program could be developed further; for example, by:</code></font></p>		<ul>			<li><font face="Times New Roman"><code>offering the option to add or multiply the (fixed) scaling factors</code></font>			<li><font face="Times New Roman"><code>designing more complex &amp; different functions for each parameter, e.g.,:</code></font>			<ol>				<li><font face="Times New Roman"><code>use a series function such as linear, exponential or logarithmic (values accumulate)</code></font>				<li><font face="Times New Roman"><code>employ a random function with user-defined ranges for duration</code></font>				<li><font face="Times New Roman"><code>add duration to previous start time so as to avoid overlaps</code></font>				<li><font face="Times New Roman"><code>progressively decrease the values again e.g., after the half-way point</code></font>			</ol>		</ul>		<p><font face="Times New Roman"><code>Some of these ideas are developed a bit further in the subsequent programs.</code></font></p>		<p><font face="Times New Roman"><code>Source code: see the file <a href="cs10altr.html">CS10ALTR.C</a><br>		<a href="#CONTENTS">Return</a> to Contents: list of example applications<br>		</code></font></p>		<p><font face="Times New Roman"><code>		<hr>		<!-- ************************************************************* -->		</code></font></p>		<h3><font face="Times New Roman"><code>2.&nbsp;<a name="CUE"></a>CS11CUE.C&nbsp;-&nbsp; Create <i>N</i> event-blocks at specified time cues, + crescendo &amp; diminuendo</code></font></h3>		<h3><font face="Times New Roman"><code>Introductory notes</code></font></h3>		<p><font face="Times New Roman"><code>The power of Cscore begins to be unveiled in a program given in its original form in an earlier Csound manual. Note when <code>holdn = n</code> stores a counter value and a new counter is initialised with <code>i = 0</code>.</code></font></p>		<p><font face="Times New Roman"><code>A look at an outline of the (adapted) score produced by this program will help us to understand how it is coded.</code></font></p>		<p><font face="Times New Roman"><code>Original block for comparison (I've commented out the code which does this)<br>		</code></font></p>		<blockquote>			<font face="Times New Roman"><code>diagnostic: event block 1, time cue=...<br>			i1 ... (series of i-statements)<br>			diagnostic: event block 2, time cue=...<br>			i1 ... (series of i-statements)<br>			diagnostic: event block 3, time cue=...<br>			i1 ... (series of i-statements)<br>			</code></font></blockquote>		<p><font face="Times New Roman"><code>A double loop structure is created in which the purpose of the OUTER loop is to cause the processing to go back to the beginning of the list: <code>f = &amp;a-&gt;e[1]</code>. Note that the counter for the INNER loop is reset to the full number of events before processing the second block. This is what the extra copy of n (holdn) is for: it stays the same and is used to reset the counter. Then the inner loop moves through each of the events, altering their amplitude. When this inner loop comes to the end of the list, note that the counter for the outer loop is incremented; the outer loop ceases when this counter reaches 2, i.e., which is the third iteration, because the count began at 0.</code></font></p>		<p><font face="Times New Roman"><code>The outer loop counter could be made to repeat the loop any number of times, thus creating n number of blocks, and the inner loop counter is set to the number of events in the list, so that each block contains versions of all the events. The double loop structure does not of course have to be used to create time cues. The re-timed blocks occur with this program only because the cues are used to alter p2. My program allocates memory dynamically as it reads the file of cues; be careful lest this code is machine-specific.</code></font></p>		<h3><font face="Times New Roman"><code>Reference Manual Page</code></font></h3>		<p><font face="Times New Roman"><code>CS11CUE - create n event blocks at specified time cues, with cresc/dim<br>		<br>		Usage<br>		<br>		<b>cs11cue -n</b><i>numcues</i> <b>-a</b><i>ampfactor</i> [<b>-m</b><i>multiplier</i>] <b>-t</b><i>processtype</i> [<b>-r</b><i>range</i>] <b>-i</b><i>scoretype cuefile inscore.sc outscore.sc</i><br>		</code></font></p>		<p><font face="Times New Roman"><b><code>-n</code></b><code><i>numcues</i> (int) number of time cues in cuefile (this will also be the number of event-blocks formed)<br>		<b>-a</b><i>ampfactor</i> (int) amplitude change factor (+: 0-&gt;x000)<br>		<b>-m</b><i>multiplier</i> (double) amplitude scaling ratio used with type 1 (*: &gt;0)<br>		<b>-t</b><i>processtype</i> (int) processtype is type of algorithm with which to process the score values<br>		</code></font></p>		<blockquote>			<font face="Times New Roman"><code>0: ADD fixed value<br>			1: MULTIPLY by time cue value &amp; multiplier<br>			2: RANDOM the formula used is: randval(0-1) * timecue * range<br>			</code></font></blockquote>		<p><font face="Times New Roman"><b><code>-r</code></b><code><i>range</i> (int) type 2: numerical range for random function (Default = 1)<br>		</code></font></p>		<blockquote>			<font face="Times New Roman"><code>NB: For *= processes, 1st time cue must be &gt; 0 or all calculations will result in 0!<br>			</code></font></blockquote>		<blockquote>			<font face="Times New Roman"><code>WARNING: Start times can be excessively high if both start time &amp; range are rather large.<br>			</code></font></blockquote>		<p><font face="Times New Roman"><code>-i<i>scoretype</i> (int) type of input scorefile:<br>		</code></font></p>		<blockquote>			<font face="Times New Roman"><code>0: SAME<br>			1: DIFFERENT<br>			</code></font></blockquote>		<p><font face="Times New Roman"><i><code>cuefile</code></i><code> input text file of cue times<br>		<i>inscore.sc</i> input Csound score file<br>		<i>outscore.sc</i> Csound score file produced by the program<br>		</code></font></p>		<h4><font face="Times New Roman"><code>Description</code></font></h4>		<p><font face="Times New Roman"><code>This program operates a little like a mix window. The Csound scorefile mechanism is itself a kind of mix window because start times are set and events can be overlapped. Here, it is not just a question of start times for single events, but start times for groups of events. These can be simultaneities or events in groups with different, possibly overlapping timings.</code></font></p>		<p><font face="Times New Roman"><code>It could therefore be useful to think of the event groups as 'blocks': the time cues affect the start time of each block &#150; and consequently all the events within each block. The first block consists of the events of the original score. One or more copies of this first set of events are made, and they repeat starting at the next time cue: i.e., this time in seconds is added to all the start times of the events in the previous block. Some variation in the blocks is made possible by the additional parameter to adjust amplitude. The processing which this program allows is minimal, given as a hint of what might be done. Extending processing to duration and frequency would be a natural path of development for the program.</code></font></p>		<p><font face="Times New Roman"><code>In effect, this is a sound copy program with two main features: 1) the copying is carried out within the context of what is really a 'mix' window (nothing prevents the copies from overlapping). 2) the copies can be altered algorithmically - within a Cscore programming environment, eventually in whatever way and to whatever degree the user wishes and is capable of programming.</code></font></p>		<h4><font face="Times New Roman"><code>Using the program</code></font></h4>		<p><font face="Times New Roman"><code>The program as it stands cannot automatically count the number of cues as it reads them in (it can when it copies them). The numcues variable is therefore input by the user, and is used as the outer loop counter upper limit. Thus each time cue creates a new 'block' of events: the number of blocks of events is the number of time cues in <i>cuefile</i>.</code></font></p>		<p><font face="Times New Roman"><code>The inscore can be a template with identical values in each parameter field (e.g. all start times = 0, all durations = 1, all amplitudes = 15000, and all frequencies = 200). (Frequency is not processed in this version of the program, so all the blocks will be at the same pitch.) This is inscore type 0. Alternatively, the inscore can be a 'real' scorefile with different values for each event: type 1. The two types of scores require different processing algorithms, because the arithmetic is slightly different when adding the values always to the same initial value to create each subsequent event, or when adding to differing values for each note event of the inscore.</code></font></p>		<p><font face="Times New Roman"><code>All of the processing in this program is based on addition and there are two alternative algorithms for each process, depending on the type of inscore: SAME or DIFFERENT. How the loop counter is used to bring about the accumulation of the values for inscore type 0 should be fairly clear in the code: it is the user's change factor which is accumulated. The new start times are added to the previous times throughout, but the amplitude decreases after the half-way point of each block of events. Differing versions of the program could be made to create differing amplitude change shapes: increasing throughout, decreasing throughout, changing randomly, logarithmically, exponentially etc.</code></font></p>		<p><font face="Times New Roman"><code>A generic problem: when it comes time to decrement, the SAME type situation needs to hold the highest value attained so far and decrement from there. Otherwise, one decrements from the initial value and the values usually go below zero. This version of the program doesn't check for this kind of eventuality - it would be better if it did, or at least report the fact to the user.</code></font></p>		<p><font face="Times New Roman"><code>The following goes through the processing options with specific reference to start times.<br>		</code></font></p>		<blockquote>			<font face="Times New Roman"><code>0 ADD: the time cue value is added to the previous start time, and the amplitude factor is added to the previous amplitude until the halfway point of the block, then it is subtracted from the highest value attained in the first half.<br>			1 MULTIPLY: the previous start time is multiplied by the time cue value<br>			2 RANDOM: a random value(0-1) * time cue * range is added to the previous start time<br>			</code></font></blockquote>		<p><font face="Times New Roman"><code>Note that the effects are cumulative between blocks as well: start times are added to the start time of event 1 of the previous block. Similarly with volume. Start times and volume are the only two parameters which are affected as the program currently stands. The volume crescendos and decrescendos within each block in ampfactor steps, changing at the half-way point. The size of the steps is set from the command line input. My own next step is to combine this program with CS13TEXT(URE) to make a powerful block/texture generator, extend the processing options etc. The possiblities are really very exciting!</code></font></p>		<p><font face="Times New Roman"><code>Source Code: see the file <a href="cs11cue.html">CS11CUE.C</a><br>		<a href="#CONTENTS">Return</a> to Contents: list of example applications<br>		</code></font></p>		<p><font face="Times New Roman"><code>		<hr>		<!-- ************************************************************ -->		</code></font></p>		<h3><font face="Times New Roman"><code>3.&nbsp;<a name="CHORD"></a>CS12CHRD.C&nbsp;-&nbsp; Explore pitch/sound continuum with Fibonacci-based chords</code></font></h3>		<h3><font face="Times New Roman"><code>Introductory notes</code></font></h3>		<p><font face="Times New Roman"><code>CS12CHRD takes advantage of Csound's ability to specify precise frequencies. The algorithm builds chords of user-definable density in which the frequency relationships are defined by the Fibonacci series. The interesting part of the algorithm concerns enabling the user to specify both the size of the interval to be spanned and the 'density; of the chord, i.e., the number of frequency components.</code></font></p>		<h3><font face="Times New Roman"><code>Reference Manual Page</code></font></h3>		<p><font face="Times New Roman"><code>CS12CHRD - explore pitch/sound continuum with Fibonacci-based chords<br>		<br>		Usage<br>		<br>		<b>cs12chrd -s</b><i>startser</i> <b>-v</b><i>nextval</i> <b>-f</b><i>freq</i> <b>-i</b><i>interval</i> <b>-n</b><i>numterms outscore.sc</i><br>		<br>		<b>-s</b><i>startser</i> (double) first term of the series (&gt; 0.0)<br>		<b>-v</b><i>nextval</i> (double) second term of the series (&gt; startser)<br>		<b>-f</b><i>freq</i> (double) root or central frequency in Hz<br>		<b>-i</b><i>interval</i> (double) interval span within which to create the harmony or harmonic complex; express as a ratio<br>		<b>-n</b><i>numterms</i> (int) number of terms in the Fibonacci series to be used to generate harmonies<br>		<i>outscore.sc</i> Csound score file produced by the program<br>		</code></font></p>		<h4><font face="Times New Roman"><code>Description</code></font></h4>		<p><font face="Times New Roman"><code>This program was written primarily as a way of experimenting with the sonic fuzzy area which lies between 'pitch' and 'sound' &#150; implying that at one end of the spectrum is a clearly pitched 'note' or chord, and at the other end is a timbrally rich sound, possibly with noise elements.</code></font></p>		<p><font face="Times New Roman"><code>In this case, the Fibonacci series is used as a way to determine the frequencies of the tones of these new, experimental harmonies, in the expectation that its self-similar proportions will result in some level of acceptable sonority in the resultant harmonies. The interval is specified by a ratio, e.g. 1.498 for a perfect fifth. Any number of tones can be placed within this interval with the <i>numterms&gt;</i> parameter. By playing with the breadth of the interval and the number of terms, one can delightfully explore the possibilities.</code></font></p>		<h4><font face="Times New Roman"><code>Using the program</code></font></h4>		<p><font face="Times New Roman"><code>Note that the initial two terms are user-defined. This is necessary because the normal integer Fibonacci series may expand the values more rapidly than is desired (1 2 3 5 8 13 21 34 55 89 ...), especially when they are being used as multipliers! The program displays the series on the screen so it can be examined before going on to create the sound.</code></font></p>		<p><font face="Times New Roman"><code>The inharmonic nature of the harmonies will create a variety of beating patterns between the sine waves. This can be increased towards richer timbres or decreased towards more 'sonorous' timbres by adjusting the line of code which defines the wave function: putstr (&quot;f1 ... &quot;). It would be useful to create the values for this function in a textfile and read it into the program, thus enabling more experimentation without having to recompile. A natural way to develop this program would be to be able to move between chords, e.g. with glissandi: from x terms within one given interval to y terms within another given interval. Also, frequency relationship patterns other than that of the Fibonacci series could be used, thus turning the program into a full-scale experimental harmony workshop.</code></font></p>		<p><font face="Times New Roman"><code>There is some interesting information available regarding numerical relationships, vibrations, 'golden numbers', and microtonal music. For example, Charles E. H. Lucy's <i>Pitch, PI, and other Musical Paradoxes ('A Practical Guide to Natural Microtonality')</i>, which develops the ideas of English horologist John Harrison (1693-1776), who won a &pound;20,000 (!) prize for measuring longitude. Charles Lucy has developed from these ideas the Lucy scale: 'based on the only natural, irrational, and transcendental number (PI).' The Csound score system provides a natural environment for exploring these ideas experimentally, and CS12CHRD extended to include a 'Lucy' algorithm would be ideal for listening to the simultaneities which these numerical relationships can produce. All good stuff. The bee in my bonnet is that we need new developments in the theory of harmony to enable an extended exploration of the sonic middle ground between 'pitch' and 'sound', so that music can successfully integrate pitch structures of all types with 'sound composition'.</code></font></p>		<p><font face="Times New Roman"><code>Source code: see the file <a href="cs12chrd.html">CS12CHRD.C</a><br>		<a href="#CONTENTS">Return</a> to Contents: list of example applications<br>		</code></font></p>		<p><font face="Times New Roman"><code>		<hr>		<!-- ********************************************************* -->		</code></font></p>		<h3><font face="Times New Roman"><code>4.&nbsp;<a name="TEXTURE"></a>CS13TEXT.C&nbsp;-&nbsp; Make a sound texture, with user inputs &amp; processing options</code></font></h3>		<h3><font face="Times New Roman"><code>Introductory notes</code></font></h3>		<p><font face="Times New Roman"><code>This program is used in conjunction with a specially designed Csound orchestra (<i>in13text.orc</i>) in order to create a sound texture which fills an enveloped shape (values increase and decrease), gets louder and softer within each block, becomes temporally denser towards the half-way point, and spreads out again from there to the end. The score creates the note events and handles the temporal density/expansion by manipulating the start times.</code></font></p>		<h3><font face="Times New Roman"><code>Reference Manual Page</code></font></h3>		<p><font face="Times New Roman"><code>CS13TEXT - make a sound texture, with user inputs &amp; processing options<br>		<br>		Usage<br>		<br>		</code></font><code><font face="Courier New"><b>cs13text -s</b><i>startf</i> <b>-d</b><i>durf</i> <b>-a</b><i>ampf</i> <b>-f</b><i>freqf</i> <b>-t</b><i>type</i> <b>-i</b><i>scoretype inscore.sc outscore.sc</i><br>		<br>		<b>-s</b><i>startf</i>(double) change factor for start times<br>		<b>-d</b><i>dur</i> (double) change factor for durations<br>		<b>-a</b><i>amplf</i> (int) change factor for amplitude (e.g 1000)<br>		<b>-f</b><i>freqf</i> (double) change factor for frequency<br>		<b>-t</b><i>type</i> (int) texture processing algorithm:<br>		</font></code></p>		<blockquote>			<font face="Courier New"><code>0 FIXED change<br>			1 RANDOM change<br>			2 LINEAR SERIES<br>			</code></font></blockquote>		<p><font face="Courier New"><b><code>-i</code></b><code><i>scoretype</i> (int) type of input scorefile:</code></font></p>		<blockquote>			<font face="Courier New"><code>0 SAME<br>			1 DIFFERENT<br>			</code></font></blockquote>		<p><font face="Courier New"><i><code>inscore.sc</code></i><code> input scorefile, of either type <i>outscore.sc</i> Csound scorefile produced by the program</code></font></p>		<h4><font face="Times New Roman"><code>Description</code></font></h4>		<p><font face="Times New Roman"><code>This program builds on the parameter inputs for CS11CUE to create a more comprehensive texture generator. Because start times can be compressed or expanded, the placement of the event blocks can be made more or less dense. All value changes except start times are made to increment during the first half of the event list, and decrement in the second half. There are now several options regarding the type of mathematical operation to apply to each parameter.</code></font></p>		<p><font face="Times New Roman"><code>The events are read from an <i>inscore.sc</i>, which can be a template of identical values in each pfield, or contain differing values, as described above in the notes for CS11CUE.</code></font></p>		<p><font face="Times New Roman"><code>The processing options are the same as those in CS11CUE (based on addition), whereas those of CS10ALTR are based on multiplication. I actually think it's better for frequency to be handled by a multiplying ratio &#150; one day!</code></font></p>		<h4><font face="Times New Roman"><code>Using the program</code></font></h4>		<p><font face="Times New Roman"><code>A little time spent simply imagining results would not go amiss. If the inscore is a same-value template, then one is beginning from scratch, building up start time, duration, amplitude and frequency relationships according to the processing option selected. (A nice task in programming logic would be to enable the user to select different processing options for every parameter!).</code></font></p>		<p><font face="Times New Roman"><code>Start times always expand, the new time added to the previous one. The actual start time itself is adjusted. This is not as ideal as it might be, because there is no way to apply the function to decrease (compress) the values without having the start times begin to fold back into the previous times. It would be better to be able to adjust the timegaps between events. This is a programming task I haven't come to grips with yet.</code></font></p>		<p><font face="Times New Roman"><code>If an inscore with different values is used, it is possible to place larger or smaller values in the duration pfield so that the durations will vary in relationship to the start times, producing a greater or lesser degree of note event overlap. Compressing durations will tend to bunch up, producing varying degrees of simultaneity towards the end of the texture.</code></font></p>		<p><font face="Times New Roman"><code>Amplitude values decrease after the half-way point. It is easy to remove this from the program &#150; just call <i>amp_up()</i> again in the second half. Or, start with high amplitude values and call <i>amp_dwn()</i> both times. With the RANDOM function <i>rand()</i>, amplitude changes can be minimal, or alter unpredictably in a considerably more dramatic way if a higher change factor is used.</code></font></p>		<p><font face="Times New Roman"><code>The frequency change factor is summed with the previous frequency, so the alterations are likely to be minimal if the change factor is small. Bear in mind as a guide that the 88-key piano keyboard extends from 27.5Hz (lowest A) to 4186Hz (highest C). The pitch chart on p.21 of John R Pierce's <i>The Science of Musical Sound</i> is a useful reference. Also note that the results are likely to be rather inharmonic: e.g., a factor of 2 does not create an octave, it simply adds 2 Hz! - but could be useful to create 'chorusing' effects. Similarly, 220Hz will create the octave of 110 Hz, but if added to 440Hz will be a long way short of the next octave (nor will it be one of the equally tempered intervals inbetween). Clearly, a version of the program with options to ADD or MULTIPLY is needed!</code></font></p>		<p><font face="Times New Roman"><code>I think we're looking at something potentially very powerful here, especially if combined with the block time cues functionality of CS11CUE: not only textures that unfold with lots of internal changes, but blocks of events which do the same and can overlap or be separated in time. The frequency parameter could be crucial here: not only could the frequencies change within each block, but a series of blocks could be transposed according to plan - and different blocks could also use different sounds.</code></font></p>		<p><font face="Times New Roman"><code>Now we are very close to thinking about the resulting music in a way similar to contemplating a written page of score, but of course within an algorithmic context. This 'mix-window' concept provides a more intuitive link to the way (we) composers normally think about things, but the power of the computer is also being employed to create potentially new and intricate sonic results: with the C programming language to construct logical/algorithmic relationships amd Cscore to produce fully written out result Csound score files ready for synthesis.</code></font></p>		<p><font face="Times New Roman"><code>Source code: see the file <a href="cs13text.html">CS13TEXT.C</a><br>		<a href="#CONTENTS">Return</a> to Contents: list of example applications<br>		</code></font></p>		<p><font face="Times New Roman"><code>		<hr>		<!-- ******************************************************* -->		</code></font></p>		<h3><font face="Times New Roman"><code>5.&nbsp;<a name="PARTIALS"></a>CS14PTLS.C&nbsp;-&nbsp; Alter partials content during a single tone</code></font></h3>		<h3><font face="Times New Roman"><code>Introductory notes</code></font></h3>		<p><font face="Times New Roman"><code>For a long time I've cherished the idea of being able to create timbrally changing tones algorithmically. This program achieves that objective to a modest degree by linking a differently specified f-statement to every note of the score. All the notes are at the same frequency and overlap (in various ways), so the different waveforms flow in and out of each other. The reference manual page goes into more detail about this and the code is fairly straightforward, so this idea can easily be developed further. When working on these applications, especially CS13TEXT, it gradually became clear that there were a number of different situations to be catered for regarding the way values accumulate from event to event. This turned out to be (for me) a somewhat stretching problem in programming logic, and I did a lot of 'dry-runs' of the arithmetic before I could work out what was going on.</code></font></p>		<p><font face="Times New Roman"><code>This is typical of what begins to happen with programming once one leaves the 'basics' behind and starts to get down to something 'interesting', so I conclude these introductory observations with an account of what I learned in the process of (partially) solving this particular problem. The key factor is the nature of the inscore. My first versions took no account of this, which caused some rather puzzling numerical results!</code></font></p>		<p><font face="Times New Roman"><code>You might want to examine the source code regarding the various situations I identified and catered for:</code></font></p>		<blockquote>			<font face="Times New Roman"><code>Case 1: when there is an inscore with identical values in the pfields for each note event, examine how the loop counter is used to accumulate values to add to the same initial value<br>			(see FIXED ... SAME in the code).</code></font></blockquote>		<blockquote>			<font face="Times New Roman"><code>Case 2: when there is an inscore with differing values in the pfields, look at how the factor is applied to the differing incoming values<br>			(see FIXED ... DIFFERENT in the code).</code></font></blockquote>		<blockquote>			<font face="Times New Roman"><code>Case 3: also consider why the LIN-SERIES operation (and presumably the other still unimplemented series operations) needs to make use of the value in the previous event. This comprises a 3rd case.<br>			See LIN_SERIES ... SAME in the code).</code></font></blockquote>		<p><font face="Times New Roman"><code>The first case: the 'same value' accumulates by multiplying the user's change factor by the loop counter and adding the new value to the same initial val or identical incoming values). CS14PTLS is a variant of the 'same' case: all values are calculated from a single initial starting point without reading each event afresh from an inscore (with identical values for each note event).</code></font></p>		<p><font face="Times New Roman"><code>The second case: the 'different' value in the pfield is read afresh from the inscore each time; the factor is added to it (or whatever) as a fixed valuehe second case does not apply to CS14PTLS because everything there is generated from the single values input by the user or from defaults.</code></font></p>		<p><font face="Times New Roman"><code>The third case (series operations): the values accumulate by using the output of the previous operation as the input to the next operation. This previous value is updated in <i>main()</i> with the 'hp2' etc. variables and passed to the functions which carry out the calculations. The compressing of values which occurs after the half-way point of the program also varies with each case. In the first case (identical start values), the now reducing values need to be decremented from the highest value achieved in the first half of the event list. This value is held in a global variable (because it doesn't want to be passed to the calculation functions every time they are called). It is updated in <i>main()</i> and then used when the <i>_dwn()</i> functions are called during the second half of the note event list. It is no longer updated during the second half and so 'holds' the peak value attained during the first half. These variables are named 'holddur' and 'holdamp'. In the second case (differing values read afresh), this incoming value is used to decrement from. In the third case (series operations), the value from the previous pfield is used.</code></font></p>		<p><font face="Times New Roman"><code>The following summarises the various situations, which can be examined in the code for CS11CUE, CS13TEXT, and in part, CS14PTLS:</code></font></p>		<blockquote>			<font face="Times New Roman"><code>SAME start point &amp; FIXED or RAND value changes: solved by augmenting the factors with <i>counter*factor</i> and adding the result to the (same) start value.</code></font></blockquote>		<blockquote>			<font face="Times New Roman"><code>SAME start point &amp; SERIES value changes: just need to add or apply the factor to each (different) incoming value.</code></font></blockquote>		<blockquote>			<font face="Times New Roman"><code>DIFFERING start points &amp; FIXED or RAND value changes: solved by augmenting the factors with <i>counter*factor</i> and adding the result to the pfield value in the previous event.</code></font></blockquote>		<blockquote>			<font face="Times New Roman"><code>DIFFERING start points &amp; SERIES value changes (solved by the same algorithm as SAME ... FIXED): solved by augmenting the factors with <i>counter*factor</i> and adding the result to the incoming value.</code></font></blockquote>		<p><font face="Times New Roman"><code>Another problem - to which I haven't yet found an adequate solution - is how to use a multiply operation (ratio) with frequencies in a way which caters for all of these situations. It's simple enough with a single event, but becomes tricky when trying to handle the different ways values accumulate. For example, if one multiplies the ratio by successive loop counter integers (as is done in the procedures above), the value can easily go over the top! When the starting point of a value in one of the pfields is non-zero (such as amplitude in the 'different' cases), you may want it to remain as it is for the first event, i.e., unaffected by the change factor. The code <code>if(counter == 0) factor = 0;</code> could be used to keep it the same if addition is involved, or <code>if(counter == 0) factor = 1</code> if multiplication is involved.</code></font></p>		<p><font face="Times New Roman"><code>No doubt much more is involved here and the solution could be much more elegant. As a musician and a programmer of modest capacity, I have tried to provide an approachable starting point for using Cscore as an environment in which to work out one's own ideas.</code></font></p>		<h3><font face="Times New Roman"><code>Reference Manual Page</code></font></h3>		<p><font face="Times New Roman"><code>CS14PTLS - alter partials content during a single tone<br>		<br>		Usage<br>		<br>		<b>cs14ptls -n</b><i>numftables</i> [<b>-s</b><i>startfactor</i>] [<b>-d</b><i>durfactor</i>] [<b>-a</b><i>amplitude</i>] [<b>-v</b><i>ampfactor</i>] <b>-f</b><i>frequency</i> [<b>-b</b><i>risetime</i>] [<b>-e</b><i>decaytime</i>] [<b>-t</b><i>processtype</i>] <i>outscore.sc</i><br>		<br>		<b>-n</b><i>numftables</i> (int) number of f-statements (will be the same as the number of notes)<br>		<b>-s</b><i>startfactor</i> (double) start time shaping factor; Default = 1: (no change)<br>		<b>-d</b><i>durfactor</i> (double) event duration shaping factor; Default = 1: no change)<br>		<b>-a</b><i>amplitude</i> (int) start amplitude level, Default = 15000<br>		<b>-v</b><i>ampfactor</i> (int) amplitude shaping factor; Default = 0: no change<br>		<b>-f</b><i>frequency</i> (double) frequency of ALL note events (Hz)<br>		<b>-b</b><i>risetime</i> (double) envelope rise time, Default = 0.5<br>		<b>-e</b><i>decaytime</i> (double) envelope decay time, Default = 0.5<br>		<b>-t</b><i>processtype</i> (int) processing type<br>		</code></font></p>		<blockquote>			<font face="Times New Roman"><code>0 ADD FIXED VALUE to initial value<br>			1 RAND factors affect the resultant values<br>			3 LINEAR series (add accumulating result of)<br>			2 LOGARITHMIC series (not implemented)<br>			4 EXPONENTIAL (not implemented)<br>			</code></font></blockquote>		<p><font face="Times New Roman"><i><code>outscore.sc</code></i><code> Csound scorefile produced by the program<br>		</code></font></p>		<p><font face="Times New Roman"><code>Defaults produce smoothly changing timbres, with 2 sec note events and start times advancing by 1 sec. Command line using defaults could be e.g.:<br>		<code>cs14ptls -n10 -f261.63 ptlssc.sc</code><br>		</code></font></p>		<p><font face="Times New Roman"><code>Example full command line:<br>		<code>cs14ptls -n10 -s1.2 -d1.5 -a24000 -v550 -f110 -b0.75 -e0.75 -t0 ptlssc.sc</code><br>		</code></font></p>		<h4><font face="Times New Roman"><code>Description</code></font></h4>		<p><font face="Times New Roman"><code>This program provides one way to experiment with timbral change over time. The context is additive synthesis, and through the combination of Csound's ability to mix note events if they overlap in time, and Cscore's ability to handle data algorithmically, the results can be manipulated with both flexibility and algorithmic precision.</code></font></p>		<p><font face="Times New Roman"><code>The key is that the program generates both the f-statements and the note events, providing a number of user inputs with which to guide the result. The f-statements are created from a partials-weighting matrix within the program (the str[] two-dimensional array), which is used with GEN10. The weights assigned to the partials (which could be zero to cancel certain ones) is of course critical to the tonal result. Remember that GEN10 deals with 'harmonic' partials: i.e., the next partial being weighted is the next integer multiple of the fundamental - there is no reason why this program couldn't be adapted to handle other GEN routines. Now that's interesting!</code></font></p>		<p><font face="Times New Roman"><code>It is also important that rise and decay parameters are provided. This affects the degree of smoothness with which the partials move in and out of each other, though the degree of difference between adjacent f-statements is also a factor. (Remember to create an orchestra that uses these pfields.) The random function could be seeded so that the start times would be identical for both f- and i-statements. This would keep them coordinated! As the program stands, the start times of the f- and i-statements vary marginally. This does not bother Csound, which happily compiles the score without complaining. It also compiled the score when the f-statement calls were randomised, but it was a bit bothered when calls to the same f-statement followed each other (and overlapped in time?): it zeroed all the additional (overlapping?) note statements which called the same function, causing gaps in the output sound. This makes the result really very random, and I've removed this feature. But it's easily put back by applying the random function to the f-statement number pfield in the note events: e.g., <code>if(ptype == RAND) {</code> etc. The lines of code for this are still in the program, but commented out.</code></font></p>		<h4><font face="Times New Roman"><code>Using the program</code></font></h4>		<p><font face="Times New Roman"><code>The purpose of this program is to provide a way to create tones which flow smoothly (and possibly unpredictably) in and out of varying types of timbral colour and degrees of richness. One could compare it with an additive synthesis module, which can achieve similar results.</code></font></p>		<p><font face="Times New Roman"><code>Note that the way I've set up the weighting of the GEN10 partials in <i>str[]</i> is only one way to do it. Such a matrix could be conceived in an infinite variety of ways, depending on the results desired. For example, all equal full strength weightings would produce a timbrally rich square wave, all odd or all even partials (with the others set to 0) would produce quite different tones, etc., and of course these can be mixed either to produce gradual or more sharply delineated changes between the types of tones. Thinking about these possibilities opens up the imagination to the potential of this program.</code></font></p>		<p><font face="Times New Roman"><code>Further development cries out for placing the f-statement two-dimensional matrix into a text file to be read into the program so that it can be adjusted without having to recompile.</code></font></p>		<p><font face="Times New Roman"><code>Source code: see the file <a href="cs14ptls.html">CS14PTLS.C</a><br>		<a href="#CONTENTS">Return</a> to Contents: list of example applications<br>		</code></font>	</body></html>