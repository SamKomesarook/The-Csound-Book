<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>An Introduction to Cscore</title>	</head>	<body bgcolor="white">		<h1><font face="Times New Roman">An Introduction to Cscore</font></h1>		<h2><font face="Times New Roman">Archer Endrich</font></h2>		<h3><font face="Times New Roman"><b>Introduction</b></font></h3>		<p><font face="Times New Roman">It took me several attempts to work out just how to get started with Cscore. This <i>Introduction to Cscore</i> is no more than that. My relative ignorance has helped me to write down the steps towards using <i>Cscore</i> in a systematic manner. It is written to give you, a musician and perhaps neophyte programmer like me a 'way in' to a very powerful part of <i>Csound</i>.</font></p>		<p><font face="Times New Roman">Thanks are due to Richard Boulanger for his set of tutorial examples in the <i>Csound Reference Manual</i>. I use some of these as starting points because they are such good examples and also to provide continuity with this source of information. Thanks are also due to Martin Atkins, Richard Orton and Richard Dobson, who helped me with my programming, but responsibility for the code below rests with me.</font></p>		<p><font face="Times New Roman">This code is really 'own use' code in the sense that there is very little in the way of error-trapping: i.e., messages to the user &amp; tidy exits if calls to functions fail or parameters go out of bounds, etc. I will introduce more of these into my versions of these programs as time goes on, but at this stage I didn't want to fill up the code with too many additional lines of this nature, which might obscure the essentially simple structure of the programs.</font></p>		<p><font face="Times New Roman">However, let me issue this WARNING in bold print: <b>do not run any score produced by one of these programs without first checking it for amplitude overflow!</b> Amplitudes way above range could be produced, so I do NOT take responsibility for what might happen to your speakers or your ears if you compiled and played back an unchecked score file.</font></p>		<p><font face="Times New Roman">Finally, I hope that some of the musical ideas here will be of interest, and that you'll be able to take them further for your own purposes.</font></p>		<h3><font face="Times New Roman"><b>Overview</b></font></h3>		<p><font face="Times New Roman"><b>Cscore</b> is a facility within <i>Csound</i> which enables you to write a program which writes a <i>Csound</i> scorefile. <i>Cscore</i> is a library of functions which makes it relatively easy to do this; the programming is in the C programming language, but the <i>cscore.lib</i> functions do a great deal of the work, leaving you to concentrate on what the score will do. With Cscore, you have the full power of 'C' available to structure your program and employ mathematical and logical functions to create and alter data values.</font></p>		<p><font face="Times New Roman"><b>The power of <i>Cscore</i> lies in the fact that a <i>Csound</i> score is really a mixing palette</b>. Start times can be adjusted precisely, including overlapping sounds; different sounds can be selected by using different instrument numbers ('i1', 'i2', etc., any of which can be a sound read into <i>Csound</i> with <b>soundin</b>), each event can have its own amplitude, pitch, etc. It's really a very powerful environment. What <i>Cscore</i> makes possible is <b>an algorithmic mix window</b> which uses your own functions. This is a computer programmer/composer's dream-equivalent to a piece of manuscript paper. One is concerned with the high-level business of placing the events on the page, with at least some of the attendant 'expressive' features which bring a score to life. I hope that the potential of this environment becomes clear during the course of this <i>Introduction to Cscore</i>.</font></p>		<p><font face="Times New Roman">NOTE: The Composers' Desktop Project implementation of <i>Cscore</i> makes it possible to use an indefinite number of command line parameters, which makes it easier to explore the possibilities of a new idea. Most of the specifics about using <i>Cscore</i> on CDP Systems have been removed from this document (e.g., using the CDP makefile mechanism on Ataris), but are contained in the version supplied with CDP Systems.</font></p>		<h3><font face="Times New Roman"><b>Working environment for <i>Cscore</i></b></font></h3>		<p><font face="Times New Roman">Your <i>Cscore</i> working environment requires the following:</font></p>		<dir>			<dir><font face="Times New Roman">TEXT EDITOR</font>				<p><font face="Times New Roman">in your text editor, tabs should be 'real' tabs, not just a group of spaces; e.g., <i>MicroEmacs</i> has 'real' tabs, whereas <i>Wordplus</i> uses spaces. This avoids the problem of invisible white space in the makefile: spaces when there should be tabs. On PC's, <i>Notepad</i> or most other text editors should be ok.</font></p>				<p><font face="Times New Roman">COMPILER</font></p>				<p><font face="Times New Roman">you need to compile your program <i>.c</i> with an appropriate compiler. The versions of the 'C' which you will need to use must comply with the compiler used to compile the <i>Cscore</i> libraries as supplied with your version of <i>Csound</i>.</font></p>				<p><font face="Times New Roman">MAKEFILE</font></p>				<p><font face="Times New Roman">a suitably modified MAKEFILE with which to compile your program, or whatever other compilation mechanism which your compiler uses.</font></p>				<p><font face="Times New Roman">ESSENTIAL HEADERS</font></p>				<p><font face="Times New Roman">the header files <i>stdio.h</i> and <i>cscore.h</i> are essential and must be available.</font></p>				<p><font face="Times New Roman">OPTIONAL HEADERS</font></p>				<p><font face="Times New Roman">On Atari if you want to enter floating point numbers as extra parameters, note that you will also need to include <i>stdlib.h</i>. Your program will then convert from the string of the command line to an actual number with <i>atof()</i>. For integers, <i>atoi()</i> is used and <i>stdlib.h</i> is not needed. For various other mathematical operations <i>math.h</i> may also be needed.</font></p>				<p><font face="Times New Roman">WAYS TO SPECIFY THE VARIOUS HEADERS</font></p>				<p><font face="Times New Roman">Note that double quotes around a header file indicate that the system will look in the current directory first; those in &lt;...&gt;'s will be elsewhere on your disk in the <b>headers</b> directory. It is safest to put them all in the directory accessed by the compiler, which will have its own path setup.</font></p>				<p><font face="Times New Roman">LINK <i>CSCORE.LIB</i></font></p>				<p><font face="Times New Roman">Note in particular that <i>cscore.lib</i> needs to be linked to your program. Otherwise the compiler will not find the specifically 'cscore' functions used in your program.</font></p>				<p><font face="Times New Roman">RUN YOUR APPLICATION</font></p>				<p><font face="Times New Roman">You then run your application according to its usage. This produces the output <i>Csound</i> scorefile from your program. You may also need to read in a pre-existing <i>Csound</i> scorefile as well. This should be in the current directory.</font></p>				<p><font face="Times New Roman">CSOUND ORCHESTRA FILE</font></p>				<p><font face="Times New Roman">You will of course need a suitable <i>Csound</i> orchestra file for use with your scorefile. This should be in the current directory.</font></p>				<p><font face="Times New Roman">RUN <i>CSOUND</i></font></p>				<p><font face="Times New Roman">You then run Csound in the normal way, using your .orc and .sc files: a generic command line to illustrate this would be: csound -omy.out my.orc my.s.</font></p>			</dir>		</dir>		<h3><font face="Times New Roman"><b>Key Components of a <i>Cscore</i> Application Program</b></font></h3>		<dir>			<dir><font face="Times New Roman">HEADERS</font>				<p><font face="Times New Roman"><i>#include &lt;stdio.h&gt;</i> and<i> &lt;stdlib.h&gt;</i> if (on Atari) reading in floating point numbers from the command line. You may also need <i>&lt;math.h&gt;</i> if using other floating point operations &#151; and then (on Atari) compile with <b>-f8</b> to make use of the floating point coprocessor). And of course <i>&quot;cscore.h&quot;</i> (double quotes if in current directory, otherwise <i>&lt;cscore.h&gt;</i>.</font></p>				<p><font face="Times New Roman">USAGE AND HELP</font></p>				<p><font face="Times New Roman">it is useful to provide your own customised help / usage message as a reminder of what to do; the one used here is called <i>phelp()</i>.</font></p>				<p><font face="Times New Roman">VOID MAIN()</font></p>				<p><font face="Times New Roman"><i>void</i></font></p>				<p><font face="Times New Roman"><i>main(argc, argv)</i> etc. for reading and parsing the command line arguments. Note that in CDP's version of <i>Cscore</i>, you can have an indefinite number of command line arguments &#151; presumed by this <i>Introduction</i> . In the original version, only two were possible: <i>infile</i> and <i>outfile</i>.</font></p>				<p><font face="Times New Roman">CODE FOR ADDITIONAL COMMAND LINE PARAMETERS (optional)</font></p>				<p><font face="Times New Roman">these are flagged parameters, such as <b>-s</b><i>starttime</i>. Besides providing flexibility, this also enables you to produce different versions of the output score, if only just to make it easy to experiment with your program.</font></p>				<p><font face="Times New Roman">THE CDP INITIAL() FUNCTION</font></p>				<p><font face="Times New Roman">call to <i>initial(argc, argv)</i> to initialize and parse the rest of the commandline; this re-checks the flagged parameters and then opens the files you've listed. The source for this CDP-specfic function is included so that you can understand what this part of the examples provided is doing.</font></p>				<p><font face="Times New Roman">TITLE / COMMENT STATEMENT</font></p>				<p><font face="Times New Roman">a <i>putstr(; ... )</i> statement to identify the score and its purpose.</font></p>				<p><font face="Times New Roman">FUNCTION STATEMENT</font></p>				<p><font face="Times New Roman">create the function table(s) and provide a tempo statement if needed.</font></p>				<p><font face="Times New Roman">EVENT LIST</font></p>				<p><font face="Times New Roman">create a list of <i>n</i> events depending on how many events you are going to have in your score. Note that this must be <i>a = lcreat(number_of_events)</i> &#151; i.e., the 'a' is mandatory. There may be other copies identified as 'b', but you then use <i>lcat()</i> to join them to a: <i>a = lcat(a, b)</i>. This is only the list of events, not the events themselves.</font></p>				<p><font face="Times New Roman">THE EVENTS THEMSELVES</font></p>				<p><font face="Times New Roman">now you must create the events themselves: these are always identified as 'e': <i>e = createv(number_of_pfields)</i> etc.</font></p>				<p><font face="Times New Roman">ACCESS TO THE PFIELDS</font></p>				<p><font face="Times New Roman">you must come to terms with how to point to the list, the events, and the contents of the pfields with the proper syntax. This is explained in the <i>Csound</i> manual, discussed in detail in this document and illustrated in most of the examples below.</font></p>				<p><font face="Times New Roman">YOUR OWN OPERATIONS/FUNCTIONS</font></p>				<p><font face="Times New Roman">you have the full power of C to draw upon to create structures and perform mathematical and logical operations. This will be the operational core of your program, i.e. why you wanted to write it in the first place!</font></p>				<p><font face="Times New Roman">TERMINATE THE SECTIONS AND MARK THE END OF THE SCORE</font></p>				<p><font face="Times New Roman">finally,<i> putstr(&quot;...&quot;)</i> is used to place end-of-section marker (&quot;s&quot;) and the end-of-score marker (&quot;e&quot;).</font></p>			</dir>		</dir>		<p><font face="Times New Roman">It always looks a bit complicated when an explanation is written out like this, but a quick look at <b>Section 5 &#151; The Basics</b> will show that it's all really quite simple. The difficult bit will be how to code your 'operational core'.</font></p>		<h2><font face="Times New Roman"><b>Example Programs with Commentary</b></font></h2>		<h3><font face="Times New Roman"><b>Section 5A - The Basics</b></font></h3>		<p><font face="Times New Roman"><i>Section I focusses on the basic mechanics of a </i>Cscore<i> program. The code for each of these programs is written out in full. The full source (with more comments) for all the examples is on the CD-ROM for reference.</i></font></p>		<h3><font face="Times New Roman"><b>CS1WRITE.C &#151; Outline the Core Ingredients of a <i>Cscore</i> Program</b></font></h3>		<p><font face="Times New Roman">SYNOPSIS: Illustrates all the basic ingredients of a <i>Cscore</i> application program:</font></p>		<dir>			<dir><font face="Times New Roman">headers (<i>#include</i>),</font>				<p><font face="Times New Roman"><i>phelp()</i> optional function,</font></p>				<p><font face="Times New Roman">declare <i>main()</i> with <i>argc</i> (the argument counter) and <i>argv[]</i> (the argument strings)</font></p>				<p><font face="Times New Roman">code for reading in extra parameters,</font></p>				<p><font face="Times New Roman">CDP <i>initial()</i> function,</font></p>				<p><font face="Times New Roman">fix Falcon stderr bug &#151; shown once here in case needed;</font></p>				<p><font face="Times New Roman">write out the output score file: text with <i>putstr(&quot;...&quot;)</i>, event with <i>putev(e)</i> and list of events with <i>lput(a)</i>;</font></p>			</dir>		</dir>		<p><font face="Times New Roman">CODE:</font></p>		<dir>			<dir><font face="Courier New">/* CS1WRITE.C &#151; program to write out the bare bones of Csound score, using CSCORE */<br>				/* A fix for a bug re stderr on early Falcon systems is shown below, but commented out; activate it in the (unlikely) event that it is needed. */</font>				<p><font face="Courier New">/* HEADERS */</font></p>				<p><font face="Courier New">#include &lt;stdio.h&gt; /* This handles things like printf */<br>				#include &lt;stdlib.h&gt; /* needed for atof() */<br>				#include &lt;math.h&gt; /* needed for certain maths functions */<br>				#include &quot;cscore.h&quot; /* The double quotes mean this .h is in the current directory.*/<br>				/* Writing &lt;cscore.h&gt; means find it anywhere in the path. */</font></p>				<p><font face="Courier New">/* USAGE / HELP */<br>				void<br>				phelp(void) /* Adapt the phelp() function as each program requires */</font></p>				<p><font face="Courier New">{<br>				printf(&quot;CS1WRITE: writes outline of a Csound .sc\n&quot;);<br>				printf(&quot;\tUsage: cs1write [-ffreq] outscore.sc\n&quot;);<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">/* DECLARING MAIN */<br>				void<br>				main(argc,argv)<br>				int argc;<br>				char *argv[];</font></p>				<p><font face="Courier New">{<br>				/* DECLARATIONS */<br>				EVENT *e;<br>				EVLIST *a;<br>				int freq = 256; /* variable for user input; default is 256 if none entered. */<br>				/* illustrates the switch mechanism &#151; not actually used*/<br>				/* FIX FOR FALCON STDERR BUG */<br>				/*!!!*/<br>				/* stderr-&gt;_file = open(&quot;con:&quot;, 2); */ /* fixup falcon stderr bug */<br>				/*!!!*/<br>				/* USER-DEFINED FLAGS/PARAMETER INPUT (CDP Systems only) */<br>				/* Showing mechanism for entering parameters on a command line. */<br>				while(argc &gt; 1 &amp;&amp; argv[1][0] == '-') {<br>				switch(argv[1][1]) {<br>				case 'f':<br>				freq = atoi(&amp;argv[1][2]);<br>				break;<br>				default:<br>				fprintf(stderr, &quot;CS1WRITE: '%s' not an option\n&quot;, argv[1]);<br>				phelp();<br>				exit(1);<br>				}<br>				argc--, argv++; /* decrement argument counter &amp; move to next arg */<br>				}<br>				if(argc &gt; 2) { /* the 2 here means program name &amp; output score name */<br>				phelp(); /* print usage if too many names here! */<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">/* CDP VERSION OF INITIAL() */<br>				initial(argc, argv); /* re-check commd line arguments &amp; open files specified */</font></p>				<p><font face="Courier New">/* any other variables needed can go here */</font></p>				<p><font face="Courier New">/* BODY OF PROGRAM */<br>				putstr(&quot;;What follows is the Csound score written by CS1WRITE\n&quot;);<br>				putstr(&quot;f1 0 256 10 1&quot;); /* i.e., write a function statement into the score */<br>				e = defev(&quot;t 0 120&quot;); /* define a tempo statement event */<br>				putev(e); /* put this tempo statement event into the score */<br>				putstr(&quot;\n; ...We now omit everything to do with events &amp; pfields.&quot;);<br>				putstr(&quot; This score won't do anything!\n&quot;);<br>				putstr(&quot;s&quot;); /* write an s to define a section break */<br>				putstr(&quot;e&quot;); /* write an e to mark the end of the score */<br>				} /* end of main() */</font></p>			</dir>		</dir>		<p><font face="Times New Roman">When run, <i>cs1write</i> produces the following output:</font></p>		<dir>			<dir><font face="Courier New">; What follows is the Csound score written by CS1WRITE<br>				f1 0 256 10 1<br>				t 0 120<br>				; ...We now omit everything to do with events &amp; pfields. This score won't do anything!<br>				s<br>				e</font>			</dir>		</dir>		<p><font face="Times New Roman">The extension suffix used with the executable program depends on your computer and compiler; e.g., it will be '.exe' on PC's.</font></p>		<h3><font face="Times New Roman"><b>CS2ONEEV.C &#151; Create a Score With Only One Event</b></font></h3>		<dir>			<dir><font face="Courier New">/* CS2ONEEV &#151; write Csound score comprising only one event with pfields, using Cscore */</font>				<p><font face="Courier New">#include &lt;stdio.h&gt; /* This handles things like printf */<br>				#include &lt;stdlib.h&gt; /* needed for atof() */<br>				#include &lt;math.h&gt; /* needed for certain maths functions */<br>				#include &quot;cscore.h&quot; /* the Cscore header */</font></p>				<p><font face="Courier New">void<br>				phelp(void)</font></p>				<p><font face="Courier New">{<br>				printf(&quot;CS2ONEEV: writes an outscore.sc with one event, + user flags\n&quot;);<br>				printf(&quot;\tUsage: cs2oneev [-ffreq] [-dduration] outscore.sc\n&quot;);<br>				printf(&quot;\tNB: outscore, but no inscore with this program\n&quot;);<br>				printf(&quot;\t-f and -d are optional because defaults are written into the program\n&quot;);<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">void<br>				main(argc, argv)<br>				int argc; /* counter for commandline arguments */<br>				char *argv[]; /* string array for commandline arguments */</font></p>				<p><font face="Courier New">{<br>				EVENT *e; /* declare structure for an event (including pfields) */<br>				EVLIST *a; /* declare structure for the list of events */<br>				int freq = 440; /* variable for frequency; default is 440Hz */<br>				float dur = 2.0; /* variable for duration of event; default is 2 sec. */<br>				while(argc &gt; 1 &amp;&amp; argv[1][0] == '-') { /* loop to read flags; identify flag by minus sign */<br>				switch(argv[1][1]) { /* switch on the letter */<br>				case('f'):<br>				freq = atoi(&amp;argv[1][2]); /* convert string to integer number */<br>				break;<br>				case('d'):<br>				dur = atof(&amp;argv[1][2]); /* convert string to float number */<br>				break;<br>				default:<br>				fprintf(stderr, &quot;cs2oneev: the option %s is not recognised\n&quot;, argv[1]);<br>				phelp();<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">argc--, argv++; /* decrement counter, move to next argument */</font></p>				<p><font face="Courier New">}</font></p>				<p><font face="Courier New">if(argc &gt; 2) { /* remaining args should be progname &amp; outfile */<br>				phelp(); /* call phelp() for messages */<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">initial(argc, argv); /* re-check arguments &amp; open outfile */<br>				putstr(&quot;;What follows is the Csound score written by CS2ONEEV.TTP\n&quot;);<br>				putstr(&quot;f1 0 256 10 1 .5 .3&quot;); /* write a function statement */<br>				e = defev(&quot;t 0 60&quot;); /* define a tempo statement event */<br>				putev(e); /* write this event to the score */<br>				a = lcreat(1); /* create a space for list of one event */<br>				e = createv(5); /* create space for 5 pfields */<br>				e-&gt;op = 'i'; /* define instrument op code (note use of single quotes)*/<br>				e-&gt;p[1] = 1; /* set this to instrument number 1 */<br>				e-&gt;p[2] = 0.0; /* start time set to 0.0 */<br>				e-&gt;p[3] = dur; /* duration set to user input */<br>				e-&gt;p[4] = 10000; /* amplitude set to 10000 &#151; ca 1/3 max */<br>				e-&gt;p[5] = freq; /* pitch set to user input */<br>				a = lappev(a, e); /* append these pfield events to master list 'a'*/<br>				lput(a); /* write out this one event list */<br>				lrelev(a); /* release space for list 'a' */<br>				putstr(&quot;e&quot;); /* write an 'e' to mark the end of the score */ }<br>				} /* end of main() */</font></p>			</dir>		</dir>		<p><font face="Times New Roman">Here the emphasis is on how a single event is created and then written to the score. This may be an unusual case, because normally one is working with several events &#151; <i>Cscore</i> is in its element when creating large scores!</font><font face="Courier New"><br>		</font></p>		<p><font face="Times New Roman">Here a <b>list</b> of one event is made: </font><font face="Courier New"><br>		</font></p>		<dir>			<p><font face="Courier New"><i>a = lcreat(1) </i></font><font face="Times New Roman">; note that this primary list is <b>always</b> identified by 'a'</font><font face="Courier New"><br>			</font><font face="Times New Roman">; only <i>copies</i> of this list can be assigned to other variables. </font></p>		</dir>		<p><font face="Times New Roman">Then an <b>event with 5 pfields</b> is made:</font><font face="Courier New"><br>		</font></p>		<dir>			<p><font face="Courier New"><i>e = createv(5)</i></font><font face="Times New Roman"><i> </i></font><font face="Times New Roman">; again, 'e' is THE identifier for events.</font><font face="Courier New"><br>			</font></p>		</dir>		<p><font face="Times New Roman">There is only one event in the list, so there is no need to indicate to which event in the list you assign data, so filling the pfields is done directly: <i>e-&gt;op = 'f''</i> etc. This one instrument event 'e' is then appended to the master list 'a' comprising the 'f' and 't' statements made above: <i>a = lappev(a, e)</i>; everything is then written to the score with <i>lput(a)</i>. The next example, <i>cs3evlst.c</i> shows the difference in coding when there is more than one event.</font></p>		<h3><font face="Times New Roman"><b>CS3EVLST.C &#151; Create a List of Events With Command Line Parameter Input</b></font></h3>		<dir>			<dir><font face="Courier New">/* CS3EVLST.C &#151; write list of events with pfields using CSCORE *</font>				<p><font face="Courier New">#include &lt;stdio.h&gt; /* This handles things like printf */<br>				#include &lt;stdlib.h&gt; /* Needed for atof(), compiled with the <b>-f</b> flag */<br>				#include &lt;math.h&gt; /* not used here, but could be needed for e.g., a random function */<br>				#include &quot;cscore.h&quot;</font></p>				<p><font face="Courier New">void<br>				phelp(void)</font></p>				<p><font face="Courier New">{</font></p>				<p><font face="Courier New">printf(&quot;CS3EVLST: program to write out a list of events\n&quot;);<br>				printf(&quot;Usage: cs3evlst [-ddur] outscore.sc\n&quot;);<br>				printf(&quot;\tThe '-dvalue' enables you to enter an event duration.\n&quot;);<br>				printf(&quot;\t different each time you run the program.\n&quot;);<br>				exit(1);<br>				}<br>				void<br>				main(argc, argv)<br>				int argc; /* counter for commandline arguments */<br>				char *argv[]; /* string array for commandline arguments */</font></p>				<p><font face="Courier New">{<br>				EVENT *e; /* declare structure an event (incl pfields) */<br>				EVLIST *a; /* declare structure for your list of events */<br>				int num = 20; /* specifies number of events in the list */<br>				int i; /* for loop iteration counter */<br>				int maxamp = 30000; /* max amplitude with safety margin */<br>				double st = 0.00; /* start time of first event */<br>				float dur = 0.50; /* (default) duration of first event */<br>				double amp; /* amplitude &#151; this variable not used here */<br>				double pch =440.00; /* pitch of first event */<br>				double rise = 0.10; /* initial rise time */<br>				double decay = 0.10; /* initial decay time */<br>				while(argc &gt; 1 &amp;&amp; argv[1][0] == '-') {<br>				switch(argv[1][1]) {<br>				case ('d'):<br>				dur = atof(&amp;argv[1][2]);</font></p>				<p><font face="Courier New">break;</font></p>				<p><font face="Courier New">default:</font></p>				<p><font face="Courier New">fprintf(stderr, &quot;cs2oneev: unknown option '%s'\n&quot;, argv[1]);</font></p>				<p><font face="Courier New">phelp();</font></p>				<p><font face="Courier New">exit(1);<br>				}</font></p>				<p><font face="Courier New">argc--, argv++;</font></p>				<p><font face="Courier New">}</font></p>				<p><font face="Courier New">if(argc &gt; 2) {<br>				phelp();<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">initial(argc, argv); /* Now initialisation of the arguments provided */<br>				putstr(&quot;;What follows is the Csound score written by CS3EVLST&quot;);<br>				putstr(&quot;;NB &#151; You will need an .orc file with a LINEN generator\n\n&quot;);<br>				putstr(&quot;f1 0 256 10 1 .5 .3&quot;); /* write a function statement */<br>				e = defev(&quot;t 0 60&quot;); /* define a tempo statement event */<br>				putev(e); /* write this tempo event to the score */<br>				a = lcreat(num); /* create a space for list of <i>num</i> events */<br>				for (i = 0; i &lt; num; i++) { /* use of FOR loop to create num number of events */<br>				e = createv(7); /* create space for 7 pfields */<br>				e-&gt;op = 'i'; /* define instrument op code */<br>				e-&gt;p[1] = 1; /* set this to instrument number 1 */<br>				e-&gt;p[2] = st; /* start time begins at Default: 0.0 */<br>				e-&gt;p[3] = dur; /* duration of this event set to user input */<br>				e-&gt;p[4] = maxamp/3; /* amplitude 1/3 max to handle overlaps */<br>				e-&gt;p[5] = pch; /* pitch begins at 440 Hz ( A above middle C) */<br>				pch += (pch * 0.010); /* create non-diatonic rising sequence */<br>				e-&gt;p[6] = rise; /* start of envelope shape in p6 */<br>				rise += 0.010; /* extend rise time slightly with each event */<br>				e-&gt;p[7] = decay; /* end of envelope shape in p7 */<br>				decay += 0.010; /* extend decay time slightly with each event */<br>				st += dur; /* advance start time by dur sec. */<br>				a = lappev(a, e); /* append these pfield events to the list */<br>				}</font></p>				<p><font face="Courier New">lput(a); /* write out this<i> num</i> event list */<br>				lrelev(a); /* release space for list a */<br>				putstr(&quot;e&quot;); /* write an e to mark the end of the score */<br>				} /* end of main() */</font></p>			</dir>		</dir>		<p><font face="Times New Roman">The salient issue here is what happens when there is a <b>list of events</b>. The number of events in the list is given with a variable, to make it easier to change. This is still 'hard-wired' into the program &#151; it could be a variable on the command line. So a list for<i> num</i> events is created BEFORE entering the <b>for</b> loop, and the events themselves, each with 7 pfields, are created WITHIN the <b>for</b> loop and are also appended to the list of events WITHIN the <b>for</b> loop. Accessing the pfields of each event is the same as in the previous program: e-&gt;op = 'i' etc. A new event is added to the list each time around the loop. This is a way of going about things which avoids the double dereferencing described later.</font></p>		<p><font face="Times New Roman">This program uses an extra parameter to set the duration from the command line. It is a number with a decimal portion (a 'floating point' number, so it is declared as a double: <i>double dur = 0.50</i>. Because a value is assigned, this declaration also functions as a default, making it optional whether or not you actually provide a value on the command line.</font></p>		<p><font face="Times New Roman">Let's look at the code for reading this command line parameter in detail:</font></p>		<dir>			<dir><font face="Courier New"><b>while(argc &gt; 1</b></font><font face="Times New Roman"><b> </b></font><font face="Times New Roman">&#151; argument count number 1 is the name of the program; given that this has been supplied, we are now looking at the second parameter. The <i>while</i> loop will continue until it reaches a parameter which doesn't begin with a '-', which in this case will be a filename (<i>infile.sc</i> or <i>outfile.sc</i>).</font>				<p><font face="Courier New"><b>&amp;&amp; argv[1][0] == '-')</b></font><font face="Times New Roman"> &#151; AND the first character of this argument is a '-',</font></p>				<p><font face="Courier New"><b>switch (argv[1][1]) {</b></font><font face="Courier New"> </font><font face="Times New Roman">&#151; then we switch on the basis of the second character. This is very important, because it means that there can be more than one case, in fact several can be used on the command line: <b>-d</b> could be for duration, <b>-s</b> could be for start time etc., and the switch mechanism would have code to handle each of these cases. If you enter a letter for which no case has been defined, the default case provides the user with an error message and calls the phelp() function to display the program's usage.</font></p>				<p><font face="Courier New"><b>argc--, argv++</b></font><font face="Times New Roman"> &#151; there is now one less argument to examine, and move on to the next one.</font></p>				<p><font face="Courier New"><b>if(argc &gt; 2)</b></font><font face="Times New Roman"> &#151; activates the phelp() function if the argument count exceeds 2. The flags are now used and <b>argc</b> decremented accordingly. There should now be only two arguments left, the program name itself and, in this case, the <i>outscore</i> name. If there is also an <i>inscore</i> (a score to read in), then change the 2 in the above code to 3.</font></p>			</dir>		</dir>		<p><font face="Times New Roman">This program also increases the start times, the pitch, and the rise and decay times each time around the loop. The user could make the program more useful for experimentation by enabling command line input of the initial value of each of these parameters (see CS10ALTR).</font></p>		<h3><font face="Times New Roman"><b>CS4SCALE.C &#151; Make a Rising Quarter-tone Scale in a FOR Loop</b></font></h3>		<dir>			<dir><font face="Courier New">/* CS4SCALE.C: adapted from a Cscore program by R. Orton, Music Technology Group, U/York 1989<br>				This program produces a <i>Csound</i> score with a rising quarter-tone scale.<br>				The pitch notation is in octaves/semitones, so use <b>cpspch</b> in the <i>.orc</i> .*/</font>				<p><font face="Courier New">#include &lt;stdio.h&gt;<br>				#include &lt;stdlib.h&gt; /* stdlib.h &amp; math.h not really needed here; included so in place if needed */<br>				#include &lt;math.h&gt; /* for changes to the code which might require them */<br>				#include &quot;cscore.h&quot;</font></p>				<p><font face="Courier New">void</font></p>				<p><font face="Courier New">phelp(void)</font></p>				<p><font face="Courier New">{<br>				printf(&quot;\nCS4SCALE: makes a rising quarter-tone scale in a FOR loop\n&quot;);<br>				printf(&quot;Usage: cs4scale outscore.sc\n&quot;);<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">void</font></p>				<p><font face="Courier New">main(argc, argv)<br>				int argc;<br>				char *argv[];</font></p>				<p><font face="Courier New">{<br>				EVENT *e;<br>				EVLIST *a;<br>				int i;<br>				double st = 0.0; /* start time set to 0.0 */<br>				double pch = 8.00; /* pitch set to Middle C */<br>				if(argc &lt; 2) {<br>				phelp();<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">initial(argc, argv);<br>				putstr(&quot;;CS4SCALE - make a scale\n\n&quot;); /* write comment title of prg */<br>				putstr(&quot;f1 0 512 10 1 .5 .3&quot;);<br>				e = defev(&quot;t 0 76&quot;); /* define tempo statement event */<br>				putev(e); /* write tempo event */<br>				a = lcreat(24); /* create blanks for a 24 item list */<br>				for(i = 0; i &lt;= 24; i++) { /* loop to fill pfields of each event */<br>				e = createv(5); /* create blanks for 5 pfields */<br>				e-&gt;op = 'i'; /* define op code: i for instr */<br>				e-&gt;p[1] = 1; /* 1 for instr 1 in pfield 1 */<br>				e-&gt;p[2] = st; /* start time is 0.0 as defined above */<br>				st += 0.083; /* add .083 to current start time each loop iteration */<br>				e-&gt;p[3] = 0.1; /* set duration to .1 sec (0.017 sec overlap) */<br>				e-&gt;p[4] = 15000; /* set amplitude to 15000 (out of 32767) */<br>				e-&gt;p[5] = pch; /* set pitch to 8.00 as defined above (middle C) */<br>				pch += 0.0050; /* add a 1/4-tone to the current pitch on each iteration */<br>				a = lappev(a, e); /* append pfield data of this note event to event list */<br>				}</font></p>				<p><font face="Courier New">lput(a); /* write out the list */<br>				lrelev(a); /* release space for list a */<br>				putstr(&quot;e&quot;); /* write an e for end of score */<br>				}</font></p>			</dir>		</dir>		<p><font face="Times New Roman">This program is essentially the same as <i>cs3evlst.c</i> except that the starting pitch for the scale is given in <i>Csound's</i> octave-semitone notation (.01 represents one semitone). This means that the orchestra needs to convert from this notation to Hz with <b>cpspch</b>. This start value could also be provided on the command line. As far as the <i>Cscore</i> program is concerned, this is a floating point number and is declared and treated as such (<i>atof()</i>). The sound output will be rather 'wooden' because only the pitch parameter changes. Later programs introduce more flexibility!</font></p>		<h3><font face="Times New Roman"><b>CS5READ.C &#151; Read in a Pre-existing Scorefile</b></font></h3>		<dir>			<dir><font face="Courier New">/* CS5READ &#151; this program reads in a pre-existing Csound score file and writes it out again unchanged */</font>				<p><font face="Courier New">#include &lt;stdio.h&gt; /* only the very basic headers are needed for this! */<br>				#include &quot;cscore.h&quot;</font></p>				<p><font face="Courier New">void</font></p>				<p><font face="Courier New">phelp(void) { /* Adapt the phelp() function as each program requires */</font></p>				<p><font face="Courier New">printf(&quot;CS4READ: read a score &amp; writes it out unchanged\n&quot;);<br>				printf(&quot;Usage: cs5read inscore.sc outscore.sc\n&quot;);<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">void</font></p>				<p><font face="Courier New">main(argc, argv)<br>				int argc;<br>				char *argv[];</font></p>				<p><font face="Courier New">{<br>				EVLIST *a; /* declare structure for the list of events */<br>				if(argc &lt; 2) { /* Test that user's commandline is ok */<br>				phelp();<br>				exit(1);<br>				}</font></p>				<p><font face="Courier New">initial (argc, argv); /* initialise command line arguments */<br>				putstr(&quot;;score produced by CS5READ&quot;);<br>				a = lget(); /* read score events in, return the list ptr */<br>				lput(a); /* write out unchanged list of score events */<br>				putstr(&quot;e&quot;); /* add end of score marker */<br>				}</font></p>			</dir>		</dir>		<p><font face="Times New Roman">The input score is read with the function <i>lget()</i> -- i.e., get the list of events; the code is <i>a = lget()</i>, and again, note the use of 'a'. <b>This automatically also reads in the pfields of the events, assigning them to e</b> etc. Thus <i>lput(a)</i> writes out the complete score again &#151; identical to the input score, as no processing has been done by this program. Confirm by displaying the files on your screen. (In earlier versions of <i>cscore.lib</i>, <i>lget()</i> could not handle a 'comment' on the line which defines the wavetable function. If your <i>outscore.sc</i> has no events in it, look for a comment on the 'f' line of <i>inscore.sc</i> and remove it. This limitation of <i>lget()</i> should have been fixed in later versions of the library.)</font></p>		<h3><font face="Times New Roman"><b>Section 5B &#151; Making Changes to Score Data</b></font></h3>		<p><font face="Times New Roman"><i>Please note that the full source code for all these example scores is on CD-ROM. The following text only picks out the key lines of code which move us deeper into an understanding of how to handle programming in the </i>Cscore<i> environment. Please have the source for each program to hand while reading Sections 5B and 5C.</i></font></p>		<p><font face="Times New Roman">We now move on to the heart of the matter, making our 'algorithmic mix window' work for us in a powerful and flexible way. It is useful to remind ourselves that melody, harmony, amplitude, duration &amp; rhythm, and timbre are among the basic components of music. The <i>Csound</i> orchestra (or our own pre-prepared sounds read in with <b>soundin</b>) gives us a lot of control over the timbral dimension of music. Our series of note events in the score file makes up a melody &#151; or in more general terms, a sequence of sounds unfolding in time. Amplitude and duration (rhythm) are also handled in the score, allowing for the creation of chords (all event start times are the same), discrete events (next start time is some time after the end of the previous event), or overlapping events (next start time is before the end of the previous event).</font></p>		<p><font face="Times New Roman">We can shape these musical parameters algorithmically by passing the column of figures for a given parameter of a block of events through our own algorithm. The function call mechanism introduced below is designed to provide a way to go from the actual score-writing section to one's own user-defined functions with which to manipulate values; these may at times become quite complex and themselves call other functions. By placing a key initial variable in the command line, we can also 'seed' the algorithm when we call the program, thus creating a useful experimental environment in which to work towards an ideal result without having to recompile the program each time.</font></p>		<p><font face="Times New Roman">Eventually, the user will build up a repertoire of functions for various purposes, and the overall structure of the environment can be handled in a variety of ways: functions for all parameters handled in one program, or separate programs with a variety of functions for each parameter, or a library of functions to be linked to the main program.</font></p>		<p><font face="Times New Roman">For the moment, though, we start slowly by making a change to one pfield of one event. This is done here with the overkill of calling a function &#151; so that this mechanism can be introduced in an otherwise simple context. These program examples are based on those in the <i>Csound</i> manual, extending them in various ways, to provide a link with the documentation there. Thus additional commentary on the <i>Csound</i> manual examples is provided, as well as the beginnings of a more extended functionality.</font></p>		<h3><font face="Times New Roman"><b>CS6CHNGE.C &#151; Call a Function to</b> <b>Change One Parameter in One Event</b></font></h3>		<p><font face="Times New Roman">(See CDP <i>Csound</i> Manual, p.86-7.) First of all, this program reads an <i>inscore.sc</i> with several events. It then sets a pointer to point at the 4th event with the code <i>f = &amp;a-&gt;e[4], </i>i.e., the value of <i>f</i> is the address of event 4 in list 'a'; '&amp;' is the address operator. It then goes on to access the 5th parameter of this event with <i>(*f)-&gt;p[5]</i>. Understanding how this works is absolutely vital in order to know how to handle any <i>Cscore</i> application programming task, so I am going to go over the mechanism here from several points of view. If all of this is familiar ground, please skip over this section!</font></p>		<p><font face="Times New Roman">What is of interest here is how this one parameter is being accessed. Double dereferencing is being used: that is, a pointer to a pointer (in other words, one address which points to another address). The declaration is **f, one asterisk for each address, as it were.</font></p>		<p><font face="Times New Roman">You will note that the programs so far have not involved ampersands ('&amp;'). This is because either only one event was involved, or each event was formed and added to the list of events one by one (e.g. inside the FOR loop). In <i>cs6chnge.c</i> the situation is a little different because we are working through the mechanism of the list of events. Now we have to make sure our event pointer is connected to the start of this list (i.e. its start address), that we point to the event in that list that we want to access, and finally that we point to the appropriate pfield in that event.</font></p>		<h3><font face="Times New Roman"><b>Step-by-step Explanation:</b></font></h3>		<dir>			<dir><font face="Courier New"><i>a = lget();</i></font><font face="Courier New"> /* read <i>inscore</i>, assigning it to the master event list 'a': EVLIST *a */</font>				<p><font face="Courier New"><i>f = &amp;a-&gt;e[4];</i> /* point to event 4 in this list of events */</font></p>				<p><font face="Courier New"><i>(*f)-&gt;p[5] = ... ;</i> /* point to pfield 5 of event 4 and do something with its contents */</font></p>			</dir>		</dir>		<p><font face="Times New Roman">The first address is the start of the list of all the events, the address where 'a' begins in memory because <i>a = lget()</i>. The address of a variable (which might itself be a pointer) is coded in C with an ampersand, thus: &amp;a gives the address of the variable a &#151; in this case the EVLIST structure.</font></p>		<p><font face="Times New Roman">Having established where the list of events begins, we then move down the list to the fourth event. The pointers to each of the events are contained in one of the fields of the event list structure, so we ask for the fourth member of this structure: thus, <i>&amp;a-&gt;e[4]</i>; we set our pointer <i>f</i> to this: <i>f = &amp;a-&gt;e[4]</i>.</font></p>		<p><font face="Times New Roman">We now want to point to one of the fields of this fourth event; this is where the second asterisk comes in, because we want to point <i>beyond the address</i> of the fourth event <i>to the contents</i> of its fifth pfield.</font></p>		<p><font face="Times New Roman">The code for this is <i>(*f)-&gt;p[5]</i>; the parentheses make sure that the dereferencing to the address we want takes place before anything else.</font></p>		<p><font face="Times New Roman">The following chart provides a visual outline of the structures containing the list of events and the events themselves, with 'bits of C-code' lined up against the various appropriate parts of this overall picture.</font></p>		<dir>			<dir><font face="Courier New">EVLIST<br>				a --------&gt; nslots (number of events created)<br>				nevents (number of events used)<br>				e[1]addr<br>				e[2]addr<br>				e[3]addr EVENT<br>				e[4]addr---------------&gt;pcnt (number of pfields)<br>				e[5]addr p[0] (used for op code)<br>				etc. p[1] (instr number)<br>				p[2] (start time)<br>				p[3] (duration of event)<br>				p[4] (amplitude)<br>				p[5] (pitch)<br>				etc. (whatever...)</font>			</dir>		</dir>		<h3><font face="Times New Roman"><b>Declarations:</b></font></h3>		<dir>			<dir><font face="Courier New"><i>EVLIST *a, *b;</i></font><font face="Courier New"> /* <b>a</b> and <b>b</b> are declared as pointers to EVLIST */</font>				<p><font face="Courier New"><i>EVENT *e; </i>/* <b>e</b> is declared as a pointer to EVENT */</font></p>				<p><font face="Courier New"><i>EVENT **f;</i> /* <b>f</b> is declared as a pointer to a pointer to EVENT &#151; this means in practice that it will first point to EVLIST */</font></p>			</dir>		</dir>		<h3><font face="Times New Roman"><b>Creating the Structures and Assigning Them to the Declared Variable:</b></font></h3>		<dir>			<dir><font face="Courier New"><i>a = lcreat(n);</i></font><font face="Courier New"> /* <b>n</b> is the size, the number of events in the list */</font>				<p><font face="Courier New"><i>a = lget();</i> /* read events from <i>inscore</i>; automatically creates the event list structure, and '<b>a</b>' points to it */</font></p>				<p><font face="Courier New"><i>e = createv(n);</i> /* create an event with n pfields; '<b>e</b>' points to it */</font></p>			</dir>		</dir>		<h3><font face="Times New Roman"><b>Looking Directly at Members of EVLIST</b></font><b><font face="Courier New">:</font></b></h3>		<dir>			<dir><font face="Courier New"><i>count = a-&gt;nevents;</i></font><font face="Courier New"> /* <i>count</i> now equals the number of events in the list */</font>				<p><font face="Courier New"><i>f = &amp;a-&gt;e[1];</i> /* the value of '<b>f</b>' is now the address of e[1]; f is declared as a pointer */</font></p>			</dir>		</dir>		<h3><font face="Times New Roman"><b>Looking Directly at Members of EVENT:</b></font></h3>		<dir>			<dir><font face="Courier New"><i>e-&gt;op = 'i';</i></font><font face="Courier New"> /* access e[0] and set to the letter 'i' */</font>				<p><font face="Courier New"><i>e-&gt;p[1] = 1; </i>/* access first pfield and set to 1 (instrument 1) */</font></p>			</dir>		</dir>		<h3><font face="Times New Roman"><b>Accessing Members of an EVENT via EVLIST List of Events:</b></font></h3>		<dir>			<dir><font face="Times New Roman">1) declare a pointer to a pointer: <i>EVENT **f;</i></font>				<p><font face="Times New Roman">2) set <b>f</b> to point to the address in EVLIST where the first event begins: <i>f = &amp;a-&gt;e[1] </i>&#151; note the use of the ampersand here; the reason is that it is the 'address contained in 'a' and not just 'a' itself.</font></p>				<p><font face="Times New Roman">3) now access the <i>contents</i> of the 5th pfield of event 1: (*f)-&gt;p[5] as in <i>(*f)-&gt;p[5] *= 0.5</i> i.e., multiply the pitch contained in p[5] by 0.5, thereby transposing it down an octave; or, as in <i>temp = (*f)-&gt;p[5]</i> i.e., set <i>temp</i> equal to the pitch value in p[5]; here the <b>*f</b> indicates that we are looking at the <i>contents</i> of p[5], <i>not the address</i> at which this data is located. &#151; Note that the code (<i>f++</i>), when used, moves on <i>not to the next pfield but to the next event</i>, i.e., the address of the next event: <i>&amp;a-&gt;e[2]</i> after carrying out the '+= value' operation.</font></p>			</dir>		</dir>		<h3><font face="Times New Roman"><b>Calling a Function</b></font></h3>		<p><font face="Times New Roman">The other key lines of code in <i>cs6chnge.c</i> differ from the <i>Csound</i> Manual version by calling a separate function in which the value is actually changed. The new value is then returned to the calling environment (in this case <i>main()</i>). This procedure is done here in a step-by-step manner, to make the first look at this as clear as possible. A more concise alternative is also shown, and then used in the next program. These lines of code are:</font></p>		<dir>			<dir><font face="Courier New"><i>pchval = (*f)-&gt;p[5];</i></font><font face="Courier New"> this sets the value of <i>pchval</i> equal to the contents of p[5]</font>				<p><font face="Courier New"><i>pchval = newpch(pchval, transp_ratio);</i> now we pass the contents of p[5] along with the user's pitch scaling factor <i>transp_ratio</i> to the function <i>newpch()</i>; at the same time, <i>pchval</i> is going to be changed to the value returned from <i>newpch(</i>).</font></p>				<p><font face="Courier New"><i>(*f)-&gt;p[5] = pchval;</i> the contents of p[5] is now updated to the new value</font></p>			</dir>		</dir>		<p><font face="Times New Roman">The one-step code for doing this is:</font></p>		<dir>			<dir><font face="Courier New"><i>(*f)-&gt;p[5] = newpch((*f)-&gt;p[5], transp_ratio);</i></font><font face="Courier New"> this can be described in pseudo code as: let the contents of p[5] take on the new value returned from <i>newpch()</i>, to which we pass its current value and the user's scaling factor.</font>			</dir>		</dir>		<p><font face="Times New Roman">The function <i>newpch()</i> is defined below, and could include a couple of diagnostic lines to confirm to the user that it has received the current value for p[5] accurately and to inform the user what the new value will be. In this case the operation is very simple (the pitch value is multiplied by the scaling factor), but the idea is that this function could be arbitrarily complex, call other functions etc. The result is then fed back into p[5] and written to the output scorefile.</font></p>		<p><font face="Times New Roman">The next program does exactly the same thing, except that it is now working with all the events. Thus the whole column of numbers &#151; which forms a pfield for a block of note events &#151; can be shaped by the action of the function which is called.</font></p>		<h3><font face="Times New Roman"><b>CS7DELAY.C &#151; Delay / Stagger the Time Entry of Note Events</b></font></h3>		<p><font face="Times New Roman">(Original came with <i>Csound</i> distribution). The structure of the score produced by this program is distinguished by its use of section markers. The following box outlines the structure of the program, which provides a model for a number of basic operations:</font></p>		<dir>			<dir><font face="Courier New">create an f-statement and write to <i>outscore</i>: <i>e = createv(5); e-&gt;op = 'f';</i> etc.<br>				s<br>				read <i>inscore</i> &amp; write out again to <i>outscore</i>: <i>a = lget();</i> etc.<br>				s<br>				write out (sorted) <i>inscore</i> again to <i>outscore</i>: <i>lsort(a); lput(a);</i> etc.<br>				s<br>				make copy b: <i>b = lcopyev(a);</i> etc.<br>				change copy b<br>				join copy b to original list (join b to a): <i>a = lcat(a,b)</i><br>				sort the whole score: <i>lsort(a);</i><br>				write out to <i>outscore</i>: <i>lput(a);</i> etc.<br>				s<br>				put f-statement into event 0: <i>e = defev(&quot;f 2 0 512 10 5 6 &quot;);</i> etc.<br>				e</font>			</dir>		</dir>		<p><font face="Times New Roman">First it creates an f-statement event with five pfields. These pfields are then filled one by one, the 'f' designating it to be a function statement. While we have previously seen function statements created with <i>defev(&quot;...&quot;)</i>, the method used in this program shows that the same mechanism we described for instrument events can also be used to create function statements. The implication is that loops can be used to create several function statements, each with varying data components (see CS14PTLS). A section marker terminates this part of the score.</font></p>		<p><font face="Times New Roman">Then the program reads in from the <i>inscore</i>. An important fact comes to light here, namely that <b>reading the input score stops automatically at a section marker</b>. In this way, the reading of portions of input score can be precisely controlled. But the user must add his or her own section marker in the program. <i>lsort()</i> is used to sort what has been read into time order before writing it to the score. A section marker terminates this part of the score.</font></p>		<p><font face="Times New Roman">Now a copy (b) of this list is made and the start times altered. Here the <i>Cscore</i> program is being used to introduce a time delay to the start times of each event in the score, simply by adding 2 to each p[2] pfield. Note that the effect is not cumulative as was the diminuendo in previous programs &#151; all events simply start a fixed 2 seconds later than they would have. After concatenating this altered copy with the original list 'a', <i>lsort()</i> is used again to place all the events into time order; this could result in interleaving the two lists in some way. A section marker terminates this part of the score.</font></p>		<p><font face="Times New Roman">Lastly, a second function statement is created, using <i>defev()</i>. Note how event zero is made: <i>a = lcreat(0)</i>, so that when the new function event is appended to the list, it slots in at the head of the list of events (but after the first function statement). The <i>outscore</i> is concluded with an &quot;e&quot;.</font></p>		<h3><font face="Times New Roman"><b>CS8TRANS.C &#151; Copy a Block and Call a Function to Change One Pfield in <i>all</i> the 'i' Events</b></font></h3>		<p><font face="Times New Roman">(See CDP <i>Csound</i> Manual, p.88.). The entire list of events can be considered to be a 'block' of events. The program code therefore includes a FOR loop to access each event in turn, calling <i>newpch()</i> each time to affect the change to the pfield value passed to it.</font></p>		<p><font face="Times New Roman">Part of the strategy in doing so is <i>first to isolate the note events</i>, i.e., separate out this block of note events from the other lines of code. This is done with the <i>cscore.lib</i> function <i>lsepf()</i>, as achieved by the following lines of code:</font></p>		<dir>			<dir><font face="Courier New"><i>a = lget();</i></font><font face="Courier New"> read in <i>inscore.sc</i> as named on the user's command line</font>				<p><font face="Courier New"><i>b = lsepf(a)</i>; separate out the <i>f</i> statements, assigning them to the pointer to EVLIST b</font></p>				<p><font face="Courier New"><i>lput(b);</i> write these <i>f</i> statements to the score, and</font></p>				<p><font face="Courier New"><i>lrelev(b);</i> release the memory space they occupied.</font></p>			</dir>		</dir>		<p><font face="Times New Roman">An existing score file is read in and the <i>f </i>statements are separated out, written to the output score and their space released: this action produces two results: 1) the <i>f</i> statements are now safely in the output score file, and 2) they are no longer in 'EVLIST a': <b>'a' now consists of the note events only</b>. Thus it can be called and handled as a block of note events without having to worry about statements which are not note events. Furthermore, both versions of the block are present in the final score so that the changed block can be compared with the original.</font></p>		<p><font face="Times New Roman">After creating a tempo statement, 'EVLIST a' (the remaining block of 'i' events) is written to the output score with <i>lput(a)</i>. This is followed by an end-of-section marker so the start times for the next block can begin again at zero. The tempo statement is repeated to provide a tempo for the next section.</font></p>		<p><font face="Times New Roman">Now a copy of 'EVLIST a' is made with the code: <i>b = lcopyev(a)</i>. The important consideration here is that this copy is going to remain the same, the original event list 'a' altered, and then 'a' (changed) joined to 'b' (unchanged) with the code: <i>a = lcat(b,a);</i> &#151; now both blocks have been concatenated to form the list identified as 'a'. This list is written to the output score, which therefore contains:</font></p>		<dir>			<dir><font face="Courier New">the f statements</font>				<p><font face="Courier New">a tempo statement</font></p>				<p><font face="Courier New">the i statements of the original score</font></p>				<p><font face="Courier New">end-of-section marker</font></p>				<p><font face="Courier New">a second tempo statement</font></p>				<p><font face="Courier New">a copy of the i statements of the original score</font></p>				<p><font face="Courier New">the altered block of events</font></p>				<p><font face="Courier New">an end-of-score marker</font></p>			</dir>		</dir>		<p><font face="Times New Roman">Because the form of the list concatenation is <i>a = lcat(destination, source)</i>, one has to remember that everything has to end up as list 'a'. Thus if some of the original material is to stay the same, it needs to be copied and, as it were, put to one side before the original data is altered. Pseudo-code for <i>a = lcat(b,a);</i> would be: the complete list 'a' is made up of the unchanged 'b' list to which the changed 'a' list has been added.</font></p>		<p><font face="Times New Roman">With <i>f</i> reset to point to the first event (<i>f = a&#151;&gt;e[1]</i>), a FOR loop is now invoked to go through the list of events, calling <i>newpch()</i> each time to change the p[5] values of all the 'a' block events. The user's scaling factor input on the command line was declared as a variable in main(). (See INTRATIO or MUSUNIT for conversions between intervals and ratios). It is passed to <i>newpch()</i> and used in the calculation of the new value:</font></p>		<dir>			<dir><font face="Courier New"><i>for(i=0; i&lt;=n; i++) {</i></font><font face="Courier New"><br>				<i>(*f)-&gt;p[5] = newpch((*f)-&gt;p[5], transp_ratio); </i>/* see above for explanation of this line! */<br>				<i>f++; </i>/* move (i.e., point) to next event */<br>				<i>}</i></font>			</dir>		</dir>		<p><font face="Times New Roman">The processing function <i>newpch()</i> is pretty simple:</font></p>		<dir>			<dir><font face="Courier New">double<br>				newpch(pch, tr_val)<br>				double pch<br>				double tr_val</font>				<p><font face="Courier New">{<br>				pch *= tr_val; /* multiply the original pitch value by the transposition ratio, write */<br>				return(pch); /* the result back to 'pch' and return this value to <i>main()</i> */<br>				}</font></p>			</dir>		</dir>		<p><font face="Times New Roman">CS10ALTR expands these procedures a little further by treating each pfield independently.</font></p>		<h3><font face="Times New Roman"><b>CS9SWITC.C &#151; Switch Between Two Sections in Two Different Scores</b></font></h3>		<p><font face="Times New Roman">This program introduces the <i>setcurfp()</i> and <i>filopen()</i> functions. The first of these means 'set current file pointer', i.e., set the file pointer to the current file. The second, <i>filopen()</i> enables the user to name another score file which he or she would like to access. Thus:</font></p>		<dir>			<dir><font face="Courier New"><i>fp1 = getcurfp();</i></font>				<p><font face="Courier New"><i>fp2 = filopen(&quot;score2.srt&quot;);</i></font></p>			</dir>		</dir>		<p><font face="Times New Roman">The process of reading up to and not beyond section markers as illustrated in CS7DELAY is used to read in portions of each score, the file pointers being used to switch between files.</font>	</body></html>