<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>An Annotated Set of Cscore Examples</title>	</head>	<body bgcolor="white">		<div align="left">			<h1><font face="Times New Roman">An Annotated Set of Cscore Examples</font></h1>			<h2><font face="Times New Roman"><b>Source Code for All Examples (ascii text files):</b></font></h2>			<p><font face="Times New Roman">For Section 5A &#151; The Basics</font></p>			<p><font face="Times New Roman"><b>cs1write.c</b> outline the core ingredients of a <i>Cscore</i> program<br>			<b>cs2oneev.c </b>create a score with only one event<br>			<b>cs3evlst.c c</b>reate list of events with command line parameter input<br>			<b>cs4scale.c </b>create a rising quarter-tone scale in a FOR loop<br>			<b>cs5read.c </b>read in a pre-existing scorefile<br>			<b>For Section 5B &#151; Make Changes to Score Data</b><br>			<b>cs6chnge.c </b>copy block &amp; call function to<b> </b>change 1 parameter in 1 event<br>			<b>cs7delay.c </b>delay / stagger the time entry of note events<br>			<b>cs8trans.c </b>copy block &amp; call function to change one pfield in <i>all</i> events<br>			<b>cs9switc.c </b>switch between two sections in two different score files<br>			<b>For Section 5C &#151; Towards some musical applications</b><br>			<a href="cs10altr.html"><b>cs10altr.c</b></a> use functions to alter several pfields, with command line input<br>			<a href="cs11cue.html"><b>cs11cue.c</b></a> create n event-blocks at specified time cues, with cresc/dim<br>			<a href="cs12chrd.html"><b>cs12chrd.c</b></a> explore pitch/sound continuum with Fibonacci-based chords<br>			<a href="cs13text.html"><b>cs13text.c</b></a> create a sound texture, with user inputs &amp; processing options<br>			<a href="cs14ptls.html"><b>cs14ptls.c</b></a><b> </b>create smooth changes of partials content during a single tone</font></p>			<h2>			<h3><font face="Times New Roman"><b>Introductory Notes for the Programs in Section 5C</b></font></h3>			</h2>			<h3><font face="Times New Roman"><b>Sextion 5C &#151; Some Specific Musical Applications</b></font></h3>			<h3><font face="Times New Roman"><b>Introductory Notes to the Programs</b></font></h3>		</div>		<p><font face="Times New Roman"><b>CS10ALTR.C &#151; Use Functions to Alter Several pfields, With Command Line Input</b></font></p>		<div align="justify">			<p><font face="Times New Roman">(See CDP <i>Csound</i> Manual, p.89). The user inputs four values on the command line, one for each pfield to be affected, and four different functions are called, one for each pfield. Thus each algorithm is tailored to the requirements of each pfield individually. The FOR loop where these four functions are called looks like this:</font></p>			<dir>				<dir>					<p><font face="Courier New">for(i=0; i&lt;=n-1; i++) {<br>					(*f)&#151;&gt;p[2] = newstt((*f)&#151;&gt;p[2], start); /* alter start time of event 1*/<br>					(*f)&#151;&gt;p[3] = newdur((*f)&#151;&gt;p[3], dur); /* alter duration of event 1*/<br>					(*f)&#151;&gt;p[4] = newamp((*f)&#151;&gt;p[4], amp); /* alter amplitude of event 1*/<br>					(*f)&#151;&gt;p[5] = newpch((*f)&#151;&gt;p[5], freqf); /* alter pitch of event 1*/<br>					f++; /* move on to next event */<br>					}</font></p>				</dir>			</dir>			<p><font face="Times New Roman">The FOR loop is set to terminate when <i>i&lt;=n-1</i> because the <i>n</i> count begins at 1 and the FOR loop count begins at 0.</font></p>			<p><font face="Times New Roman">Now we are beginning to see the power of the <i>Cscore</i> environment. Blocks of events can be copied and treated differently in each section of the score. User inputs can change the results with every run of the program, providing a useful experimental working method. Each pfield can be massaged with an algorithmic function of arbitrary complexity. It's starting to look good!</font></p>			<p><font face="Times New Roman">If one is going to think about this environment as an 'algorithmic mix window', the start time and duration pfields are of key importance. The blocks of events can all have the same time, thus forming chords; they can overlap by starting before the next event is finished, or can come after silences by beginning after the previous event has finished, thereby controlling the horizontal density of the resulting texture: the pitch pfield controls its vertical density. In the next program we examine a higher-level mechanism for handling blocks of events by means of timing cues.</font></p>		</div>		<h3><font face="Times New Roman"><b>S11CUE.C &#151; Create n Event-blocks at Specified Time Cues, with Cresc/Dim</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">(See CDP <i>Csound</i> Manual, p. 90.) The power of <i>Cscore</i> begins to be unveiled in this program supplied in the <i>Csound</i> manual. It builds on the two previous ones, but begins to do something different when the line of code <i>holdn = n</i> stores a counter value and a new counter is initialised with <i>i = 0</i>.</font></p>			<p><font face="Times New Roman">A look at an outline of the (adapted) score produced by this program will help us to understand how it is coded.</font></p>			<dir>				<dir>					<p><font face="Courier New">original block for comparison (I've commented out the code which does this)</font></p>					<p><font face="Courier New">diagnostic: event block 1, time cue=...</font></p>					<p><font face="Courier New">i1 ... (series of i-statements)</font></p>					<p><font face="Courier New">diagnostic: event block 2, time cue=...</font></p>					<p><font face="Courier New">i1 ... (series of i-statements)</font></p>					<p><font face="Courier New">diagnostic: event block 3, time cue=...</font></p>					<p><font face="Courier New">i1 ... (series of i-statements)</font></p>				</dir>			</dir>			<p><font face="Times New Roman">A double loop structure is created in which the purpose of the OUTER loop is to cause the processing to go back to the beginning of the list: <i>f = &amp;a-&gt;e[1]</i>. Note that the counter for the INNER loop is reset to the full number of events before processing the second block. This is what the extra copy of n (<i>holdn</i>) is for: it stays the same and is used to reset the counter. Then the inner loop moves through each of the events, altering their amplitude. When this inner loop comes to the end of the list, note that the counter for the outer loop is incremented; the outer loop ceases when this counter reaches 2, i.e., which is the third iteration, because the count began at 0.</font></p>			<p><font face="Times New Roman">The outer loop counter could be made to repeat the loop any number of times, thus creating n number of blocks, and the inner loop counter is set to the number of events in the list, so that each block contains versions of all the events. The double loop structure does not of course have to be used to create time cues. <i>The re-timed blocks occur with this program only because the cues are used to alter p2.</i> My program allocates memory dynamically as it reads the file of cues; be careful lest this code is machine-specific.</font></p>		</div>		<h3><font face="Times New Roman"><b>CS12CHRD.C &#151; Explore Pitch/Sound Continuum with Fibonacci-based Chords</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">CS12CHRD takes advantage of <i>Csound's</i> ability to specify precise frequencies. The algorithm builds chords of user-definable density in which the frequency relationships are defined by the Fibonacci series. The interesting part of the algorithm concerns enabling the user to specify both the size of the interval to be spanned and the 'density; of the chord, i.e., the number of frequency components.</font></p>		</div>		<h3><font face="Times New Roman"><b>CS13TEXT.C &#151; Make a Sound Texture, With User Inputs &amp; Processing Options</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">This program is used in conjunction with a specially designed <i>Csound</i> orchestra (<i>in13text.orc</i>) in order to create a sound texture which fills an enveloped shape (values increase and decrease), gets louder and softer within each block, becomes temporally denser towards the half-way point, and spreads out again from there to the end.</font></p>			<p><font face="Times New Roman">The score creates the note events and handles the temporal density/expansion by manipulating the start times.</font></p>		</div>		<h3><font face="Times New Roman"><b>CS14PTLS.C &#151; Create Smooth Changes of Partials Content During a Single Tone</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">For a long time I cherished the idea of being able to create timbrally changing tones algorithmically. This program achieves that objective to a modest degree by linking a differently specified f-statement to every note of the score. All the notes are at the same frequency and overlap (in various ways), so the different waveforms flow in and out of each other. The reference manual page goes into more detail about this and the code is fairly straightforward, so this idea can easily be developed further.</font></p>			<p><font face="Times New Roman">When working on the programs in 5B, especially CS13TEXT, it gradually became clear that there were a number of different situations to be catered for regarding the way values accumulate from event to event. This turned out to be (for me) a somewhat stretching problem in programming logic, and I did a lot of 'dry-runs' of the arithmetic before I could work out what was going on. This is typical of what begins to happen with programming once one leaves the 'basics' behind and starts to get down to something 'interesting', so I conclude these introductory observations with an account of what I learned in the process of (partially) solving this particular problem. The key factor is the nature of the <i>inscore</i>. My first versions took no account of this, which caused some rather puzzling numerical results!</font></p>			<p><font face="Times New Roman">You might want to examine the source code regarding the various situations I identified and catered for:</font></p>			<p><font face="Times New Roman">Case 1: when there is an <i>inscore</i> with identical values in the pfields for each note event, examine how the loop counter is used to accumulate values to add to the <b>same initial value</b> (see FIXED ... SAME in the code).</font></p>			<p><font face="Times New Roman">Case 2: when there is an <i>inscore</i> with differing values in the pfields, look at how the factor is applied to the <b>differing incoming values</b> (see FIXED ... DIFFERENT in the code).</font></p>			<p><font face="Times New Roman">Case 3: also consider why the LIN-SERIES operation (and presumably the other still unimplemented series operations) needs to make use of the <b>value in the previous event</b>. This comprises a 3rd case. See LIN_SERIES ... SAME in the code).</font></p>			<dir>				<dir>					<p><font face="Times New Roman"><b>The first case:</b> the 'same value' accumulates by multiplying the user's change factor by the loop counter and adding the new value to the same initial value (or identical incoming values). CS14PTLS is a variant of the 'same' case: all values are calculated from a single initial starting point without reading each event afresh from an <i>inscore</i> (with identical values for each note event).</font></p>					<p><font face="Times New Roman"><b>The second case:</b> the 'different' value in the pfield is read afresh from the <i>inscore</i> each time; the factor is added to it (or whatever) as a fixed value. The second case does not apply to CS14PTLS because everything there is generated from the single values input by the user or from defaults.</font></p>					<p><font face="Times New Roman"><b>The third case</b> (series operations): the values accumulate by using the output of the previous operation as the input to the next operation. This previous value is updated in <i>main()</i> with the 'hp2' etc. variables and passed to the functions which carry out the calculations.</font></p>				</dir>			</dir>			<p><font face="Times New Roman">The compressing of values which occurs after the half-way point of the program also varies with each case. In the first case (identical start values), the now reducing values need to be decremented from the highest value achieved in the first half of the event list. This value is held in a global variable (because it doesn't want to be passed to the calculation functions every time they are called). It is updated in <i>main()</i> and then used when the <i>_dwn()</i> functions are called during the second half of the note event list.</font></p>			<p><font face="Times New Roman">It is no longer updated during the second half and so 'holds' the peak value attained during the first half. These variables are named 'holddur' and 'holdamp'. In the second case (differing values read afresh), this incoming value is used to decrement from. In the third case (series operations), the value from the previous pfield is used.</font></p>			<p><font face="Times New Roman">The following summarises the various situations, which can be examined in the code for CS11CUE, CS13TEXT, and in part, CS14PTLS:</font></p>			<p><font face="Times New Roman">SAME start point &amp; FIXED or RAND value changes: solved by augmenting the factors with <i>counter*factor</i> and adding the result to the (same) start value.</font></p>			<p><font face="Times New Roman">SAME start point &amp; SERIES value changes: just need to add/apply the factor to each (different) incoming value.</font></p>			<p><font face="Times New Roman">DIFFERING start points &amp; FIXED or RAND value changes: solved by augmenting the factors with <i>counter*factor</i> and adding the result to the pfield value in the <i>previous</i> event.</font></p>			<p><font face="Times New Roman">DIFFERING start points &amp; SERIES value changes (solved by the same algorithm as SAME ... FIXED): solved by augmenting the factors with <i>counter*factor</i> and adding the result to the incoming value.</font></p>			<p><font face="Times New Roman">Another problem &#151; to which I haven't yet found an adequate solution &#151; is how to use a multiply operation (ratio) with frequencies in a way which caters for all of these situations. It's simple enough with a single event, but becomes tricky when trying to handle the different ways values accumulate. For example, if one multiplies the ratio by successive loop counter integers (as is done in the procedures above), the value can easily go over the top!</font></p>			<p><font face="Times New Roman">When the starting point of a value in one of the pfields is non-zero (such as amplitude in the 'different' cases), you may want it to remain as it is for the first event, i.e., unaffected by the change factor. The code <i>if(counter == 0) factor = 0;</i> could be used to keep it the same if addition is involved, or <i>if(counter == 0) factor = 1</i> if multiplication is involved.</font></p>			<p><font face="Times New Roman">No doubt much more is involved here and the solution could be much more elegant. As a musician and not much of a programmer, I have tried to provide an approachable starting point for using <i>Cscore</i> as an environment in which to work out one's own ideas, thus moving us a step further towards the goal of an open-ended CDP System.</font></p>		</div>		<div align="left">			<h2>			<h3><font face="Times New Roman"><b>Reference manual pages for each of the programs in Section 5C</b></font></h3>			</h2>		</div>		<h3><font face="Times New Roman"><b>CS10ALTR &#151; Use Functions to Alter Several pfields, With Commandline Input</b></font></h3>		<p><font face="Times New Roman"><b>Usage:</b></font></p>		<dir>			<dir>				<p><b><font face="Courier New">cs10altr -s</font></b><font face="Courier New"><i>startf </i><b>-d</b><i>durf </i><b>-a</b><i>ampf </i><b>-f</b><i>freqf inscore.sc outscore.sc</i></font></p>				<div align="justify">					<dir>						<p><font face="Courier New"><b>-s</b><i>startf</i> start_time scaling ratio (double) (*: 0.0-&gt;)</font></p>						<p><font face="Courier New"><b>-d</b><i>durf</i> duration scaling ratio (double) (*: &gt;0.0)</font></p>						<p><font face="Courier New"><b>-a</b><i>ampf</i> amplitude scaling factor (int) (+: 0-&gt;x000)</font></p>						<p><font face="Courier New"><b>-f</b><i>freqf</i> frequency scaling ratio (double) (*: &gt;0.0)</font></p>						<p><font face="Courier New">When multiplying, vals &lt; 1 compress, &gt; 1 expand</font></p>						<p><font face="Courier New">NB1: values &lt;1 * scaling ratios &lt;1 become very small!</font></p>						<p><font face="Courier New">NB2: if <i>startf</i> = 0, a simultaneity will result</font></p>						<p><font face="Courier New"><i>inscore.sc</i> assumed to have different values for each event, but identical <i>inscore</i> values in a parameter field will also all be the same in the <i>outscore</i>, though rescaled.</font></p>						<p><font face="Courier New"><i>outscore.sc</i> altered Csound scorefile produced by the program</font></p>					</dir>				</dir>			</dir></div>		<h3><font face="Times New Roman"><b>Description</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">Start_time, duration, amplitude and frequency are the four parameter fields of the input scorefile altered by a simple algorithmic function. The user enters the scaling factor on the command line, and can easily produce a variety of output scores, viewing them to check the results before going on to produce a soundfile.</font></p>			<p><font face="Times New Roman">Start time, duration, and frequency are all calculated by applying the same formula 'new_value *= scaling_ratio': i.e., the new value = the current value * the scaling factor. The current value is passed to the function and multiplied by the scaling factor, thereby becoming the new value. Amplitude uses an integer factor and += .</font></p>			<p><font face="Courier New">EXAMPLE: ('nv' = new_value, 'cv' = current_value, 'sf' = scaling_factor)</font></p>			<p><font face="Courier New">IN_DUR_VALUE CALCULATION OUT_DUR_VALUE</font></p>			<p><font face="Courier New"><b>nv = cv * sf</b></font></p>			<p><font face="Courier New">0 0 = 0 * 1.2 0</font></p>			<p><font face="Courier New">1 1.2 = 1 * 1.2 1.2</font></p>			<p><font face="Courier New">2.5 3 = 2.5 * 1.2 3</font></p>			<p><font face="Times New Roman">The code for one of these functions looks like this:</font></p>			<dir>				<dir>					<p><font face="Courier New">double<br>					newdur(du, df)<br>					double du; /* duration variable as in pfield 3 */<br>					double df; /* duration factor input on command line */<br>					{<br>					du *= df; /* duration scaled by user's factor */<br>					fprintf(stderr, &quot;diagnostic, newst(): new duration = %.3f\n&quot;, du);<br>					return (du);<br>					}</font></p>				</dir>			</dir></div>		<h3><font face="Times New Roman"><b>Using the Program</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">As the usage reminds us, the program requires an input file assumed to have different values for each of the events. Any values which are the same from one event to the next will remain equal, though rescaled. In other words, a fixed change is applied throughout. It would take a further development of the code to start with the same values and accumulate the results from one event to the next. This is a 'series' operation and is applied in some of the programs which follow.</font></p>			<p><font face="Times New Roman">Because the scaling factor is applied by a multiplication operation, the user should be careful with scaling ratios less than zero. When applied for example to start times or durations which are also less than zero, rather small numbers can easily result. E.g., 0.2 * 0.7 = 0.14. This will have the effect of moving events closer to the start of the output soundfile, or of producing very short events.</font></p>			<p><font face="Times New Roman">On the other hand, because multiplication is involved, values greater than 1 easily 'blow up': become excessively large. Multiplication is in fact a dangerous operation in this context, though appropriate for frequency. The following programs in this set of examples for <i>Cscore</i> try out different algorithms, with a greater role for addition.</font></p>			<p><font face="Times New Roman">The simple beginning represented by this program could be developed further; for example, by:</font></p>			<dir>				<dir>					<p><font face="Times New Roman">&#183; offering the option to add or multiply the (fixed) scaling factors</font></p>					<p><font face="Times New Roman">&#183; designing more complex &amp; different functions for each parameter, e.g.,:</font></p>					<p><font face="Times New Roman">- use a series function such as linear, exponential or logarithmic (values accumulate)</font></p>					<p><font face="Times New Roman">- employ a random function with user-defined ranges for duration</font></p>					<p><font face="Times New Roman">- add duration to previous start time so as to avoid overlaps</font></p>					<p><font face="Times New Roman">- progressively decrease the values again e.g., after the half-way point</font></p>				</dir>			</dir>			<p><font face="Times New Roman">Some of these ideas are developed a bit further in the subsequent programs.</font></p>		</div>		<h3><font face="Times New Roman"><b>CS11CUE - Create n Event Blocks at Specified Time Cues, With Cresc/Dim</b></font></h3>		<p><font face="Times New Roman"><b>Usage</b></font></p>		<dir>			<dir>				<p><b><font face="Courier New">cs11cue</font></b><font face="Courier New"><i> </i><b>-n</b><i>numcues</i><b> -a</b><i>ampfactor </i>[<b>-m</b><i>multiplier</i>] <b>-t</b><i>processtype</i> [<b>-r</b><i>range</i>]<i> </i><b>-i</b><i>scoretype cuefile inscore.sc outscore.sc</i></font></p>				<div align="justify">					<dir>						<p><font face="Courier New"><b>-n</b><i>numcues</i> (int) number of time cues in <i>cuefile</i> (this will also be the number of event-blocks formed)</font></p>						<p><font face="Courier New"><b>-a</b><i>ampfactor</i> (int) amplitude change factor (+: 0-&gt;x000)</font></p>						<p><font face="Courier New"><b>-m</b><i>multiplier</i> (double) amplitude scaling ratio used with type 1 (*: &gt;0)</font></p>						<p><font face="Courier New"><b>-t</b><i>processtype</i> (int) <i>processtype</i> is type of algorithm with which to process the score values</font></p>					</dir>					<p><font face="Courier New">0: ADD fixed value</font></p>					<p><font face="Courier New">1: MULTIPLY by time cue value &amp; multiplier</font></p>					<p><font face="Courier New">2: RANDOM the formula used is: randval(0-1) * timecue * range</font></p>					<dir>						<p><font face="Courier New"><b>-r</b><i>range</i> (int) type 2: numerical range for random function (Default = 1)</font></p>					</dir>				</dir>			</dir></div>		<center>			<p><font face="Courier New">NB: For *= processes, 1st time cue must be &gt; 0 or all calculations will result in 0!</font></p>			<p><font face="Courier New">WARNING: Start times can be excessively high if both start time &amp; range are rather large.</font></p>		</center>		<div align="justify">			<dir>				<dir>					<dir>						<p><font face="Courier New"><b>-i</b><i>scoretype</i> (int) type of input scorefile:</font></p>					</dir>					<p><font face="Courier New">0: SAME</font></p>					<p><font face="Courier New">1: DIFFERENT</font></p>					<dir>						<p><font face="Courier New"><i>cuefile</i> input text file of cue times</font></p>						<p><font face="Courier New"><i>inscore.sc</i> input Csound score file</font></p>						<p><font face="Courier New"><i>outscore.sc</i> Csound score file produced by the program</font></p>					</dir>				</dir>			</dir></div>		<h3><font face="Times New Roman"><b>Description</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">This program operates a little like a mix window. The <i>Csound</i> scorefile mechanism is itself a kind of mix window because start times are set and events can be overlapped. Here, it is not just a question of start times for single events, but start times for groups of events. These can be simultaneities or events in groups with different, possibly overlapping timings.</font></p>			<p><font face="Times New Roman">It could therefore be useful to think of the event groups as 'blocks': the time cues affect the start time of each block &#151; and consequently all the events within each block. The first block consists of the events of the original score. One or more copies of this first set of events are made, and they repeat starting at the next time cue: i.e., this time in seconds is added to all the start times of the events in the previous block.</font></p>			<p><font face="Times New Roman">Some variation in the blocks is made possible by the additional parameter to adjust amplitude. The processing which this program allows is minimal, given as a hint of what might be done. Extending processing to duration and frequency would be a natural path of development for the program.</font></p>			<p><font face="Times New Roman">In effect, this is a sound copy program with two main features:</font></p>			<dir>				<dir>					<p><font face="Times New Roman">1) the copying is carried out within the context of what is really a 'mix' window (nothing prevents the copies from overlapping).</font></p>					<p><font face="Times New Roman">2) the copies can be altered algorithmically &#151; within a <i>Cscore</i> programming environment, eventually in whatever way and to whatever degree the user wishes and is capable of programming.</font></p>				</dir>			</dir></div>		<h3><font face="Times New Roman"><b>Using the Program</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">The program as it stands cannot automatically count the number of cues as it reads them in (it can when it copies them). The <i>numcues</i> variable is therefore input by the user, and is used as the outer loop counter upper limit. Thus each time cue creates a new 'block' of events: the number of blocks of events is the number of time cues in <i>cuefile</i>.</font></p>			<p><font face="Times New Roman">The <i>inscore</i> can be a template with identical values in each parameter field (e.g. all start times = 0, all durations = 1, all amplitudes = 15000, and all frequencies = 200). (Frequency is not processed in this version of the program, so all the blocks will be at the same pitch.) This is <i>inscore</i> type 0. Alternatively, the <i>inscore</i> can be a 'real' scorefile with different values for each event: type 1. The two types of scores require different processing algorithms, because the arithmetic is slightly different when adding the values always to the same initial value to create each subsequent event, or when adding to differing values for each note event of the <i>inscore</i>.</font></p>			<p><font face="Times New Roman">All of the processing in this program is based on addition and there are two alternative algorithms for each process, depending on the type of <i>inscore</i>: SAME or DIFFERENT. How the loop counter is used to bring about the accumulation of the values for <i>inscore</i> type 0 should be fairly clear in the code: it is the user's change factor which is accumulated.</font></p>			<p><font face="Times New Roman">The new start times are added to the previous times throughout, but the amplitude decreases after the half-way point of each block of events. Differing versions of the program could be made to create differing amplitude change shapes: increasing throughout, decreasing throughout, changing randomly, logarithmically, exponentially etc.</font></p>			<p><font face="Times New Roman">A generic problem: when it comes time to decrement, the SAME type situation needs to hold the highest value attained so far and decrement from there. Otherwise, one decrements from the initial value and the values usually go below zero. This version of the program doesn't check for this kind of eventuality &#151; it would be better if it did, or at least report the fact to the user. The following goes through the processing options with specific reference to start times.</font></p>			<dir>				<dir>					<p><font face="Times New Roman">0 ADD: the time cue value is added to the previous start time, and the amplitude factor is added to the previous amplitude until the halfway point of the block, then it is subtracted from the highest value attained in the first half.</font></p>					<p><font face="Times New Roman">1 MULTIPLY: the previous start time is multiplied by the time cue value</font></p>					<p><font face="Times New Roman">2 RANDOM: a random value(0-1) * time cue * range is added to the previous start time</font></p>				</dir>			</dir>			<p><font face="Times New Roman">Note that the effects are cumulative between blocks as well: start times are added to the start time of event 1 of the previous block. Similarly with volume. Start times and volume are the only two parameters which are affected as the program currently stands. The volume crescendos and decrescendos within each block in <i>ampfactor</i> steps, changing at the half-way point. The size of the steps is set from the command line input.</font></p>			<p><font face="Times New Roman">My own next step is to combine this program with CS13TEXT(URE) to make a powerful block/texture generator, extend the processing options etc. The possiblities are really very exciting!</font></p>		</div>		<h3><font face="Times New Roman"><b>CS12CHRD &#151; Explore Pitch/Sound Continuum with Fibonacci-based Chords</b></font></h3>		<h3><font face="Times New Roman"><b>Usage</b></font></h3>		<dir>			<dir>				<p><b><font face="Courier New">cs12chrd</font></b><font face="Courier New"><i> </i><b>-s</b><i>startser </i><b>-v</b><i>nextval </i><b>-f</b><i>freq </i><b>-i</b><i>interval </i><b>-n</b><i>numterms outscore.sc</i></font></p>				<div align="justify">					<dir>						<p><font face="Courier New"><b>-s</b><i>startser</i> (double) first term of the series (&gt; 0.0)</font></p>						<p><font face="Courier New"><b>-v</b><i>nextval</i> (double) second term of the series (&gt; <i>startser</i>)</font></p>						<p><font face="Courier New"><b>-f</b><i>freq</i> (double) root or central frequency in Hz</font></p>						<p><font face="Courier New"><b>-i</b><i>interval</i> (double) interval span within which to create the harmony or harmonic complex; express as a ratio</font></p>						<p><font face="Courier New"><b>-n</b><i>numterms</i> (int) number of terms in the Fibonacci series to be used to generate harmonies</font></p>						<p><font face="Courier New"><i>outscore.sc</i> Csound score file produced by the program</font></p>					</dir>				</dir>			</dir></div>		<h3><font face="Times New Roman"><b>Description</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">This program was written primarily as a way of experimenting with the sonic fuzzy area which lies between 'pitch' and 'sound' &#151; implying that at one end of the spectrum is a clearly pitched 'note' or chord, and at the other end is a timbrally rich sound, possibly with noise elements.</font></p>			<p><font face="Times New Roman">In this case, the Fibonacci series is used as a way to determine the frequencies of the tones of these new, experimental harmonies, in the expectation that its self-similar proportions will result in some level of acceptable sonority in the resultant harmonies.</font></p>			<p><font face="Times New Roman">The interval is specified by a ratio, e.g. 1.498 for a perfect fifth (see INTRATIO or MUSUNIT). Any number of tones can be placed within this interval with the <i>numterms</i> parameter. By playing with the breadth of the interval and the number of terms, one can delightfully explore the possibilities.</font></p>		</div>		<h3><font face="Times New Roman"><b>Using the Program</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">Note that the initial two terms are user-defined. This is necessary because the normal integer Fibonacci series may expand the values more rapidly than is desired (1 2 3 5 8 13 21 34 55 89 ...), especially when they are being used as multipliers! The program displays the series on the screen so it can be examined before going on to create the sound.</font></p>			<p><font face="Times New Roman">The inharmonic nature of the harmonies will create a variety of beating patterns between the sine waves. This can be increased towards richer timbres or decreased towards more 'sonorous' timbres by adjusting the line of code which defines the wave function: <i>putstr (&quot;f1 ... &quot;)</i>. It would be useful to create the values for this function in a textfile and read it into the program, thus enabling more experimentation without having to recompile.</font></p>			<p><font face="Times New Roman">A natural way to develop this program would be to be able to move between chords, e.g. with glissandi: from <b>x</b> terms within one given interval to <b>y</b> terms within another given interval. Also, frequency relationship patterns other than that of the Fibonacci series could be used, thus turning the program into a full-scale experimental harmony workshop.</font></p>			<p><font face="Times New Roman">There is some interesting information available regarding numerical relationships, vibrations, 'golden numbers', and microtonal music. For example, Charles E. H. Lucy's <i>Pitch, PI, and other Musical Paradoxes</i> ('A Practical Guide to Natural Microtonality'), which develops the ideas of English horologist John Harrison (1693-1776), who won a &pound;20,000 (!) prize for measuring longitude. Charles Lucy has developed from these ideas the Lucy scale: 'based on the only natural, irrational, and transcendental number (PI).' The <i>Csound</i> score system provides a natural environment for exploring these ideas experimentally, and CS12CHRD extended to include a 'Lucy' algorithm would be ideal for listening to the simultaneities which these numerical relationships can produce. All good stuff. The bee in my bonnet is that we need new developments in the theory of harmony to enable an extended exploration of the sonic middle ground between 'pitch' and 'sound', so that music can successfully integrate pitch structures of all types with 'sound composition'.</font></p>		</div>		<h3><font face="Times New Roman"><b>CS13TEXT &#151; Make a Sound Texture, With User Inputs &amp; Processing Options</b></font></h3>		<h3><font face="Times New Roman"><b>Usage</b></font></h3>		<dir>			<dir>				<p><b><font face="Courier New">cs13text</font></b><font face="Courier New"><i> </i><b>-s</b><i>startf </i><b>-d</b><i>durf </i><b>-a</b><i>ampf </i><b>-f</b><i>freqf </i><b>-t</b><i>type </i><b>-i</b><i>scoretype inscore.sc outscore.sc</i></font></p>				<div align="justify">					<dir>						<p><font face="Courier New"><b>-s</b><i>startf</i> (double) change factor for start times</font></p>						<p><font face="Courier New"><b>-d</b><i>dur</i> (double) change factor for durations</font></p>						<p><font face="Courier New"><b>-a</b><i>amplf</i> (int) change factor for amplitude (e.g 1000)</font></p>						<p><font face="Courier New"><b>-f</b><i>freqf</i> (double) change factor for frequency</font></p>						<p><font face="Courier New"><b>-t</b><i>type</i> (int) texture processing algorithm:</font></p>					</dir>					<p><font face="Courier New">0 FIXED change</font></p>					<p><font face="Courier New">1 RANDOM change</font></p>					<p><font face="Courier New">2 LINEAR SERIES</font></p>					<p><font face="Courier New">3 LOGARITHMIC SERIES (not implemented)</font></p>					<p><font face="Courier New">4 EXPONENTIAL SERIES (not implemented)</font></p>					<dir>						<p><font face="Courier New"><b>-i</b><i>scoretype</i> (int) type of input scorefile:</font></p>					</dir>					<p><font face="Courier New">0 SAME</font></p>					<p><font face="Courier New">1 DIFFERENT</font></p>					<dir>						<p><font face="Courier New"><i>inscore.sc</i> input scorefile, of either type</font></p>						<p><font face="Courier New"><i>outscore.sc</i> Csound scorefile produced by the program</font></p>					</dir>				</dir>			</dir></div>		<h3><font face="Times New Roman"><b>Description</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">This program builds on the parameter inputs for CS11CUE to create a more comprehensive texture generator. Because start times can be compressed or expanded, the placement of the event blocks can be made more or less dense. All value changes except start times are made to increment during the first half of the event list, and decrement in the second half. There are now several options regarding the type of mathematical operation to apply to each parameter.</font></p>			<p><font face="Times New Roman">The events are read from an <i>inscore.sc</i>, which can be a template of identical values in each pfield, or contain differing values, as described above in the notes for CS11CUE.</font></p>			<p><font face="Times New Roman">The processing options are the same as those in CS11CUE (based on addition), whereas those of CS10ALTR are based on multiplication. I actually think it's better for frequency to be handled by a multiplying ratio and will adapt the program accordingly for my own use. (If I do everything I think of before publishing this <i>Introduction</i>, it will never go out!).</font></p>		</div>		<h3><font face="Times New Roman"><b>Using the Program</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">A little time spent simply imagining results would not go amiss. If the <i>inscore</i> is a <b>same-value</b> template, then one is beginning from scratch, building up start time, duration, amplitude and frequency relationships according to the processing option selected. (A nice task in programming logic would be to enable the user to select different processing options for every parameter!).</font></p>			<p><font face="Times New Roman">Start times always expand, the new time added to the previous one. The actual start time itself is adjusted. This is not as ideal as it might be, because there is no way to apply the function to decrease (compress) the values without having the start times begin to fold back into the previous times. It would be better to be able to adjust the timegaps between events, as Trevor does with MIXSHUFL. This is a programming task I haven't come to grips with yet. An interim solution would be to use MIXSHUFL on a copy of the score file and then extract the start time column with GETCOL and put it into this scorefile with PUTCOL.</font></p>			<p><font face="Times New Roman">If an <i>inscore</i> with <b>different values</b> is used, it is possible to place larger or smaller values in the duration pfield so that the durations will vary in relationship to the start times, producing a greater or lesser degree of note event overlap. Compressing durations will tend to bunch up, producing varying degrees of simultaneity towards the end of the texture.</font></p>			<p><font face="Times New Roman">Amplitude values decrease after the half-way point. It is easy to remove this from the program &#151; just call <i>amp_up()</i> again in the second half. Or, start with high amplitude values and call <i>amp_dwn()</i> both times. With the RANDOM function, amplitude changes can be minimal, or alter unpredictably in a considerably more dramatic way if a higher change factor is used.</font></p>			<p><font face="Times New Roman">The frequency change factor is <i>summed</i> with the previous frequency, so the alterations are likely to be minimal if the change factor is small. Bear in mind as a guide that the 88-key piano keyboard extends from 27.5Hz (lowest A) to 4186Hz (highest C). The pitch chart on p.21 of John R Pierce's <i>The Science of Musical Sound</i> is a useful reference. Also note that the results are likely to be rather inharmonic: e.g., a factor of 2 does not create an octave, it simply adds 2 Hz! &#151; but could be useful to create 'chorusing' effects. Similarly, 220Hz will create the octave of 110 Hz, but if added to 440Hz will be a long way short of the next octave (nor will it be one of the equally tempered intervals inbetween). Clearly, a version of the program with options to ADD or MULTIPLY is needed!</font></p>			<p><font face="Times New Roman">I think we're looking at something potentially very powerful here, especially if combined with the block time cues functionality of CS11CUE: not only textures that unfold with lots of internal changes, but blocks of events which do the same and can overlap or be separated in time. The frequency parameter could be crucial here: not only could the frequencies change within each block, but a series of blocks could be transposed according to plan &#151; and different blocks could also use different sounds.</font></p>			<p><font face="Times New Roman">Now we are very close to thinking about the resulting music in a way similar to contemplating a written page of score, but of course within an algorithmic context. This 'mix-window' concept provides a more intuitive link to the way (we) composers normally think about things, but the power of the computer is also being employed to create potentially new and intricate sonic results: with the C programming language to construct logical/algorithmic relationships amd <i>Cscore</i> to produce fully written out result <i>Csound</i> score files ready for synthesis.</font></p>		</div>		<h3><font face="Times New Roman"><b>CS14PTLS &#151; Create Smooth Changes of Partials Content During a Single Tone</b></font></h3>		<h3><font face="Times New Roman"><b>Usage</b></font></h3>		<dir>			<dir>				<p><b><font face="Courier New">cs14ptls -n</font></b><font face="Courier New"><i>numftables </i>[<b>-s</b><i>startfactor</i>] [<b>-d</b><i>durfactor</i>] [<b>-a</b><i>amplitude</i>] [<b>-v</b><i>ampfactor</i>] <b>-f</b><i>frequency </i>[<b>-b</b><i>risetime</i>] [<b>-e</b><i>decaytime</i>] [<b>-t</b><i>processtype</i>] <i>outscore.sc</i></font></p>				<div align="justify">					<dir>						<p><font face="Courier New"><b>-n</b><i>numftables</i> (int) number of f-statements (will be the same as the number of notes)</font></p>						<p><font face="Courier New"><b>-s</b><i>startfactor</i> (double) start time shaping factor; Default = 1: (no change)</font></p>						<p><font face="Courier New"><b>-d</b><i>durfactor</i> (double) event duration shaping factor; Default = 1: no change)</font></p>						<p><font face="Courier New"><b>-a</b><i>amplitude</i> (int) start amplitude level, Default = 15000</font></p>						<p><font face="Courier New"><b>-v</b><i>ampfactor</i> (int) amplitude shaping factor; Default = 0: no change</font></p>						<p><font face="Courier New"><b>-f</b><i>frequency</i> (double) frequency of ALL note events (Hz)</font></p>						<p><font face="Courier New"><b>-b</b><i>risetime</i> (double) envelope rise time, Default = 0.5</font></p>						<p><font face="Courier New"><b>-e</b><i>decaytime</i> (double) envelope decay time, Default = 0.5</font></p>						<p><font face="Courier New"><b>-t</b><i>processtype</i> (int) processing type</font></p>					</dir>					<p><font face="Courier New">0 ADD FIXED VALUE to initial value</font></p>					<p><font face="Courier New">1 RAND factors affect the resultant values</font></p>					<p><font face="Courier New">3 LINEAR series (add accumulating result of)</font></p>					<p><font face="Courier New">2 LOGARITHMIC series (not implemented)</font></p>					<p><font face="Courier New">4 EXPONENTIAL (not implemented)</font></p>					<dir>						<p><font face="Courier New"><i>outscore.sc</i> Csound scorefile produced by the program</font></p>					</dir>				</dir>			</dir>			<p><font face="Times New Roman">Defaults produce smoothly changing timbres, with 2 sec note events and start times advancing by 1 sec.</font></p>			<p><font face="Times New Roman">Command line using defaults could be e.g.:</font></p>		</div>		<dir>			<dir>				<p><b><font face="Courier New">cs14ptls -n</font></b><font face="Courier New"><i>10 </i><b>-f</b><i>261.63 ptlssc.sc</i></font></p>			</dir>		</dir>		<div align="justify">			<p><font face="Times New Roman">Example full command line:</font></p>		</div>		<dir>			<dir>				<p><b><font face="Courier New">cs14ptls -n</font></b><font face="Courier New"><i>10 </i><b>-s</b><i>1.2 </i><b>-d</b><i>1.5 </i><b>-a</b><i>24000 </i><b>-v</b><i>550 </i><b>-f</b><i>110 </i><b>-b</b><i>0.75 </i><b>-e</b><i>0.75 </i><b>-t</b><i>0 ptlssc.sc</i></font></p>			</dir>		</dir>		<h3><font face="Times New Roman"><b>Description</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">This program provides one way to experiment with timbral change over time. The context is additive synthesis, and through the combination of <i>Csound's</i> ability to mix note events if they overlap in time, and <i>Cscore's</i> ability to handle data algorithmically, the results can be manipulated with both flexibility and algorithmic precision.</font></p>			<p><font face="Times New Roman"><i>The key is that the program generates both the f-statements and the note events,</i> providing a number of user inputs with which to guide the result. The f-statements are created from a partials-weighting matrix within the program (the <i>str[]</i> two-dimensional array), which is used with GEN10. The weights assigned to the partials (which could be zero to cancel certain ones) is of course critical to the tonal result. Remember that GEN10 deals with 'harmonic' partials: i.e., the next partial being weighted is the next integer multiple of the fundamental &#151; there is no reason why this program couldn't be adapted to handle other GEN routines. Now that's interesting!</font></p>			<p><font face="Times New Roman">It is also important that <i>rise</i> and <i>decay</i> parameters are provided. This affects the degree of smoothness with which the partials move in and out of each other, though the degree of difference between adjacent f-statements is also a factor. (Remember to create an orchestra that uses these pfields.)</font></p>			<p><font face="Times New Roman">The random function could be seeded so that the start times would be identical for both f- and i-statements. This would keep them coordinated! As the program stands, the start times of the f- and i-statements vary marginally. This does not bother <i>Csound</i>, which happily compiles the score without complaining.</font></p>			<p><font face="Times New Roman">It also compiled the score when the f-statement calls were randomised, but it was a bit bothered when calls to the same f-statement followed each other (and overlapped in time?): it zeroed all the additional (overlapping?) note statements which called the same function, causing gaps in the output sound. This makes the result really very random, and I've removed this feature. But it's easily put back by applying the random function to the f-statement number pfield in the note events: e.g., <i>if(ptype == RAND) {</i> etc. The lines of code for this are still in the program, but commented out.</font></p>		</div>		<h3><font face="Times New Roman"><b>Using the Program</b></font></h3>		<div align="justify">			<p><font face="Times New Roman">The purpose of this program is to provide a way to create tones which flow smoothly (and possibly unpredictably) in and out of varying types of timbral colour and degrees of richness. One could compare it with ADSYN DRAW which can achieve similar results. Somehow, though, it seems to be different, but I haven't used it enough yet to be able to say how.</font></p>			<p><font face="Times New Roman">Note that the way I've set up the weighting of the GEN10 partials in <i>str[]</i> is only one way to do it. Such a matrix could be conceived in an infinite variety of ways, depending on the results desired. For example, all equal full strength weightings would produce a timbrally rich square wave, all odd or all even partials (with the others set to 0) would produce quite different tones, etc., and of course these can be mixed either to produce gradual or more sharply delineated changes between the types of tones. Thinking about these possibilities opens up the imagination to the potential of this program.</font></p>			<p><font face="Times New Roman">Further development cries out for placing the f-statement two-dimensional matrix into a text file to be read into the program so that it can be adjusted without having to recompile.</font></p>		</div>		<p><font face="Times New Roman">&nbsp;</font>	</body></html>