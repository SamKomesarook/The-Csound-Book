Release Notes for 4.15
======================

A set of corrections to the changes in 4.14 (mislabelled as 4.13).


Bug Fixes
---------

pvanal in pvx mode allows for duration

internal changes to adsr

Bug in reading analysis file on macintosh fixed

Csound will again run without a csoudn.xmg file -- and defaults to
English (not American)


Language Changes
----------------

In extented pvoc file it now recognises .pvx in all case variations


Opcode Fixes
------------

soundin was incorrectly specified in entry table

Endianness problem in 24bit sound fixed

schedkwhen now allows deferred action turnoff

minor fix in adsr

Buf in spat3d fixed


New Opcodes 
-----------

tempoval -- read current value of tempo if beatmode is on, or 60 if not
biquada -- just like biquad except the parameters are all a-rate
vibrato, vibr -- Vibrato opcodes
jitter, jitter2, jspline -- Jitter opcodes
oscbnk -- an oscilator bank
cpstun, cpstuni -- another micro-tuning opcode
 

Other Changes:
-------------

Known Bugs
==========

The following bugs are known but not yet fixed

1: Large scores do not always extend correctly
2: ADSR can go wrong
3: Convolve files on Mac not recognised
4: reported bug in spat3di (mail of Sun, 26 Aug 2001 22:47:37 -0400)
5: Bug in linseg at k-rate (mail of Wed, 15 Aug 2001 19:59:48 +0100)
6: PVOC can glitch (mail of Mon, 19 Jun 2000 00:45:23 +0200)


Windows GUI Changes
-------------------

Can now select 24bit output and floats; the GUI was confused and so
there are some layout changes

-----------------------------------------------------------------------
==John ff
  2001 September
========================================================================
cpstun, cpstuni

kcps cpstun ktrig, kindex, kfn
icps cpstuni index, ifn

INITIALIZATION

icps - return value in cps
index - an integer number denoting an index of scale
ifn - function table containing the parameters (numgrades, interval,
basefreq, basekeymidi) and the tuning ratios.

PERFORMANCE

kcps - return value in cps
ktrig - a trigger signal used to trigger the evaluation
kindex - an integer number denoting an index of scale
kfn - function table containing the parameters (numgrades, interval,
basefreq, basekeymidi) and the tuning ratios.

These opcodes are similar to cpstmid, but work without necessity of
MIDI.

cpstun works at k-rate, while cpstuni at init-rate. They allow
fully customized micro-tuning scales. They requires a function table number
containing the tuning ratios, and some other parameters stored in the function
table itself.

kindex and index arguments should be filled with integer numbers
expressing the grade of given scale to be converted in cps. In cpstun,
a new value is evaluated only when ktrig contains a non-zero value.
The function table ifn (or kfn) should be generated by GEN2
and the first four values stored in this function are parameters that express:

numgrades (the number of grades of the micro-tuning scale),

interval (the frequency range covered before repeating the
grade ratios, for example 2 for one octave, 1.5 for a fifth etcetera),

basefreq (the base frequency of the scale in cps), 
basekey (the integer index of the scale to which to assign
basefreq unmodified).

After these four values, the user can begin to insert the tuning ratios.
For example, for a standard 12-grade scale with the base-frequency of 261
cps assigned to the key-number 60, the corresponding f-statement in the score
to generate the table should be:
;           numgrades    basefreq     tuning-ratios (eq.temp) ....... 
;                  interval    basekey
f1 0 64 -2  12     2     261   60     1   1.059463 1.12246 1.18920 ..etc...

Another example with a 24-grade scale with a base frequency of 440 assigned
to the key-number 48, and a repetition interval of 1.5:
                  numgrades       basefreq      tuning-ratios .......  
                          interval       basekey
f1 0 64 -2         24      1.5     440    48     1   1.01  1.02  1.03   ..etc...

------------------------------------------------------------------------

ar	oscbnk kcps, kamd, kfmd, kpmd, iovrlap, iseed,			       \
		kl1minf, kl1maxf, kl2minf, kl2maxf, ilfomode,		       \
		keqminf, keqmaxf, keqminl, keqmaxl, keqminq, keqmaxq, ieqmode, \
		kfn, il1fn, il2fn, ieqffn, ieqlfn, ieqqfn[, itabl[, ioutfn]]

DESCRIPTION
===========

This unit generator mixes the output of any number of oscillators. The
frequency, phase, and amplitude of each oscillator can be modulated by two
LFOs (all oscillators have a separate set of LFOs, with different phase and
frequency); additionally, the output of each oscillator can be filtered
through an optional parametric equalizer (also controlled by the LFOs).
This opcode is most useful for rendering ensemble (strings, choir, etc.)
instruments.
Although the LFOs run at k-rate, amplitude, phase and filter modulation are
interpolated internally, so it is possible (and recommended in most cases)
to use this unit at low (~1000 Hz) control rates without audible quality
degradation.
The start phase and frequency of all oscillators and LFOs can be set by
a built-in seedable 31-bit random number generator, or specified manually in
a function table (GEN2).

INITIALIZATION
==============

iovrlap - number of oscillator units.

iseed - seed value for random number generator (positive integer in the range
  1 to 2147483646 (2^31 - 2)).

ilfomode - LFO modulation mode, sum of:
    128: LFO1 to frequency
     64: LFO1 to amplitude
     32: LFO1 to phase
     16: LFO1 to EQ
      8: LFO2 to frequency
      4: LFO2 to amplitude
      2: LFO2 to phase
      1: LFO2 to EQ
  If an LFO does not modulate anything, it is not calculated, and the ftable
  number (il1fn or il2fn) can be omitted.

ieqmode - parametric equalizer mode
     -1: disable EQ (faster)
      0: peak
      1: low shelf
      2: high shelf
      3: peak (filter interpolation disabled)
      4: low shelf (interpolation disabled)
      5: high shelf (interpolation disabled)
  The non-interpolated modes are faster, and in some cases (e.g. high shelf
  filter at low cutoff frequencies) also more stable; however, interpolation
  is useful for avoiding "zipper noise" at low control rates.

il1fn - LFO1 function table number. The waveform in this table has to be
  normalized (absolute value <= 1), and is read with linear interpolation.

il2fn - LFO2 function table number. The waveform in this table has to be
  normalized, and is read with linear interpolation.

ieqffn, ieqlfn, ieqqfn - lookup tables for EQ frequency, level, and Q (optional
  if EQ is disabled). Table read position is 0 if the modulator signal is less
  than, or equal to -1, (table length / 2) if the modulator signal is zero, and
  the guard point if the modulator signal is greater than, or equal to 1. These
  tables have to be normalized to the range 0 - 1, and have an extended guard
  point (table length = power of two + 1). All tables are read with linear
  interpolation.

itabl - function table storing phase and frequency values for all oscillators
  (optional). The values in this table are in the following order (5 for each
  oscillator unit):

  oscillator phase, lfo1 phase, lfo1 frequency, lfo2 phase, lfo2 frequency, ...

  All values are in the range 0 to 1; if the specified number is greater than 1,
  it is wrapped (phase) or limited (frequency) to the allowed range. A negative
  value (or end of table) will use the output of the random number generator.
  The random seed is always updated (even if no random number was used), so
  switching one value between random and fixed will not change others.

ioutfn - function table to write phase and frequency values (optional). The
  format is the same as in the case of itabl. This table is useful when
  experimenting with random numbers to record the best values.

PERFORMANCE
===========

ar - output signal.

kcps - oscillator frequency in Hz.

kamd - AM depth (0 - 1).
  (AM output) = (AM input) * ((1 - (AM depth)) + (AM depth) * (modulator))
(Note: amplitude modulation is applied before the parametric equalizer.)

kfmd - FM depth (in Hz).

kpmd - phase modulation depth.

kl1minf, kl1maxf - LFO1 minimum and maximum frequency in Hz.

kl2minf, kl2maxf - LFO2 minimum and maximum frequency in Hz.
(Note: oscillator and LFO frequencies are allowed to be zero or negative.)

keqminf, keqmaxf - parametric equalizer minimum and maximum frequency in Hz.

keqminl, keqmaxl - parametric equalizer minimum and maximum level.

keqminq, keqmaxq - parametric equalizer minimum and maximum Q.

kfn - oscillator waveform table. Table number can be changed at k-rate (this
  is useful to select from a set of band-limited tables generated by GEN30,
  to avoid aliasing). The table is read with linear interpolation.

AUTHOR
======

Istvan Varga
2001

------------------------------------------------------------------------
kout vibrato kAverageAmp, kAverageFreq, kRandAmountAmp, kRandAmountFreq,
kAmpMinRate, kAmpMaxRate, kcpsMinRate, kcpsMaxRate, ifn [, iphs]

kout vibr kAverageAmp, kAverageFreq, ifn

kout jitter kamp, kcpsMin, kcpsMax
kout jitter2 ktotamp, kamp1, kcps1, kamp2, kcps2, kamp3, kcps3

DESCRIPTION

These opcode are designed to make sounds more natural to hearing.
vibrato and vibr generates a vibrato-like signal containing
some user-controlled randomness in amplitude and frequency; jitter
and jitter2 produces some deviation to be summed to constant signals
to make them more "analog-like" and natural.

INITIALIZATION

ifn - number of vibrato table. It normally contains a sine or a triangle
wave.

iphs (optional) - initial phase of table, expressed as a fraction
of a cycle (0 to 1). A negative value will cause phase initialization to
be skipped. The default value is 0.

PERFORMANCE

kAverageAmp - average amplitude value of vibrato
kAverageFreq - average frequency value of vibrato (in cps)
kRandAmountAmp - amount of random amplitude deviation
kRandAmountFreq - amount of random frequency deviation
kAmpMinRate - minimum frequency of random amplitude deviation segments
(in cps)
kAmpMaxRate - maximum frequency of random amplitude deviation segments
(in cps)
kcpsMinRate - minimum frequency of random frequency deviation segments
(in cps)
kcpsMaxRate - maximum frequency of random frequency deviation segments
(in cps)

kamp - amplitude of jitter deviation
kcpsMin -  minimum speed of random frequency variations (expressed
in cps)
kcpsMax - maximum speed of random frequency variations (expressed
in cps)

ktotamp - resulting amplitude of jitter2
kamp1 - amplitude of the first jitter component
kcps1 - speed of random variation of the first jitter component (expressed
in cps)
kamp2 - amplitude of the second jitter component
kcps2 - speed of random variation of the second jitter component
(expressed in cps)
kamp3 - amplitude of the third jitter component
kcps3 - speed of random variation of the third jitter component (expressed
in cps)

vibrato outputs a natural-sounding user-controllable vibrato. The
concept is to randomly vary both frequency and amplitude of the oscillator
generating the vibrato, in order to simulate the irregularities of a
real vibrato. In order to have a total control of these random variations,
several input arguments are present. Random variations are obtained by two
separated segmented lines, the first controlling amplitude deviations, the
second the frequency deviations. Average duration of each segment of each
line can be shortened or enlarged by the arguments kAmpMinRate, kAmpMaxRate,
kcpsMinRate, kcpsMaxRate, and the deviation from the average amplitude
and frequency values can be independently adjusted by means of
 kRandAmountAmp and kRandAmountFreq.

vibr is an easier-to-use version of vibrato. It has the same
generation-engine of vibrato, but the parameters corresponding to
missing input arguments are hard-coded to default values.

jitter generates a segmented line whose segments are randomly generated
inside the +kamp and -kamp interval. Duration of each segment is a random
value generated according to kcpsmin and kcpsmax values.

jitter2 also generates a segmented line such as jitter, but
in this case the result is similar to the sum of three randi opcodes,
each one with a different amplitude and frequency value (see randi
for more details), that can be varied at k-rate. Different effects can be
obtained by varying the input arguments.

jitter and jitter2 can be used to make more natural and
"analog-sounding" some static, dull sound. For best results, It is suggested
to keep their amplitude moderate.

------------------------------------------------------------------------

kr jspline kamp, kcpsMin, kcpsMax
ar jspline xamp, kcpsMin, kcpsMax

kr rspline krangeMin, krangeMax, kcpsMin, kcpsMax
ar rspline xrangeMin, xrangeMax, kcpsMin, kcpsMax

DESCRIPTION

Generate random spline curves

INITIALIZATION

no init args

PERFORMANCE

kr, ar - output signal
xrangeMin, xrangeMax - range of values of random-generated points
kcpsMin, kcpsMax -  range of point-generation rate. Min and max
limits are expressed in cps.
xamp - amplitude factor

jspline (jitter-spline generator) generates a smooth curve based on
random points generated at [cpsMin, cpsMax] rate.  This
opcode is similar to randomi or randi or jitter, but
segments are not stright lines, but cubic spline curves. Output value range
is approximately > -xamp and < xamp. Actually, real range
could be a bit greater, because of interpolating curves beetween each pair
of random-points.

rspline (random-spline-curve generator) is similar to jspline
but output range is defined by means of two limit values. Also in this case,
real output range could be a bit greater of range values, because of
interpolating curves beetween each pair of random-points.

At present time generated curves are quite smooth when cpsMin is not
too different from cpsMax. When cpsMin-cpsMax interval is big,
some little discontinuity could occurr, but it should not be a problem, in
most cases. Maybe the algorithm will be improved in next versions.

These opcodes are often better than jitter when user wants to "naturalize"
or "analogize" digital sounds. They could be used also in algorithmic
composition, to generate smooth random melodic lines when used together with
samphold opcode.

Note that the result is quite different from the one obtained by filtering
white noise, and they allow the user to obtain a much more precise control.
------------------------------------------------------------------------
