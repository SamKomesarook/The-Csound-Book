Release Notes for 4.20======================Bug Fixes---------After #include in scores a character was ignoredmessage 1704 was wrongwgclar could fail to be proberly initialised leading to silencecubic interpolation in tablexkt fixedLanguage Changes----------------MIDI format 1 now allowed if single trackSADIR searched in pvoc pvt caseThere is a new global variable 0dbfs (starting with a zero character).This defaults to 32768 so things shoudl behave as before.  It can beused to set the value for full scale 0db, affecting things like Peakchunks, reporting of over range etc.  Thsi is believed to work fullyfor all 16 and 24 bit formats.  No guarantees with 8bit formats.Opcode Fixes------------diskin -- fix in 64bit modeNew Opcodes -----------waveterr -- an imprememtation of wave terrain synthesisMIDI changes: midinoteoff, midinoteonkey, midinoteoncps,midinoteonoct, midinoteonpch, midipolyaftertouch, midicontrolchange,midiprogramchange, midichannelaftertouch, midipitchbend, mididefault-- allow mixed MIDI/score instrumentsxscanmap -- extending xscan familyclfilt -- a ramge of flexible classical filtermidichn, pgmassignscantable, scanhammerb -- alternative and simpler implementations ofscanned synthesisNew Gens--------noneOther Changes:-------------Revised GEN30: This new version of GEN30 fixes a bug which caused"minh" to be scaled by "ref_sr", even though according to the specs itshould scale "maxh" only. Also, if "ref_sr" is zero, or negative, itis now ignored.A new optional argument "interp" was added, which, if non-zero, allowschanging the amplitude of the lowest and highest harmonic partialdepending on the fractional part of "minh" and "maxh"; for example, if"maxh" is 11.3, the 12th harmonic partial is added with 0.3amplitude. This parameter is zero by default.The syntax with the new argument is:  f  # time size  30  src minh maxh [ref_sr[ interp]]-------There are many internal changes moving towards better reentrance.Known Bugs==========The following bugs are known but not yet fixed 9still!)6: PVOC can glitch (mail of Mon, 19 Jun 2000 00:45:23 +0200)8. Spaces in arguments to opcodes can be ignored, giving oddities9. Mismatched closing bracket can give crash (mail of Fri, 19 Oct 2001   19:00:56 +0100) Windows GUI Changes-------------------Continued attempts to stop the crash on exit.......Jubilee Day, 2002-----------------------------------------------------------------------MIDI INTEROPERABILITY OPCODESmidinoteoff    xkey, xvelocitymidinoteonkey   xkey, xvelocitymidinoteoncps   xcps, xvelocitymidinoteonoct   xoct, xvelocitymidinoteonpch   xpch, xvelocitymidipolyaftertouch  xpolyaftertouch, xcontrollervalue [,                                olow, hhigh]midicontrolchange,  xcontroller, xcontrollervalue [, olow,                                hhigh]midiprogramchange  xprogrammidichannelaftertouch  xchannelaftertouch [, olow, hhigh]midipitchbend   xpitchbend [, olow, hhigh]mididefault   xdefault, xvalueDescriptionThese opcodes are designed to simplify writing instruments that can beused interchangeably for either score or MIDI input,and to make it easier to adapt instruments originally written for scoreinput to work with MIDI input.In general, it should be possible to write instrument definitions thatwork identically with both scores and MIDI,including both MIDI files and real-time MIDI input, without using anyconditional statements,and that take full advantage of MIDI voice messages.Note that correlating Csound instruments with MIDI channel numbers isdone using the massign opcode for real-time performance,.For file-driven performance, instrument numbers default to MIDI channelnumber + 1, but the defaults are overriddenby any MIDI program change messages in the file.Initializationxkey - returns MIDI key during MIDI activation, remains unchangedotherwisekcps - returns MIDI key translated to cycles per second during MIDIactivation, remains unchanged otherwisexoct - returns MIDI key translated to linear octaves during MIDIactivation, remains unchanged otherwisexpch - returns MIDI key translated to octave.pch during MIDI activation,remains unchanged otherwisexvelocity - returns MIDI velocity during MIDI activation, remainsunchanged otherwisexpolyaftertouch - returns MIDI polyphonic aftertouch during MIDIactivation, remains unchanged otherwisexcontroller - specifies a MIDI controller numberxcontrollervalue - returns the value of the MIDI controller during MIDIactivation, remains unchanged otherwisexprogram - returns the MIDI program change value during MIDI activation,remains unchanged otherwisexchannelaftertouch - returns the MIDI channel aftertouch during MIDIactivation, remains unchanged otherwisexpitchbend - returns the MIDI pitch bend during MIDI activation, remainsunchanged otherwisexdefault - specifies a default value that will be used during MIDIactivationxvalue - overwritten by xdefault during MIDI activation, remainsunchanged otherwiseolow - optional low value after rescaling, defaults to 0.hhigh - optional high value after rescaling, defaults to 127.Performancefor the first 10 opcodes, if the instrument was activated by MIDI input,the opcode overwrites the value of the "x" input variable(s) with thecorresponding value from MIDI input.If the instrument was NOT activated by MIDI input, the value of the "x"input variable(s) remains unchanged.This enables score pfields to receive MIDI input data during MIDIactivation, and score values otherwise.For the mididefault opcode, if the instrument was activated by MIDIinput,the opcode will overwrite the value of xvalue with the value ofxdefault.If the instrument was NOT activated by MIDI input, xvalue will remainunchanged.This enables score pfields to receive a default value during MIDIactivation, and score values otherwise.To adapt an ordinary Csound instrument designed for score activation forscore/MIDI interoperability:1. Change all linen, linseg, and expseg opcodes to linenr, linsegr,and expsegr, respectively, except for a de-clicking or damping envelope. This will not materially change score-driven performance.2. Add the following lines at the beginning of the instrumentdefinition:  mididefault 60, p3 ; Ensures that a MIDI-activated instrumentwill have a positive p3 field. midinoteoncps p4, p5 ; Puts MIDI key translated to cycles persecond into p4, and MIDI velocity into p5 Obviously, midinoteoncps could be changed to midinoteonoct orany of the other options, and the choice of pfields is arbitrary. Author:  Michael Gogins  gogins@pipeline.comEXAMPLE INTEROPERABLE INSTRUMENTinstr 5 ; Dynamic FM with comb filter, Michael Gogins; PFIELDS.   mididefault  20, p3   midinoteonoct p4, p5iattack   =    0.003idecay   =    0.125isustain   =     p3irelease   =     0.5p3    =     iattack + idecay +isustain + ireleaseifrequency   =     cpsoct(p4); Normalize so iamplitude for p5 of 80 == ampdb(80).iamplitude   =     ampdb(p5) * 15848.926 /18282ijunk6   =     p6; Constant-power pan.ipi    =     4.0 * taninv(1.0)iradians   =     p7 * ipi / 2.0itheta   =     iradians / 2.0; Translate angle in [-1, 1] to left and right gain factors.irightgain   =     sqrt(2.0) / 2.0 *(cos(itheta) + sin(itheta))ileftgain   =     sqrt(2.0) / 2.0 *(cos(itheta) - sin(itheta))ijunk8   =     p8ijunk9   =     p9ijunk10   =     p10ijunk11   =     p11; INITIALIZATIONicosinetable  =     42icarrier1   =     0.998icarrier2   =     1.002ifmamplitude  =     12.5 * (iamplitude / 32767.0)index   =     0.375ilooptime   =     0.028ireverbtime  =     0.75; KONTROLkdamping   linseg  0.0, iattack, 1.0, idecay +isustain, 1.0, irelease, 0.0kenvelope0   expsegr   1.0, iattack, 2.0,idecay, 1.3, isustain, 1.1, irelease, 1.0kenvelope   =     kenvelope0 - 1.0kindex   =     index + (kenvelope *ifmamplitude); AUDIOimodulator   =     .01aouta   foscili   iamplitude, ifrequency,icarrier1, imodulator, kindex, icosinetableaoutb   foscili   iamplitude, ifrequency,icarrier2, imodulator, kindex, icosinetableafmout   =     =(aouta + aoutb) * kenvelope *kdamping   outs    ileftgain * afmout,irightgain * afmoutendin------------------------------------------------------------------------ODBFSThe header declaration in an orc would be simply:sr = 44100....0dbfs = 1or0dbfs = 1000or0dbfs = 32767or even0dbfs = 1.0594631i.e. no checks for values given, except for > 0.The default is 32767, so all existing orcs ~should~ work.These calls should all work:        ipeak = 0dbfs asig oscil 0dbfs,freq,1 out  asig * 0.3 * 0dbfs and so on.BIG NB: all the main sample formats are supported, but I haven't got aroundtodealing with the char formats. Probably it's straight-forward...I have tried to cover the main utils - adsyn,lpanal etc. But there arebound to be things missing, sorry.Some of the parsing code is a bit grungy becasue I have a variablewith a leading digit! As for documentation: the usage should be obvious - the main thing isfor people to start to code 0dbfs-relatively (and use the ampdb()opcodes a lot more!), rather than use explicit sample values. Floats written to a file, when 0dbfs = 1, will in effect go throughno range translation at all, so the nunbers in the file are exactlywhat the orc says they are.RWD 31:5:2001------------------------------------------------------------------------Signal Modifiers: Standard Filtersar clfilt   asig, kfreq, itype, inpol[, ikind, ipbr, isba, iskip]ar clbfilt  asig, kufrq, klfrq, itype, inpol[, ikind, ipbr, isba, iskip]clfilt and clbfilt implement the classical standard analog filter types:lowpass and highpass (clfilt) and bandpass and bandstop (clbfilt),with the four classical filter kinds, Butterworth, Chebyshev Type I,Chebyshev Type II, and Elliptical.  The number of poles may be anyeven number from 2 to 80. If you have a need for more than 80 poles, Iwant to know about it.The variables are as follows:asig - The input signalkfreq - The corner frequency for lowpass or highpass.kufrq, klfrq - The upper and lower corner frequencies for bandpass andbandstop.itype - 0 for lowpass, 1 for highpass in clfilt. 0 for bandpass, 1 forbandstop in clbfilt.inpol - The number of poles in the filter. It must be an even numberfrom 2 to 80.ikind - 0 for Butterworth, 1 for Chebyshev Type I, 2 for ChebyshevType II, 3 for Elliptical.        Defaults to 0 (Butterworth)ipbr - The pass-band ripple in dB. Must be greater than 0. It's        ignored by Butterworth and Chebyshev Type II. The default is 1 dB.isba - The stop-band attenuation in dB. Must be less than 0. It's        ignored by Butterworth and Chebyshev Type I. The default is -60 dB.iskip - 0 initializes all filter internal states to 0. 1 skips        initialization. Default 0.Examples: ;Lowpass filter signal a1 with a 10-pole Butterworth at 500 Hza2    clfilt  a1, 500, 0, 10 ;Highpass filter signal a1 with a 6-pole Chebyshev Type Ia2    clfilt  a1, 20, 1, 6, 1, 3 ; at 20 Hz with 3 dB of passband ripple.Eril Spjut------------------------------------------------------------------------