<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>Csound Magazine</title>		<meta name="author" content="Hans Mikelson">		<meta name="summary" content="On-line magazine with articles on Csound for synthesis, signal processing, real-time performance, composing and programming.">		<meta name="keywords" content="csound, Csound, computer music, software synthesizer, software synth, digital signal processing, DSP, dsp, algorithmic composition, fractal music, electro-acoustic, electronica, signal processing, synthesis, sound design, audio programming">		<meta name="keywords" content="csound, Csound, computer music, software synthesizer, software synth, digital signal processing, DSP, dsp, algorithmic composition, fractal music, electro-acoustic, electronica, signal processing, synthesis, sound design, audio programming">	</head>	<body bgcolor="white" text="black" link="#000040" vlink="#264624" alink="#e9ca18">		<table border="0">			<tr>				<td valign="top" colspan="2"><a href="../index.html"><img src="../figures/logosm.jpg" border="0" width="291" height="29"></a></td>			</tr>			<tr>				<td valign="top"><strong>Columns</strong>					<p><a href="../weekly/index.html">Weekly</a></p>					<p><a href="../beginners/index.html">Beginners</a></p>					<p><a href="../synthesis/">Synthesis</a></p>					<p><a href="../processing/index.html">Processing</a></p>					<p>Real-Time</p>					<p><strong>Features</strong></p>					<p><a href="../internals/index.html">Internals</a></p>					<p><a href="../composition/index.html">Composition</a></p>					<p><strong>Departments</strong></p>					<p><a href="../links.html">Links</a></p>					<p><a href="../editorial.html">Editorial</a></p>					<p><a href="../contribute.html">Contribute</a></p>					<p><a href="../past.html">Back Issues</a></p>					<p><a href="http://www.csounds.com/"><img src="../figures/csounds1.gif" border="0" width="88" height="31"></a></td>				<td valign="top">					<h2>A Real-Time CSound Orchestra</h2>					<p><b>Part 1 - Sensing and Storing Audio</b></p>					<p><em>Richard Bowers</em></p>					<p><a href="mailto:richardbowers@kakutopia.fsnet.co.uk">richardbowers@kakutopia.fsnet.co.uk</a><br>					<a href="http://www.kakutopia.fsnet.co.uk">http://www.kakutopia.fsnet.co.uk</a></p>					<p><b>Aim</b></p>					<p>I had always considered CSound to be a strictly &#145;deferred-time&#146; application which somehow resisted real time use because of the computational load put upon the processor by audio-rate number-crunching. However, in recent years the computation speeds on desktop computers have enabled quite sophisticated orchestras to run admirably in a real-time situation. Gabriel Maldonado&#146;s Direct CSound is a real-time-optimised variety of CSound which makes a Pentium PC running Windows a suitable platform for experiment of this kind. He outlines four methods of using CSound in real-time in his chapter &#145;Using real-time Csound MIDI with Windows&#146; from the CSound Book cdrom. The emphasis was on MIDI control and, to serve this end, Gabriel has introduced a large number of opcodes to CSound to extend its MIDI functionality.</p>					<p>This increase in MIDI functionality is a great asset in the real-time situation because it removes the need for a predetermined score and allows for free improvisation to some degree. However, I was looking for a way of removing MIDI from the equation and creating a composing, or improvising, environment which worked with audio material alone &#150; audio which both controlled parameters and provided the sonic material.</p>					<p>What is described below is a kind of &#145;work in progress&#146; insofar as the orchestra is still being developed in the studio. Unlike the traditional way of testing CSound as a score-driven application, real-time tests are usually conducted with unrepeatable (&#145;live&#146;) material and the types of &#145;errors&#146; one is trying to correct are more often stylistic ones, ie. personal decisions about the ways in which your orchestra is changing and presenting your material. One of the joys of using this method is that you are making aesthetic decisions based on varied output &#150; which means that your efforts are directed towards changing the orchestra&#146;s behaviour in a general way.</p>					<p>In this implementation I wanted to avoid the use of direct synthesis (albeit triggered by audio input) from within the orchestra. My feeling was that using deterministic synthesis methods would be at odds with the spirit of the piece and that my attention would be unduly diverted towards fine-tuning synthesis parameters. Signal modification may be used, but only where the signal is unique to the performance- ie. captured &#145;live&#146; audio.</p>					<p>This orchestra is certainly not one which would be useful to others &#145;as is&#146;. It is idiosyncratic and probably contains much that could be written more efficiently by an experienced programmer and certainly more imaginatively by a skilled composer. However, I hope that newcomers to the idea of using CSound in real-time would see potential in some of its aspects, particularly in the way it &#145;captures&#146; the audio.</p>					<p><b>Overview</b></p>					<p>Signal sensing is the system&#146;s &#145;interface&#146; with the outside world. The input signal is tested for amplitude and a signal of sufficient strength will trigger the start of pitch detection and the simultaneous writing of the audio into a table. When the amplitude drops below another threshold the writing stops and pitch detection is switched off. The process is repeated at the next strong signal. These chunks of audio data are stacked up to be retrieved arbitrarily subsequently.</p>					<p>The pitch detection of incoming audio is used to affect the playback of the stored audio. Thus, some degree of control is afforded the performer over the way the stored audio is replayed. Another example of such control is the amplitude sensing, which returns a duration value, determined in performance, to be applied to a cycling envelope over the played-back audio.</p>					<p>As you would expect, there are a number of ways of configuring an orchestra such as this but, briefly, this implementation attempts to:</p>					<ul>						<li>capture incoming audio						<li>capture some of its features						<li>play back looped chunks of this audio						<li>modulate the audio using data derived from the current input					</ul>					<p><b>The Design</b></p>					<p><a href="realtime01.csd">csound csd file</a></p>					<p><u>Amplitude sensing</u></p>					<p>Because there is a need for chopping up the incoming audio into manageable chunks and for applying non-uniform processing to the audio I chose to cook up some form of amplitude thresholding to gate the input. Conditional statements and <b>rms</b> sensing offered this functionality.</p>					<p>Instrument 18 constantly monitors the rms value of the incoming signal, waits for the threshold to be crossed and continues to wait while the rms rises. When the rms starts to drop (after a peak in an attack, for instance) the time is noted and written to <i>gkstart</i>. The flag <i>gkpflag01</i> is set to 1 allowing the instrument to branch to the next section of the instrument and avoid sensing further peaks for the time being. Also the flag triggers another flag within instrument 90. The present instrument then waits for the rms to drop below the lower threshold during which time instrument 90 is doing its work:</p>					<p><font face="Courier">if gkrms&gt;gklow kgoto continue</font></p>					<p>When the lower threshold is crossed the time is noted (<i>gkend</i>), the duration calculated (<i>gkdur=gkend-gkstart</i>) and a cps value calculated (<i>gkdurcps</i>) which shall be used to make an oscillator read a table at a rate which relates to <i>gkdur</i>. The flags and the default value for the threshold are reset.</p>					<p><u>Pitch Detection</u></p>					<p>Instrument 90 waits for a conditional branch to be tripped so that pitch detection can begin. As mentioned above, this happens when instrument 18 hears a strong signal, thus when <i>gkpflag01</i>=1.</p>					<p>The incoming signal (<i>ga1</i>) is fed into the <b>spectrum</b> opcode for conversion into a <i>wsig</i> data type which is, in turn, tracked for pitch and amplitude by <b>specptrk</b>. This opcode returns 0 for pitch (<i>koct</i>) if the signal drops below a certain threshold. This means that an unwanted portamento effect occurs at times, going from 0 cps to the current pitch. To overcome this a statement is included which maintains the previous pitch value if <i>koct</i> becomes zero:</p>					<p><font face="Courier">koct=(koct=0 ? gkproct : koct)<br>					.<br>					.<br>					.<br>					gkproct=koct</font></p>					<p><u>Writing Audio and Data</u></p>					<p>Next, audio (<i>ga1</i>) is written to table 1 using <b>tablew</b>. This process is controlled by a <b>phasor</b> running at a speed which matches the table index numbers to the audio rate:</p>					<p><font face="Courier">and phasor gitabcps<br>					andex=and*gitablen<br>					tablew ga1, andex, 1, 0, 0, 1</font></p>					<p>The constant <i>gitabcps</i> is calculated as 1/(table length/sampling rate) and is calculated once in the header of the orchestra. It is a generally useful constant which represents a cps value for reading table 1 at normal speed.</p>					<p>It is worth noting here that the <b>phasor</b> will hold its last position when the writing stops (ie. when the signal drops below the threshold and the branching avoids the phasor) and will resume from the same position when the next strong signal comes. This means that the chunks of audio can be written contiguously into the table.</p>					<p><b>Figure 1 &#150; Illustrating the relationship between the data table and the audio table: f7 stores the lookup references into f1 enabling arbitrary playback of the segments.</b></p>					<p><img src="1.jpg" alt="Figure1.jpg (28319 bytes)" width="763" height="412"></p>					<p>Another table (f7) is used to store the locations of the starts of each chunk of audio in table 1. The index number (<i>andex</i>) is written to table 7 at location <i>gkdata</i>. <i>gkdata</i>table (see figure 1). is incremented by 1 each time a new chunk is to be written resulting in a table of pointers into the audio</p>					<p>A conditional branch is included to prevent this writing from happening at every k-rate pass:</p>					<p><font face="Courier">if gkpitchflag=gkpitchprev kgoto contin<br>					.<br>					.<br>					.<br>					gkpitchprev=gkpitchflag; note the previous state</font></p>					<p>(In other words, if the flag indicating that writing can take place is still in the same state, don&#146;t carry out this bit again.)</p>					<p>The lines</p>					<p><font face="Courier">gkdata=(gkinxprev&gt;kindexno ? 0 : gkdata)<br>					gkinxprev=kindexno</font></p>					<p>are included to prevent the orchestra from reading old data after wraparound has occurred in table 1. I shan&#146;t say much about this here except that after wraparound occurs the pointers into the table start to become invalid. Rather than wipe the tables I chose to ignore the invalid pointers and audio chunks by resetting the value of <i>gkdata</i>.</p>					<p>The last thing this section does is to reinitialise (<b>reinit</b>) at label <i>segment</i>.</p>					<p><u>Playback</u></p>					<p>So much for the writing. Now let&#146;s take a look at a way of reading the indexing data and its associated audio.</p>					<p>Instrument 90, which runs continually, also includes the playback operations. The aforementioned <b>reinit</b> statement allows a fresh value (<i>inum</i>) to be generated whenever a new chunk is written. <i>inum</i> is used to randomly select a segment for playback:</p>					<p><font face="Courier">gknum rand gkdata-1<br>					.<br>					.<br>					.<br>					inum=int(abs(gknum))</font></p>					<p>The <b>rand</b> opcode is placed outside the reinitialised <i>segment</i> section because reinitialisation will return the same value each time.</p>					<p><i>inum</i> is a positive integer in the range 0 to <i>gkdata</i>-1, in other words any index number into table 7 which holds a valid reference to table 1. For example, (and this is illustrated in figure 1) ten entries have been written to table 7 representing the start indexes of ten chunks of audio in table 1. <i>inum</i> is assigned the number 4 so it reads (using the <b>table</b> opcode) the value of index 4 from table 7. Then the next value is read from table 7 (<i>inum+1</i>). These give us the start and end indexes of the fifth chunk of audio in table 1. These can be converted to values representing the offset and the range of the chunk to be read from table 1:</p>					<p><font face="Courier">ioffset table inum, 7 ; read location inum from f7<br>					inext table inum+1, 7 ; read next value<br>					iplaces=abs(inext-ioffset) ; calculate range</font></p>					<p>Once a chunk has been selected it is played back using the <b>phasor</b> opcode in conjunction with the <b>tablei</b> opcode. After determining some cps for the <b>phasor</b> based on the pitch yielded by the pitchtracker the output of the phasor is used to control the speed of the reading of the chunk of audio:</p>					<p><font face="Courier">kfact1 = kcps/1046.502 ;ratio for kcps using c7 as a base frequency<br>					and2 phasor kfact1/(iplaces/sr)</font></p>					<p>This speed is therefore under the control of the performer to some extent ie. the input pitch at any moment will control the speed of playback via the variable <i>kcps</i>. However, the important part is getting the right range of the table to be read by <i>tablei</i>. An a-rate index (<i>andex2</i>) is established:</p>					<p><font face="Courier">andex2=(and2*iplaces)+ioffset</font></p>					<p>When placed in a <b>tablei</b> opcode reading the audio table this results in the indexes being scanned over the range (<i>iplaces</i>), as established above, after being offset by <i>ioffset</i> places:</p>					<p><font face="Courier">gasig5 tablei andex2, 1, 0, 0, 1</font></p>					<p>Each instance of the looped segment is faded in and out (<i>kenv</i>) to remove glitches. This looped audio is faded out overall (<i>kdec</i>) to silence over a period of time.</p>					<p>One feature that quickly became apparent in the first tests was the rapid build-up of dense material after a minute or so of sparse bursts of activity. The sparseness is attractive so an additional envelope (<i>kspace</i>) was applied to the continuous table read which gave a degree of &#145;white space&#146;. This envelope was controlled by the duration of the incoming audio by inverting <i>gkdur</i> as <i>gkdurcps=1/gkdur.</i></p>					<p><u>Processing</u></p>					<p>Needless to say, since most of CSound&#146;s opcodes can function in realtime there are a great many ways of modulating the sounds being read from the tables. Also, the manner in which the audio is played back is a huge area to be explored and is probably the area bearing the greatest potential from a musical standpoint.</p>					<p>The number and type of operations that can be carried out simultaneously shall depend on hardware and appropriate buffer sizes. Gabriel Maldonado&#146;s documentation gives more on this subject. Also, real-time operations benefit greatly from the optimisations outlined in Chapter 4 of the Csound Book: &quot;Optimising Your CSound Instruments&quot; by Paris Smaragdis.</p>					<p><u>The audio extracts</u></p>					<p>The audio sample demonstrates some of the characteristics of the method. <a href="drums.mp3">Drums.mp3</a> uses short noisy sounds which nevertheless have an influence on pitch. You can hear the changes in pitch being triggered by the input audio (which may also be the output audio being fed back from loudspeakers into the system). Also, looped sounds are audible, demonstrating the orchestra&#146;s ability to select and access the segments in the audio table thanks to the references logged in the data table.</p>					<p><a href="drone.mp3">Drone.mp3</a> serves to illustrate the orchestra&#146;s capability of being calmed down by the performer. A recorder choruses with its previous output. Although not demonstrated in this extract, there will often be a period of transition when old material is being flushed out of the table. This can take some time if the output from loudspeakers is influencing the orchestra&#146;s behaviour. If there is no feedback, then it is merely a case of filling the table with enough audio (in this case about 11 seconds) to overwrite the old data.</p>					<p><u>Conclusion</u></p>					<p>Although some of the methods used in this orchestra may seem somewhat long-winded given the apparent simplicity of the tasks, the need to remove the uniformity from a real time interactive system demands the use of conditional testing and branching, a means for the efficient storage of audio for fast recall and some degree of player control via sensing. Certain sacrifices were made: audio quality can be a bit rough and the finite size of the audio table means that the system&#146;s history is limited by practical choice.</p>					<p>Furthermore, the performance environment plays a considerable part in affecting the quality of the results. The extracts given here were recorded in a small room (about 12 by 10 feet) which gave me the freedom to enrich the sound a little using <b>reverb2</b>. When I carried out tests in a larger space (an old stone-built church) it was difficult to get the right balance of input levels and loudspeaker levels. Also, natural reverberation muddied the sound and stripped away any intimacy the instruments could evoke.</p>					<p>In my next article I intend to demonstrate a more imaginative way of handling the captured audio and to explain my extensions to the functionality of the orchestra to include rhythm and greater performer control.</td>			</tr>		</table>	</body></html>