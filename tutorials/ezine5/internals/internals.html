<html>	<head>		<title>Csound internal mechanics</title>	</head>	<body>		<h1>Csound Program Flow</h1>		<font size="+1"><strong>Notes by rasmus ekman, Feb 1999 (reviewed April 2000)</strong></font>		<p>Somebody wanted to know the main program structure of Csound. If you're going to add new ugens you will not need to look at this section, instead see the manual entry <strong>Adding New Modules to Csound</strong>. This is a brief overview of the orch/score parsers, and the program flow during a Csound run; a list of the functions that are called and in which files they reside. It may be of use to programmers who need to get into the parser or event management mechanisms, and need a map of where to begin looking.<br>		File management, function tables and lots of other essentials are not covered.</p>		<hr>		<h2>CONTENTS</h2>		<ul>			<a href="#OVERVIEW">OVERVIEW</a><br>			<a href="#PREPARATIONS">PREPARATIONS</a><br>			<ul>				<a href="#Parsing_session_options">Parsing session options</a>			</ul>			<ul>				<a href="#Input_file_parsing_the_score">Input file parsing: the score</a>			</ul>			<ul>				<a href="#Input_file_parsing_the_orchestra">Input file parsing: the orchestra</a>			</ul>			<ul>				<a href="#Instrument_templates">Instrument templates</a>			</ul>			<ul>				<a href="#Opcodes_in_instr_templates">Opcodes in instr templates</a>			</ul>			<ul>				<a href="#Preparing_for_the_performance">Preparing for the performance</a>			</ul>			<a href="#PERFORMANCE">PERFORMANCE</a>			<ul>				<a href="#Initialization_of_instr_events">Initialization of instr events</a>			</ul>			<ul>				<a href="#Score_event_input">Score event input</a>			</ul>			<ul>				<a href="#Other_events">Other events</a>			</ul>			&nbsp;<br>			<a href="#CS_H">STRUCTS FROM <b>CS.H</b></a>			<ul>				<tt><a href="#OPDS">OPDS</a> </tt>&nbsp;			</ul>			<ul>				<tt><a href="#EVTBLK">EVTBLK</a> </tt>&nbsp;			</ul>			<ul>				<tt><a href="#INSDS">INSDS</a></tt> &nbsp;			</ul>			<ul>				<tt><a href="#TEXT">TEXT</a> </tt>&nbsp;			</ul>			<ul>				<tt><a href="#OPTXT">OPTXT</a> </tt>&nbsp;			</ul>			<ul>				<tt><a href="#INSTRTXT">INSTRTXT</a> </tt>&nbsp;			</ul>		</ul>		<hr>		<a name="OVERVIEW">		<h2>OVERVIEW</h2>		<p><strong>main(&nbsp;)</strong> (in <strong>Main.c</strong>) collects and checks command line options, opens input files, reads and sorts score etc.</p>		<p>The last few lines of <strong>main(&nbsp;)</strong> calls <strong>otran(&nbsp;)</strong> (in <strong>Otran.c</strong>) and <strong>musmon(&nbsp;)</strong> (in <strong>Musmon.c</strong>).</p>		<p><strong>otran(&nbsp;)</strong> is top of orchestra parsing;</p>		<p><strong>musmon(&nbsp;)</strong> does the score playing or &quot;performance&quot; part.</p>		<p><strong>musmon(&nbsp;)</strong> sets up realtime and/or file output, calls <strong>oload(&nbsp;)</strong> (in <strong>Oload.c</strong>) to initialise all opcodes (get ftables, set defaults etc), and then calls <strong>playevents(&nbsp;)</strong> (in <strong>Musmon.c</strong>), which does the actual performance.</p>		<p>All structs used by Csound to parse the score and orchestra files, and maintain the performance, are declared in the <strong>Cs.h</strong> header file.</p>		<p>Now for some more details.</p>		<hr>		<a name="PREPARATIONS">		<h2>PREPARATIONS</h2>		<a name="Parsing_session_options">		<h3>Parsing session options</h3>		<p><strong>main(&nbsp;)</strong> calls <strong>readOptions(&nbsp;)</strong> (in <strong>one_file.c</strong>) to read the <strong>.csoundrc</strong> file.</p>		<p><strong>argdecode(&nbsp;)</strong> (in <strong>Argdecode.c</strong>) parses the command line. If <strong>Winsound</strong> is invoked, <strong>cwin_args(&nbsp;)</strong> (in&nbsp;<strong>Cwin.cpp</strong>) is called (via <strong>dialog_arguments(&nbsp;)</strong> in Main.c) to show the Winsound dialog. This is the entry point of Winsound performance, which is not covered further here.)</p>		<p>If a <strong>.csd</strong> file is used for orc/score, <strong>read_unified_file(&nbsp;)</strong> (in&nbsp;<strong>one_file.c</strong>) is called to split it into temporary orc/sco files and collect any further program options.</p>		<p>The options for the session is stored in the global variable <strong>O</strong>, of type struct <strong>OPARMS</strong>, (declared&nbsp;in&nbsp;<strong>Cs.h</strong>).</p>		<p>After this, the collected info is checked for consistency (eg of sr/kr/ksmps and output soundfile options) and existence of input files, etc.</p>		<p>Note that any options appearing in several places will overwrite previous assigment of the same value. The order of precedence of options is:</p>		<ul>			<li><strong>.csd</strong> file <strong><csoptions></strong>tag,			<li>command line (or <strong>Winsound</strong> dialog),			<li><strong>.csoundrc</strong> file,			<li>program default value.		</ul>		<a name="Input_file_parsing_the_score">		<h3>Input file parsing: the score</h3>		<p>After program options are collected, main(&nbsp;) calls <strong>scsort(&nbsp;)</strong> (in&nbsp;<strong>Scsort.c</strong>). This short function just calls <strong>sread(&nbsp;)</strong> (in <strong>Sread.c)</strong> to read the score by the section. This function does all textual score preprocessing, including macro expansion, score maths operations, as well as syntax checks.</p>		<p>For each score section, <strong>scsort(&nbsp;)</strong> calls <strong>sort(&nbsp;)</strong>, <strong>twarp(&nbsp;)</strong> and <strong>swrite(&nbsp;)</strong>. Any time-warping (see&nbsp;eg&nbsp;<strong>t&nbsp;</strong>statement) is straightened out in <strong>twarp(&nbsp;)</strong>, and all events are sorted into strict starting-time order. The score event list is then written to a temporary file <strong>score.srt</strong>, which is closed, and then reopened to get new events during program run. (The functions reside in <strong>Twarp.c</strong>, <strong>Sort.c</strong> and <strong>Swrite.c</strong>, respectively.)</p>		<a name="Input_file_parsing_the_orchestra">		<h3>Input file parsing: the orchestra</h3>		<p><strong>otran(&nbsp;)</strong> (in Otran.c) calls <strong>rdorchfile(&nbsp;)</strong> to input the full orchestra text, then it repeatedly calls <strong>getoptxt(&nbsp;)</strong> to get single lines of instrument code (both functions are in <strong>Rdorch.c</strong>).</p>		<p><strong>rdorchfile(&nbsp;)</strong> does the macro collection and substitution, strips comments etc to get clean preprocessed orchestra code. <strong>getoptxt(&nbsp;)</strong> does the orch code parsing and syntax checks.</p>		<p>From the orch text lines, <strong>otran(&nbsp;)</strong> builds a list of instrument templates, ie the sequence of opcode calls that constitute the instrument's performance.</p>		<a name="Instrument_templates">		<h3>Instrument templates</h3>		<p>The text of each <strong>instr</strong>...<strong>endin</strong> block in the orch file is stored in an <a href="#INSTRTXT">INSTRTXT</a> struct. This begins with the equivalent of an <a href="#OPTXT">OPTXT</a>, followed by some info about the instrument (mostly things relevant for memory allocation: number of labels, max number of opcode arguments etc).</p>		<p>The instruments are stored in numerical order in a list. The list is accessible throughout performance either by index to an array of pointers: INSTRTXT<strong>&nbsp;<em>*</em></strong><em>instrtxtp[&nbsp;]</em>; or as a linked list via INSTRTXT<strong>&nbsp;</strong><em>instxtanchor</em>. (The <em>instrtxtp</em> array will contain null pointers for each instr in range 0 through to <em>maxinsno</em> which has not been defined. There used to be a hardcoded maximum number of instruments (200), but this has recently been made dynamic).</p>		<p>The INSTRTXT struct of an instr is used as a template from which each new instrument instance is created as required by score (or other) events. (Note that INSTRTXT pointers are typecast to OPTXT structs as deemed convenient.)</p>		<a name="Opcodes_in_instr_templates">		<h3>Opcodes in instr templates</h3>		<p>The OPTXT-equiv part of the INSTRTXT holds a chain of <a href="#TEXT">TEXT</a> structs. Each TEXT struct holds the arguments for one opcode in the instrument. As they are encountered by the parser (<strong>otran(&nbsp;)</strong>), orchestra variable names (eg <em>garvb</em>, <em>kamp</em> etc) and pointers to their values are stored in four lists:</p>		<ul>			<li>numerical constants (eg &quot;0&quot;, &quot;3.1416&quot;),			<li>global variables (gi/gk/ga&nbsp;type),			<li>instrument label names,			<li>instrument-local variables (i/k/a&nbsp;type), and p-arguments (eg&nbsp;<em>p3</em>)		</ul>		<p>The ARGLST and ARGOFFS in/out lists in the TEXT struct of an opcode contains pointers to the names and the values of opcode arguments in these lists. (The lists are declared locally in Otran.c, some relevant structs and constants are in <strong>Oload.h</strong>.)</p>		<p>So, all arguments to an opcode are stored as pointers to the actual constant or variable value in the appropriate list, and their names are also kept around throughout performance. This is set up in <strong>insprep(&nbsp;)</strong> (in&nbsp;<strong>Otran.c</strong>), which is called from <strong>otran(&nbsp;)</strong> after reading the orchestra. (See also the support functions <strong>lgbuild(&nbsp;)</strong>, <strong>plgndx(&nbsp;)</strong> etc in <strong>Otran.c</strong>.)</p>		<a name="Preparing_for_the_performance">		<h3>Preparing for the performance</h3>		<p><strong>musmon(&nbsp;)</strong> sets up realtime and/or file output, and calls <strong>oload(&nbsp;)</strong> (in <strong>Oload.c</strong>) to initialize &quot;instr&nbsp;0&quot;. This is the instrument which contains all <strong>instr</strong>-<strong>endin</strong> blocs and the orchestra header statements. <strong>oload(&nbsp;)</strong> also allocates memory for global names in orch code, data space for all a-rate arguments etc.</p>		<p><strong>musmon(&nbsp;)</strong> then calls <strong>playevents(&nbsp;)</strong> (in <strong>Musmon.c</strong>), which does the actual performance.</p>		<a name="PERFORMANCE">		<hr>		<h2>PERFORMANCE</h2>		<p>playevents(&nbsp;)</strong> collects several kinds of input: MIDI (file or live input) events, score events from the sorted .sco file, or score events started in realtime by various means. The user arguments of each event is passed around in an <a href="#EVTBLK">EVTBLK</a> struct. <strong>playevents(&nbsp;)</strong> switches on the score event type (i,&nbsp;f,&nbsp;s,&nbsp;t&nbsp;etc) to determine action. Most event types except i-&nbsp;(instr) and f-statements (ftables) are handled locally.</p>		<p><strong>playevents(&nbsp;)</strong> also counts up the k-rate clock <em>kcounter</em>, and calls <strong>kperf(&nbsp;)</strong> (in <strong>Insert.c</strong>). <strong>kperf(&nbsp;)</strong> goes through the k-rate opcode list of each active instrument in the playlist (see below), and makes the actual calls to the k- and a-rate opcode functions used by each instrument. It returns to <strong>playevents(&nbsp;)</strong> for each event scheduled from score (instrument turnon, ftable generation, or instrument turnoff). It may also return early if a &quot;realtime&quot; event is detected (this includes MIDI input or MIDI file events, and live text input through a named pipe).</p>		<a name="Initialization_of_instr_events">		<h3>Initialization of instr events</h3>		<p>The INSTRTXT array built up by the orchestra parser holds a raw chain of indexes to the list of opcodes (<strong>opcodlst[&nbsp;]</strong> in <strong>Entry.c</strong>), and all actual opcode arguments input by the user. In performance, however, there is a split between i-time and k-rate opcodes.</p>		<p><strong>playevents(&nbsp;)</strong> starts instrument events by calling <strong>insert(&nbsp;)</strong> (in <strong>Insert.c</strong>), passing the <a href="#EVTBLK">EVTBLK</a> for the concrete event. This function creates or reuses or ties instruments. To get a new instrument performance copy it calls <strong>instance(&nbsp;)</strong> (in&nbsp;<strong>Oload.c</strong>) to allocate memory for opcodes, get ftables etc.		<p>In <strong>instance(&nbsp;)</strong> the requested instrument template (<a href="#INSTRTXT">INSTRTXT</a> struct) is used to init an (<a href="#INSDS">INSDS</a> struct. The INSDS struct has one <a href="#OPDS">OPDS</a> struct chain (&quot;thread&quot;) for i-time opcodes, and one for k-rate (a-rate opcodes are of course called at k-rate). It also has pointers for the lists in which it can appear: The list of all allocated instrument instances in performance, and the list of currently active instr instances.</p>		<p><strong>insert(&nbsp;)</strong> then calls all the i-time opcodes with the user arguments in the concrete EVTBLK to init the instrument for performance.</p>		<p>If there are five events of instr 7, it will thus exist in five (simultaneous or sequentially used) copies throughout the performance. If copies are sequentially used, the instrument data space may be taken over by a later instr copy.</p>		<a name="Score_event_input">		<h3>Score event input</h3>		<p>During performance, <strong>Csound</strong> reads all score events from <strong>score.srt</strong> up until the first event <em>after </em>the present k-cycle. The time of the next score event is calculated in k-cycles, and <strong>kperf(&nbsp;)</strong> is invoked only for the number of k-cycles from present until this next event.</p>		<p>This has two notable consequences: First, because of this setup, the list of future events is not available to Csound during performance, even when they exist in the (sorted) score. Secondly, the onset time of an event can only occur with k-rate precision. The k-time of an event is clipped, not rounded (probably; this <em>could</em> vary for different event sources). Until recently (Csound&nbsp;<strong>4.03</strong>), this would lead to problems with time drift in scores with a single stream of events at a regular tempo of fractional k-cycles (eg drum loop-type scores).</p>		<a name="Other_events">		<h3>Other events</h3>		<p>All other events are called &quot;real-time events&quot; in Csound source code. The presently available types are:</p>		<ul>			<li>MIDI file events (using command line option <strong>-M</strong>)			<li>MIDI live input (using command line option <strong>-F</strong> and <strong>MIDI converters</strong>)			<li>Real-time text line input (through a pipe set with command line option <strong>-L</strong>), and			<li>Orchestra-generated events (<strong>schedwhen</strong>, <strong>schedkwhen</strong>).		</ul>		If any of these methods is used to input events, the program option <strong>O.RTevents</strong> is set, together with a flag for each used event source: O.Midiin, O.FMidiin, O.Linein or O.OrcEvents. <strong>kperf(&nbsp;)</strong> will then check all flagged event sources at k-rate.</p>		<hr>		<h3>This exposition could go on and on, but...</h3>		<p>Most relevant structs are declared in <strong>Cs.h</strong>. As will be evident from the above, they contain pointers to the instrument text, to each other, and to the corresponding opcode functions, so it is fairly easy to see what's going on by single-stepping through a Csound performance in your favourite debugger.</p>		<p>All this is (scantily, but still) commented in the source, so you'll find your way in the program flow. Changing stuff without breaking it is trickier.</p>		<p>&nbsp;</p>		<p>re, 25 Feb 1999 (reviewed April 2000)</p>		<hr>		<a name="CS_H">		<h1>Structs from CS.H</h1>		<hr>		<h2><a name="OPDS">OPDS - in Cs.h</h2>		<p>This struct holds the info for one opcode in a concrete instrument instance in performance.</p>		<pre>typedef struct opds {	struct opds * nxti;	<font color="#008000">/* Next opcode in init-time chain */</font>	struct opds * nxtp;	<font color="#008000">/* Next opcode in perf-time chain */</font>	SUBR	iopadr;  	<font color="#008000">/* Initialization (i-time) function pointer */</font>	SUBR	opadr;   	<font color="#008000">/* Perf-time (k- or a-rate) function pointer */</font>	<a href="#OPTXT">OPTXT</a> 	*optext;	<font color="#008000">/* Orch file template part for this opcode */</font>	<a href="#INSDS">INSDS</a>	*insdshead;	<font color="#008000">/* Owner instrument instance data structure */</font>} <strong>OPDS</strong>;</pre>		<hr>		<h2><a name="EVTBLK">EVTBLK - in Cs.h</h2>		<p>This struct holds the data for one score event.</p>		<pre>typedef struct event {	char	*strarg;	<font color="#008000">/* Original argument list string of event */</font>	char	opcod;		<font color="#008000">/* Event type */</font>	short	pcnt;   	<font color="#008000">/* Number of p-fields */</font>	float	p2orig;  	<font color="#008000">/* Event start time */</font>	float	p3orig;  	<font color="#008000">/* Length */</font>	float	offtim; 	<font color="#008000">/* k-time to turn off this event */</font>	float	p[PMAX+1];	<font color="#008000">/* All p-fields for this event */</font>} <strong>EVTBLK</strong>;</pre>		<hr>		<h2><a name="INSDS">INSDS - in Cs.h</h2>		<p>This struct holds the info for a concrete instrument event instance in performance.</p>		<pre>typedef struct insds {	struct <a href="#OPDS">opds</a> * nxti;	 	<font color="#008000">/* Chain of init-time opcodes */</font>	struct opds * nxtp; 		<font color="#008000">/* Chain of performance-time opcodes */</font>	struct insds * nxtinstance;	<font color="#008000">/* Next allocated instance */</font>	struct insds * prvinstance; 	<font color="#008000">/* Previous allocated instance */</font>	struct insds * nxtact; 		<font color="#008000">/* Next in list of active instruments */</font>	struct insds * prvact;		<font color="#008000">/* Previous in list of active instruments */</font>	struct insds * nxtoff;		<font color="#008000">/* Next instrument to terminate */</font>	FDCH	fdch;		<font color="#008000">/* Chain of files used by opcodes in this instr */</font>	AUXCH	auxch;	 	<font color="#008000">/* Extra memory used by opcodes in this instr */</font>	MCHNBLK *m_chnbp; 	<font color="#008000">/* MIDI note info block if event started from MIDI */</font>	short	m_pitch;	<font color="#008000">/* MIDI pitch, for simple access */</font>	short	m_veloc;	<font color="#008000">/* ...ditto velocity */</font>	short 	xtratim;	<font color="#008000">/* Extra release time requested with </font><strong>xtratim</strong><font color="#008000"> opcode */</font>	short	relesing;	<font color="#008000">/* Flag to indicate we're releasing, test with </font><strong>release</strong><font color="#008000"> opcode */</font>	short	insno;		<font color="#008000">/* Instrument number */</font>	short	actflg; 	<font color="#008000">/* Set if instr instance is active (performing) */</font>	float	offbet;		<font color="#008000">/* Time to turn off event, in score beats */</font>	float	offtim;		<font color="#008000">/* Time to turn off event, in seconds (negative on indef/tie) */</font>	struct insds * nxtolap;	<font color="#008000">/* ptr to next overlapping voice */</font>	<font color="#008000">/* end of overlap */</font>	float	p0;		<font color="#008000">/* Copy of required p-field values for quick access */</font>	float	p1;	float	p2;	float	p3;} <strong>INSDS</strong>;</pre>		<hr>		<h2><a name="TEXT">TEXT, <a name="OPTXT">OPTXT - in Cs.h</h2>		<p>Storage for parsed orchestra code, for each opcode in an <a href="#INSTRTXT">INSTRTXT</a>.</p>		<pre>typedef struct text {	short	linenum;	<font color="#008000">/* Line number in orch file (currently buggy!)  */</font>	short	opnum;		<font color="#008000">/* Opcode index in opcodlst[] */</font>	char	*opcod;		<font color="#008000">/* Pointer to opcode name in global pool */</font>	char	*strarg;	<font color="#008000">/* (Unquoted) file name if needed by opcode */</font>	ARGLST	*inlist; 	<font color="#008000">/* Input arguments (pointer to item in name list) */</font>	ARGLST	*outlist;	ARGOFFS	*inoffs; 	<font color="#008000">/* Input args (index into list of values) */</font>	ARGOFFS	*outoffs;	short	xincod;		<font color="#008000">/* Rate switch for multi-rate opcode functions */</font>	char	intype;		<font color="#008000">/* Type of first input argument (g, k, a, w etc) */</font>	char	pftype;		<font color="#008000">/* Type of output argument (k, a etc) */</font>} <strong>TEXT</strong>;	typedef struct op {	struct op * nxtop;	TEXT	t;} <strong>OPTXT</strong>;</pre>		<hr>		<h2><a name="INSTRTXT">INSTRTXT - in Cs.h</h2>		<p>This struct is filled out by <strong>otran(&nbsp;)</strong> at orch parse time. It is used as a template for instrument events.</p>		<pre>typedef struct instr {	<a href="#OPTXT">struct op</a> * nxtop;		<font color="#008000">/* Linked list of instr opcodes */</font>	<a href="#TEXT">TEXT</a>	t;			<font color="#008000">/* Text of instrument (same as in nxtop) */</font>	short	pmax, vmax, pextrab;	<font color="#008000">/* Arg count, size of data for all opcodes in instr */</font>	short	mdepends;		<font color="#008000">/* Opcode type (i/k/a) */</font>	short	lclkcnt, lcldcnt;	<font color="#008000">/* Storage reqs for this instr */</font>	short	lclwcnt, lclacnt;	short	lclfixed, optxtcount;	long	localen;	long	opdstot;	 	<font color="#008000">/* Total size of </font><a href="#OPDS">opds</a><font color="#008000"> structs in instr */</font>	long	* inslist;		<font color="#008000">/* Only used in parsing (?) */</font>	float	* psetdata;		<font color="#008000">/* Used for </font><strong>pset</strong><font color="#008000"> opcode */</font>	struct <a href="#INSDS">insds</a> * instance;	<font color="#008000">/* Chain of allocated instances of this instr */</font>	struct instr * nxtinstxt;	<font color="#008000">/* Next instrument in orchestra (numerical order) */</font>} <strong>INSTRTXT</strong>;</pre>	</body></html>