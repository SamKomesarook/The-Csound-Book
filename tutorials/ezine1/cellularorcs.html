<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><html>	<head>		<meta name="Generator" content="Cosmo Create 1.0.3">		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">		<meta name="Author" content="Josep M Comajuncosas">		<title>Cellular Orchestras</title>	</head>	<body bgcolor="white">		<p>		<div align="right">			<i>... because there&acute;s life in the zak space</i></div>		&nbsp;</p>		<center>			<h2 align="CENTER">Implementing Cellular Automatas in Csound, with some musical applications</h2>		</center>		<center>			<p align="CENTER"><i><font size="2">&copy; by Josep M Comajuncosas / oct.-dec.&acute;1998</font></i></p>		</center>		<center>			<p align="CENTER"><a href="mailto:gelida@intercom.es"><font size="-1">gelida@intercom.es</font></a></p>		</center>		<center>			<p align="CENTER"><a href="instruments/ca.orc"><font size="2">ca.orc</font></a><font size="2"> <a href="instruments/ca.sco">ca.sco</a></font></p>		</center>		<p><b><font size="2">Abstract </font></b></p>		<p><font size="2">This paper describes how to implement a cellular automata as an algorithm in a Csound instrument for sound synthesis purposes. Other possible applications such as algorithmic composition are not studied. It is mainly concerned with one-dimensional automatas for simplicity, driving banks of oscillators for additive synthesis. Images, sound samples and code are included at the end of the article. </font><br>		&nbsp;</p>		<p><b><font size="2">A (quick) introduction to Cellular Automata theory</font></b></p>		<p><font size="2">&nbsp;A Cellular Automata consists of several single units, called <i>Automatas</i> or <i>Cells</i>, with an initial discrete state, which interact with its adjacent cells following a given rule to get their next states. In One-dimensional automatas you have a row of&nbsp; &quot;cells&quot; which, at every iteration, compute their next state based on their own current state and their neighbour&acute;s state: </font></p>		<center>			<p align="CENTER"><img src="figures/cacomp.jpg" width="641" height="201" sgi_src="/tmp_mnt/home/bull6/hpm/ezine/cacomp.jpg"></p>		</center>		<p><font size="2">The possible variants include both the number of possible states and the number of neighbours taken into account. </font><br>		<font size="2">For example, the 41 Cellular Automata I use assumes 4 possible states for each cell (0,1,2 and 3) and compute their values based on its own state and the states of the first cells located at their right and at their left sides. </font><br>		<font size="2">Assuming <i>cyclic contour conditions</i>, I will consider the first and the last cells to be adjacent, thus getting a continuous cyclical space. </font></p>		<p><font size="2">Usually you compute the next state by table lookup. In this way, you have a table storing the state assigned to every possible result in the computation. Let&acute;s suppose a cell can have 2 possible states, 0 or 1. The maximum allowed result by adding a cell&acute;s state with its first neighbour&acute;s states will be of course 3. Other possibilities are 0,1 or 2. Thus some possible transition tables are </font></p>		<center>			<p align="CENTER"><i>10<b>0</b>0</i></p>		</center>		<center>			<p align="CENTER"><i>01<b>0</b>1</i></p>		</center>		<center>			<p align="CENTER"><i>01<b>1</b>0</i></p>		</center>		<p><font size="2">for example, if you get a value of 2 in the computation, table lookup indexes the 3rd position in the table (starts with 0) giving <b>0</b>,<b>0</b> and <b>1</b> respectively. </font><br>		<font size="2">In my 41CA there are 10 possible states (from 0 to 3*3=9), requiring a transition table with 16 memory locations (the nearest power of two). </font></p>		<p><font size="2">The interest of Cellular Automatas is that such weak local constrains <i>can give rise to large scale structures</i>. Some of them will extinguish or generate chaotic patterns, buth some other show memory and perdurability of their initial structures, with a characteristic fractal behaviour (self similarity). This peculiarities are of evident musical interest. </font><br>		&nbsp;</p>		<h3><font size="2">Automata-controlled additive synthesis</font></h3>		<h4><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Instrument overview</font></h4>		<p><font size="2">The basic idea behind this instrument is to use the cell states from the CA as amplitude values for a bank of oscillators to create a CA-controlled additive synth. This obviously implies that both the Automata and the Additive Synth will have the same&nbsp; number of discrete units (one cell for each oscillator). </font></p>		<center>			<p align="CENTER"><img src="figures/flow.jpg" width="468" height="442" sgi_src="/tmp_mnt/home/bull6/hpm/ezine/flow.jpg"></p>		</center>		<p><font size="2">&nbsp; </font><br>		<font size="2">All the stuff runs in 3 separate instruments for clarity, simplicity and modularity. The communications between instruments is hold via the <i>zak</i> system. </font><br>		<font size="2">You will need one location for the <i>za</i> space which is required to store the waveform generated by the Additive Synth. You will also need as many as 3 times the number of cell states in <i>zk</i> locations, to store both the current and the next cell states for each iteration, as well as to keep track of the phase increments for each oscillator in the additive synth. </font></p>		<p><font size="2">The first instrument initialises the cells of the CA to some values stored in a table. Those values are not important for the long-term evolution of the Automata - at least in theory-, but they can be of great influence during the&nbsp; initial <i>attack transient</i>. It also initialises the phases of the oscillators to more or less random values. This (also in theory) should help to smooth the waveform amplitude, avoiding buzzing timbres and sharp peaks when dealing with harmonic textures and fast iterations. </font></p>		<p><font size="2">This instrument is deactivated just after initialisation has been finished with a<i> turnoff </i>statement. </font></p>		<p><font size="2">The second instrument runs the Cellular Automata. It is controlled by a <i>timout</i> statement which allow the cell computations to be done only once every<i> icell_period</i> seconds. It is therefore quite efficient. I assumed that all the cell transitions must take place syncronously. The instrument reads the cell values from the <i>zk</i> space; for each cell it adds the value of itself and the two neighbours and, via table lookup, it computes the resulting value which will be dependent on the transition rule selected by the user. </font><br>		<font size="2">Several interesting tricks are necessary to run the Automata without problems, most of them related to the periodic contour conditions stated above. </font><br>		<font size="2">Notice also that you will have to switch the pointers (here <i>zk offsets</i>) for each group of cell states at each iteration, the <i>next state</i> becoming the actual&nbsp; <i>previous state,</i> leaving the previous <i>previous state</i> location free to be filled with the next <i>next state</i>. Not much different from the update process in a delay unit in fact. </font></p>		<p><font size="2">The third instrument is the additive engine. To allow a user selectable number of partials, you won&acute;t find hundreds of <i>oscil</i> units here. Instead, it works quite similar to a Phase Vocoder resynthesis routine: it adds the instantaneous value of each oscillator to a common memory location - a <i>za</i> location. This value is computed accessing a sine table indexed by the current phase increment of the oscillator, wich is updated at every pass depending on the oscillator frequency as </font></p>		<p><i>kphase = kfactor * imin_freq/kr</i></p>		<p><font size="2">and weighted by the cell state linked to that oscillator. Notice this process makes<i> ksmps=1 </i>necessary (as well as some conditionals and <i>goto</i>&acute;s throughout the code), but it is anyway much more efficient and flexible thant an <i>oscil</i>&acute;s bank. Of course you can acces any wavetable, not just a sine wave. </font><br>		<font size="2">I had some troubles with the phase update, as it grew bigger and bigger and eventually the wrap feature in the table lookup access crashed. To avoid it I work always with the fractional part of the phase after adding the current phase increment </font></p>		<p><i>zkw frac(kphase+kprev_phase),kzkndx</i><br>		&nbsp;</p>		<h4><font size="2">&nbsp;&nbsp;&nbsp; Frequency mapping</font></h4>		<p><font size="2">A key feature of this design is the flexibility to map the frequencies of the oscillator bank. Once selected the lowest frequency (the frequency assigned to the oscillator n&ordm; 1), the next oscillators can be set to frequencies related to the fundamental either in an additive, a geometric or an exponential relationship. </font><br>		<font size="2">The nomenclature might not be quite standard, so here you have the relationships used to calculate any frequency from the lowest frequency and the &quot;stretch factor&quot; (a factor used to scale the frequencies): </font></p>		<p>additive:<br>		<i>kfactor = (kzkndx+1)*istr</i></p>		<p>geometric:<br>		<i>kfactor pow kzkndx+1,istr</i></p>		<p>exponential:<br>		<i>kfactor pow istr, kzkndx</i><br>		&nbsp;<br>		&nbsp;<br>		<font size="2">Additive and geometric mapping allow both harmonic and inharmonic textures to be created, even chorus effects with small <i>istr</i> factors. Exponential mapping makes it possible to set the oscillator frequencies to any equal-tempered scale, like the usual 12ET and 24ET scales, and also to any ET non-octaviant scale. Thus a great variety of textures can be created with just a single Automata. </font></p>		<h4><font size="2">&nbsp;&nbsp;&nbsp; Creating a quasi-continuous Automata</font></h4>		<p><font size="2">Till now I&acute;ve been using CA allowing up to 4 different internal states. As the Cell states control the amplitude tracks of the Additive Synth without further manipulation, severe amplitude quantisation happens. Of course the Cellular Automata is a discrete system, and this effect is inherent in its nature, but those clicks could be greatly reduced by implementing a CA with float values as the internal cell states and the transition rules. You won&acute;t be able to test visually the Automata with Fractint before, at least by now, but anyway I suggest you to test the instrument with a spectrum analizer. </font><br>		<font size="2">This implementation allows the use of<i>&nbsp; tablei</i> to access the transition rule. In theory the resulting waveform should be smoother provided the transition rule table avoids sharp transitions, but the results weren&acute;t so impressive. </font><br>		&nbsp;</p>		<h4><font size="2">&nbsp;&nbsp;&nbsp; Results</font></h4>		<p><font size="2">First of all a graphic from a 41 CA with rule 0020121303, in fact a sonogram of the rendered waveform made with a spectrum analizer. The most common morphology&nbsp; in this kind of Automata (triangular shapes) is quite notorius, as well as its fractal (self-similar) character. Note also how upper and lower edges are considered neighbours in this implementation: </font><br>		&nbsp;</p>		<center>			<p align="CENTER"><img src="figures/ca41sono1.jpg" width="300" height="176" sgi_src="/tmp_mnt/home/bull6/hpm/ezine/ca41sono1.jpg"></p>		</center>		<p><font size="2">You can compare the graphical output from a program like Fractint with the sonogram of a waveform generated from the same Automata (here with rule 1113110301). I hope you will be able to see their morphological similitudes: </font><br>		&nbsp;</p>		<center>			<table>				<caption><i><font size="-1">Fractint image v. waveform sonogram</font></i></caption>				<tr>					<td><img src="figures/ca41frct0.jpg" width="155" height="110" sgi_src="/tmp_mnt/home/bull6/hpm/ezine/ca41frct0.jpg"></td>					<td><img src="figures/ca41sono0.jpg" width="155" height="110" sgi_src="/tmp_mnt/home/bull6/hpm/ezine/ca41sono0.jpg"></td>				</tr>			</table>		</center>		<p><font size="2">In most cases the waveform generated is someway beetween the result of a morphing timbral texture and that of an algorithmic compositional process, due to the discrete nature of the automata, and to the fact that all the states are updated syncronously. </font><br>		&nbsp;<br>		&nbsp;</p>		<table border="1">			<caption><i>Flying transients</i>&nbsp;</caption>			<tr>				<td><img src="figures/ca41sono2.jpg" align="LEFT" width="155" height="110" sgi_src="/tmp_mnt/home/bull6/hpm/ezine/ca41sono2.jpg"></td>				<td><font size="2">These settings generate a fast moving microtonal (quarter-tone) cluster with 128 oscillators (not sinusoidal) controlled by an organic 41CA with rule 0201200331. mp3 sample <a href="audio/transients.mp3">here </a>(with some compression).&nbsp;</font></td>			</tr>		</table>		<p>&nbsp;<br>		&nbsp;</p>		<table border="1">			<caption>&nbsp; <i>Cellular Vox</i>&nbsp;</caption>			<tr>				<td><img src="figures/ca41sono3.jpg" align="LEFT" width="155" height="110" sgi_src="/tmp_mnt/home/bull6/hpm/ezine/ca41sono3.jpg"></td>				<td><font size="2">With an harmonic texture extending from 60 Hz up to 2.5 KHz these settings simulate a robotic voice quite well, though with some annoying clicks. The 41CA rule used here is 0100102302 and shows a typical behaviour. mp3 sample <a href="audio/vox.mp3">here</a>.</font></td>			</tr>		</table>		<p>&nbsp;<br>		&nbsp;</p>		<center>			<table border="1">				<caption><i>Metallic Cloud&nbsp;</i></caption>				<tr>					<td>&nbsp;<img src="figures/ca41sono4.jpg" align="LEFT" width="155" height="110" sgi_src="/tmp_mnt/home/bull6/hpm/ezine/ca41sono4.jpg">&nbsp;</td>					<td><font size="2">And finally, an inharmonic cluster with a CA being iterated at a quite fast rate. The initial cell states favours the extreme registers. After a clear attack transient the spectrum fills completely resulting in a rich and evolving texture. The rule used is 0112310231. mp3 sample <a href="audio/metallic.mp3">here</a> (with some reverb).</font></td>				</tr>			</table>		</center>		<p>&nbsp;<br>		&nbsp;</p>		<h4><font size="2">&nbsp;&nbsp;&nbsp; Code</font></h4>		<p><i><font size="2">Orc &amp; sco</font></i><font size="2"> </font><br>		<font size="2">Here you can get the orchestra and score implementing the instruments discussed above. </font><br>		<a href="instruments/ca.orc"><font size="2">Cellular orchestra</font></a><font size="2"> </font><br>		<a href="instruments/ca.sco"><font size="2">Cellular score</font></a><font size="2"> </font>		<div align="right">			<i><font size="2">&copy; by </font></i><font size="2">Josep M Comajuncosas</font></div>		<font size="2"></font>		<div align="right">			<font size="2">send comments to:</font></div>		<font size="2"></font>		<div align="right">			<font size="2">gelida@intercom.es</font></div>		<font size="2"></font></p>	</body></html>