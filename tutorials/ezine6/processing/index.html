<html>	<head>		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">		<meta name="author" content="Hans Mikelson">		<meta name="summary" content="On-line magazine with articles on Csound for synthesis, signal processing, real-time performance, composing and programming.">		<meta name="keywords" content="csound, Csound, computer music, software synthesizer, software synth, digital signal processing, DSP, dsp, algorithmic composition, fractal music, electro-acoustic, electronica, signal processing, synthesis, sound design, audio programming">		<meta name="KeyWords" content="csound, Csound, computer music, software synthesizer, software synth, digital signal processing, DSP, dsp, algorithmic composition, fractal music, electro-acoustic, electronica, signal processing, synthesis, sound design, audio programming">		<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">		<title>Csound Magazine</title>	</head>	<body bgcolor="#000000" link="#FF0000" vlink="#B00000" alink="#F38181">		<table border="0" cellspacing="0">			<tr>				<td colspan="3" bgcolor="#000000"><a href="../index.html"><img src="../figures/logosm.gif" border="0" width="295" height="28"></a></td>				<td bgcolor="#000000">&nbsp;</td>			</tr>			<tr>				<td bgcolor="#000000">&nbsp;</td>				<td width="21" background="../bg1.jpg" height="22">&nbsp;</td>				<td background="../bg2.jpg">&nbsp;</td>				<td width="21" background="../bg6.jpg" height="22">&nbsp;</td>			</tr>			<tr>				<td valign="top" rowspan="4" bgcolor="#000000"><font color="#FFFF00"><strong>Columns</strong> </font>					<p><a href="../news/index.html">News</a></p>					<p><a href="../beginners/index.html">Beginners</a></p>					<p><a href="../internals/index.html">Internals</a></p>					<p><a href="index.html">Processing</a></p>					<p><font color="#FFFF00"><strong>Departments</strong></font></p>					<p><a href="../links.html">Links</a></p>					<p><a href="../editorial.html">Editorial</a></p>					<p><a href="../contribute.html">Contribute</a></p>					<p><a href="../past.html">Back Issues</a></p>					<p><a href="http://www.csounds.com/"><img src="../figures/csounds1.gif" border="0" width="88" height="31"></a></p>				</td>				<td rowspan="4" background="../bg5.jpg">&nbsp;</td>				<td valign="top" bgcolor="#FFFFFF">					<h2>An Efficient, Precise Frequency Shifter</h2>					<p><i>Jens Groh</i></p>					<p><a href="mailto:groh@irt.de">groh@irt.de</a></p>					<p><a href="fshift.orc">fshift.orc</a> <a href="fshift.sco">fshift.sco</a> <a href="fshift.mp3">fshift.mp3 (912KB)</a></p>					<p><strong>Overview</strong></p>					<p>In this article I describe how to shift the spectrum of a given signal by a constant frequency offset. Do not mix this up with a shift of the pitch by some musical interval, which would mean: &quot;frequency times x&quot;. What I mean is &quot;frequency plus x&quot;.</p>					<p>Frequency shifting can change the sound drastically; in general, it will convert a harmonic series into an inharmonic one. The example Csound orchestra shows a frequency shifter in a delay loop, resulting in a flanger-like effect which seems to go in only one direction. Thanks to Sean Costello who gave me this idea.</p>					<p><strong>Carrier and Sidebands</strong></p>					<p>Frequency shifting is also referred to as single-sideband modulation (SSB). In radio engineering, SSB is usually interpreted as a special form of amplitude modulation (AM). To see why, let us consider the frequency spectra. First, the original signals:</p>					<p><img src="am_car.gif" align="middle" width="195" height="47"> The spectrum of the unmodulated sinewave &quot;carrier&quot; signal</p>					<p><img src="am_mod.gif" align="middle" width="195" height="47"> The spectrum of a sample &quot;modulator&quot; signal, say, a speech signal</p>					<p>Now, to see what sidebands are, let us have a look at the frequency spectra of some known AM variants:</p>					<p><img src="am_am.gif" align="middle" width="195" height="47"> (1.) &quot;Normal&quot; AM, also called double-sideband modulation</p>					<p><img src="am_dsb.gif" align="middle" width="195" height="47"> (2.) Double-sideband modulation with suppressed carrier</p>					<p><img src="am_ssb.gif" align="middle" width="195" height="47"> (3.) Single-sideband modulation (with suppressed carrier)</p>					<p>While (1.) is easiest to realize with an electronic circuit, and (2.) is easiest for us csounders, namely a simple multiplication of the carrier and the modulator waveform, (3.) is tricky for both analog electronics and digital processing, yet it is the variant we want to have. So, how can it be done? In particular, how do we get rid of the unwanted, in this case the lower, sideband?</p>					<p><strong>Three Methods</strong></p>					<p>The first method, known as the filter method, is not of much use for us. It suffers signal foldover problems at the frequency boundaries 0 and sr/2, which reduces the usable bandwidth. Small frequency offsets would only be possible with a two step shift procedure: Filter - shift up - filter - shift down - filter. I will leave out the details.</p>					<p>The second method, called the phase method, has less bandwidth constraints. It is based on an exotic phase-shifting filter, called Hilbert transformer, which performs a frequency-independent phase shift of 90 degrees. That could be realized with a nonrecursive (FIR) filter of high order, but at the expense of a very high processing load. A different, more efficient concept approximates the phase difference between two signals. It uses two matched recursive (IIR) filters of moderate order; see the <code>hilbert</code> opcode reference. Still these filters are difficult to design, since the phase difference error is crucial for the suppression of the unwanted sideband.</p>					<p>The third and least known method, which will be shown here, was found by Donald K. Weaver. This is the block diagram:</p>					<p><img src="weavr3.gif" width="546" height="274"></p>					<p>The scheme is somewhat more complicated than method 2 but it only needs an ordinary lowpass filters of moderate order, which can be designed with any standard method. Their phase response is irrelevant. You can choose their type and order according to your needs, the only condition is that you must use a pair of identical ones. Besides the two identical filters mentioned, four multipliers and an adder, it contains two &quot;quadrature oscillators&quot;. Now what is that? A quadrature oscillator generates a sine wave and a cosine wave with the same frequency simultaneously. The difference of the frequencies of the two oscillators will be the resulting offset. Without shifting, the oscillators will both operate at sr/4. To achieve a shift, you can adjust either the first or the second oscillator's frequency or both. I will point out the differences later.</p>					<p><strong>Development of the Spectra</strong></p>					<p>In the spectrum diagrams that follow I have chosen the colours so that they indicate the phase - complementary colours correspond to opposite phases in order to give you a hint which spectral components will cancel each other.</p>					<p><img src="phasen.gif" width="136" height="106"></p>					<p>So how does Weaver's method produce the frequency shift? Let us take the following input signal and shift it down:</p>					<p><img src="awin.gif" align="middle" width="235" height="67"></p>					<p>First, the input signal is multiplied (or modulated) with the first oscillator signal. This shifts it up by half the Nyquist frequency = sr/4 and mirrors it:</p>					<p><img src="awq1r.gif" align="middle" width="235" height="67"> Upper branch</p>					<p><img src="awq1i.gif" align="middle" width="235" height="67"> Lower branch</p>					<p>Do not worry about all those mirrored and overlapping spectral components - half of them will be cancelled out later. Next, the filters cut the signal off at half the Nyquist frequency:</p>					<p><img src="aw1fr.gif" align="middle" width="235" height="67"> Upper branch</p>					<p><img src="aw1fi.gif" align="middle" width="235" height="67"> Lower branch</p>					<p>Then the signal is multiplied with the second oscillator signal. This shifts it down again by sr/4 plus the offset and mirrors it again:</p>					<p><img src="awq2r.gif" align="middle" width="235" height="67"> Upper branch</p>					<p><img src="awq2i.gif" align="middle" width="235" height="67"> Lower branch</p>					<p>The adder is where the mirrored components cancel each other, and the result is the frequency-shifted original:</p>					<p><img src="awfs.gif" align="middle" width="235" height="67"></p>					<p>This is how SSB normally behaves. You can see how the lower end of the spectrum is folded around frequency zero. Now look what happens if you leave the second oscillator at sr/4 but adjust the first oscillator. There is a different behaviour at the edge of the spectrum where some spectrum content is shifted off the range [0...sr/2]. Here are all relevant combinations:</p>					<p><img src="awfsdn.gif" align="middle" width="235" height="67"> Shift down, normal SSB</p>					<p><img src="awfsdo.gif" align="middle" width="235" height="67"> Shift down, other variant</p>					<p><img src="awfsun.gif" align="middle" width="235" height="67"> Shift up, normal SSB</p>					<p><img src="awfsuo.gif" align="middle" width="235" height="67"> Shift up, other variant</p>					<p>I decided to introduce a &quot;shift mode&quot; parameter to &quot;morph&quot; continuously between normal SSB (<code>kshfmode=1</code>) and the other variant (<code>kshfmode=0</code>).</p>					<p>I am sure my lowpass filter design can be improved. It was done the &quot;quick and dirty&quot; way with the tools I could find. You may want to design a better one. Go ahead! It should have a cutoff frequency of at most 1/4 of the sampling rate. The better the filter, the better will be the performance, above all in the bass range.</p>					<p><strong>The Csound Code for the Frequency Shifter</strong></p>				</td>				<td rowspan="4" background="../bg8.jpg">&nbsp;</td>			</tr>			<tr>				<td valign="top" bgcolor="#EFFEF9">					<pre>; useful constant:gisr4 = sr * 0.25; global sinewave table for both quadrature oscillators:gisin ftgen 0,0,65536,10,1; global filter coefficients for both filters:; (6th order elliptical filter, fc=0.25sr, in 3 biquad sections)gifc0 = 0.051532459925gifb01 = 1.0gifb11 = 1.6375276435gifb21 = 1.0gifa01 = 1.0gifa11 = -0.93027644018gifa21 = 0.37171017225gifb02 = 1.0gifb12 = 0.56037176307gifb22 = 1.0gifa02 = 1.0gifa12 = -0.40320752514gifa22 = 0.73736786626gifb03 = 1.0gifb13 = 0.19165327787gifb23 = 1.0gifa03 = 1.0gifa13 = -0.15398586410gifa23 = 0.94001488557</pre>				</td>			</tr>			<tr>				<td valign="top" bgcolor="#F9FEEF">					<pre>instr 1 . . .; input waveform:awin = .....; the frequency shift (+/-) in Hertz:kfrqshf = .....; the shift mode: 0.0 ... 1.0 kshfmod = .....; first quadrature oscillator:ko1frq = gisr4 - (1 - kshfmod) * kfrqshfaqo1r oscil 1.0, ko1frq, gisin, 0.25 ; cosineaqo1i oscil 1.0, ko1frq, gisin, 0.0 ; sine; second quadrature oscillator:ko2frq = gisr4 + kshfmod * kfrqshfaqo2r oscil 1.0, ko2frq, gisin, 0.25 ; cosineaqo2i oscil 1.0, ko2frq, gisin, 0.0 ; sine; upper branch:; first multiplier:awq1r = awin * aqo1r; lowpass filter:awf1r biquad awq1r, gifb01, gifb11, gifb21, gifa01, gifa11, gifa21awf2r biquad awf1r, gifb02, gifb12, gifb22, gifa02, gifa12, gifa22awf3r biquad awf2r, gifb03, gifb13, gifb23, gifa03, gifa13, gifa23aw1fr = awf3r * gifc0; second multiplier:awq2r = aw1fr * aqo2r; lower branch:; first multiplier:awq1i = awin * aqo1i; lowpass filter:awf1i biquad awq1i, gifb01, gifb11, gifb21, gifa01, gifa11, gifa21awf2i biquad awf1i, gifb02, gifb12, gifb22, gifa02, gifa12, gifa22awf3i biquad awf2i, gifb03, gifb13, gifb23, gifa03, gifa13, gifa23aw1fi = awf3i * gifc0; second multiplier:awq2i = aw1fi * aqo2i; summing up:awfs = awq2r + awq2i . . .endin</pre>				</td>			</tr>			<tr>				<td valign="top" bgcolor="#FFFFFF"><strong>Applications</strong>					<p>In the example orchestra, a bandpass-filtered noise pulse with exponential decay is the source signal. It is fed into a simple echo loop which contains the frequency shifter. The left and right stereo outputs tap the beginning and the end of the delay chain, respectively. Only ten notes are played in the score, with different parameters. Listen yourself!</p>					<p>Another application could be the frequency modulation of an arbitrary sampled sound, even if it is not coming from an oscillator under your control. You would have to replace <code>kfrqshf</code> by an a-rate variable.</p>					<p>If you replace the addition by a subtraction, the spectrum is inverted, that is, mirrored.</p>					<p>Furthermore, you can experiment with the filters. For example, make them adjustable.</p>					<p><strong>References and Links</strong></p>					<p><i>A Third Method of Generation and Detection of Single-Sideband Signals</i>, Donald K. Weaver Jr., Proc. IRE Dec 1956, pp 1703-1705</p>					<p><a href="http://www.haint.com/sounds/beethoven.html">Sean Costello's application of a frequency shifter</a></p>				</td>			</tr>			<tr>				<td bgcolor="#000000">&nbsp;</td>				<td width="21" background="../bg4.jpg" height="22">&nbsp;</td>				<td background="../bg3.jpg">&nbsp;</td>				<td width="21" background="../bg7.jpg" height="22">&nbsp;</td>			</tr>		</table>	</body></html>